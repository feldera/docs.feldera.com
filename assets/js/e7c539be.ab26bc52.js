"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[7708],{8705:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/feldera-otel-processing-5c128835e11ca02e8b01944e6d4b343b.png"},26914:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/otel-feldera-table-c9d61b0574f8fd47f208ead481e432c9.png"},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>c});var t=n(96540);const r={},o=t.createContext(r);function a(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(o.Provider,{value:s},e.children)}},46877:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"use_cases/otel/preprocessing","title":"Sending OTel data to Feldera","description":"To push data into Feldera, we configure the OpenTelemetry (OTel) Collector to send data to Feldera via HTTP (see: HTTP Ingress Docs).","source":"@site/docs/use_cases/otel/preprocessing.md","sourceDirName":"use_cases/otel","slug":"/use_cases/otel/preprocessing","permalink":"/use_cases/otel/preprocessing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Representing OTel Data","permalink":"/use_cases/otel/representing_otel_data"},"next":{"title":"Extracting High-Level Metrics","permalink":"/use_cases/otel/insights"}}');var r=n(74848),o=n(28453);const a={},c="Sending OTel data to Feldera",i={},l=[{value:"OTel Collector Configuration:",id:"otel-collector-configuration",level:4},{value:"Pre-processing",id:"pre-processing",level:2},{value:"Step 1: Extract Resource-Level Data",id:"step-1-extract-resource-level-data",level:4},{value:"Step 2: Extract Scope-Level Data",id:"step-2-extract-scope-level-data",level:4},{value:"Step 3: Extract Final Metrics and Logs",id:"step-3-extract-final-metrics-and-logs",level:4},{value:"Step 4: Process Spans and Add Derived Fields",id:"step-4-process-spans-and-add-derived-fields",level:4}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",sup:"sup",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"sending-otel-data-to-feldera",children:"Sending OTel data to Feldera"})}),"\n",(0,r.jsxs)(s.p,{children:["To push data into Feldera, we configure the OpenTelemetry (OTel) Collector to send data to Feldera via HTTP (see: ",(0,r.jsx)(s.a,{href:"https://docs.feldera.com/connectors/sources/http",children:"HTTP Ingress Docs"}),")."]}),"\n",(0,r.jsx)(s.h4,{id:"otel-collector-configuration",children:"OTel Collector Configuration:"}),"\n",(0,r.jsx)(s.p,{children:"Here we configure OTel Collector to send logs, traces, and metrics to Feldera as JSON via an HTTP POST request without any compression."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"OTel Collector to Feldera Table",src:n(26914).A+"",width:"684",height:"474"})}),"\n",(0,r.jsx)(s.p,{children:"Configure your OTel Collector as follows:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yml",children:"# src/otel-collector/otelcol-config-extras.yml in OpenTelemetry Demo\n\nexporters:\n\n  # Send traces to the Feldera pipeline.\n  # Currently only uncompressed JSON is supported.\n  otlphttp/feldera:\n     logs_endpoint: http://feldera:8080/v0/pipelines/otel/ingress/otel_logs?format=json&update_format=raw\n     traces_endpoint: http://feldera:8080/v0/pipelines/otel/ingress/otel_traces?format=json&update_format=raw\n     metrics_endpoint: http://feldera:8080/v0/pipelines/otel/ingress/otel_metrics?format=json&update_format=raw\n     encoding: json\n     compression: none\n\nservice:\n   pipelines:\n     traces:\n       receivers: [otlp]\n       processors: [transform, batch]\n       exporters: [spanmetrics, otlphttp/feldera, debug, otlp]\n\n     logs:\n       receivers: [otlp]\n       processors: [batch]\n       exporters: [otlphttp/feldera, debug]\n\n     metrics:\n       receivers: [hostmetrics, docker_stats, httpcheck/frontend-proxy, otlp, prometheus, redis, spanmetrics]\n       processors: [batch]\n       exporters: [otlphttp/feldera, debug]\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Notice that we have the query parameters (see: ",(0,r.jsx)(s.a,{href:"https://docs.feldera.com/formats/json#encoding-data-change-events",children:"JSON Format Docs"}),"): ",(0,r.jsx)(s.code,{children:"format=json&update_format=raw"})]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"format=json"}),": Specifies that the input data is JSON-formatted."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"update_format=raw"}),": Indicates that the request body contains raw data, which Feldera processes as an insertion into the table."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"pre-processing",children:"Pre-processing"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"Preprocessing OTel data in Feldera",src:n(8705).A+"",width:"742",height:"386"})}),"\n",(0,r.jsx)(s.p,{children:"The OTel data format contains data in arrays of fields, we want to convert them into traditional database table rows,\nthis would allow for easier processing in SQL."}),"\n",(0,r.jsxs)(s.p,{children:["We do this by performing a series of ",(0,r.jsx)(s.code,{children:"UNNEST"})," operations."]}),"\n",(0,r.jsx)(s.h4,{id:"step-1-extract-resource-level-data",children:"Step 1: Extract Resource-Level Data"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-sql",children:"-- concat with the previous table definitions\n\n-- (ResouceMetrics[N]) -> (Resource, ScopeMetrics[N])\nCREATE LOCAL VIEW rsMetrics AS SELECT resource, scopeMetrics\nFROM otel_metrics, UNNEST(resourceMetrics) as t (resource, scopeMetrics);\n\n-- (ResouceSpans[N]) -> (Resource, ScopeSpans[N])\nCREATE LOCAL VIEW rsSpans AS SELECT resource, scopeSpans\nFROM otel_traces, UNNEST(resourceSpans) as t (resource, scopeSpans);\n\n-- (ResouceLogs[N]) -> (Resource, ScopeLogs[N])\nCREATE LOCAL VIEW rsLogs AS SELECT resource, scopeLogs\nFROM otel_logs, UNNEST(resourceLogs) as t (resource, scopeLogs);\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Here we ",(0,r.jsx)(s.code,{children:"UNNEST"})," arrays of ",(0,r.jsx)(s.code,{children:"ResourceSpans"}),", ",(0,r.jsx)(s.code,{children:"ResourceMetrics"})," and ",(0,r.jsx)(s.code,{children:"ResourceLogs"})," into separate rows."]}),"\n",(0,r.jsx)(s.h4,{id:"step-2-extract-scope-level-data",children:"Step 2: Extract Scope-Level Data"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-sql",children:"-- (ScopeMetrics[N]) -> (ScopeMetrics) x N\nCREATE LOCAL VIEW metrics_array AS\nSELECT\n    resource,\n    scope,\n    metrics\nFROM rsMetrics, UNNEST(rsMetrics.scopeMetrics) as t(scope, metrics);\n\n-- (ScopeLogs[N]) -> (ScopeLogs) x N\nCREATE LOCAL VIEW logs_array AS\nSELECT\n    resource,\n    scope,\n    logs\nFROM rsLogs, UNNEST(rsLogs.scopeLogs) as t(scope, logs);\n\n-- (ScopeSpans[N]) -> (ScopeSpans) x N\nCREATE LOCAL VIEW spans_array AS\nSELECT\n    resource,\n    scope,\n    spans\nFROM rsSpans, UNNEST(rsSpans.scopeSpans) as t(scope, spans);\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Similarly, we ",(0,r.jsx)(s.code,{children:"UNNEST"})," the ",(0,r.jsx)(s.code,{children:"ScopeMetrics"}),", ",(0,r.jsx)(s.code,{children:"ScopeLogs"})," and ",(0,r.jsx)(s.code,{children:"ScopeSpans"})," into separate rows."]}),"\n",(0,r.jsx)(s.h4,{id:"step-3-extract-final-metrics-and-logs",children:"Step 3: Extract Final Metrics and Logs"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-sql",children:"-- (Metrics[N]) -> (_, Metric) x N\nCREATE MATERIALIZED VIEW metrics AS\nSELECT\n    name,\n    description,\n    unit,\n    sum,\n    summary,\n    gauge,\n    histogram,\n    exponentialHistogram,\n    resource,\n    scope,\n    metadata\nFROM metrics_array, UNNEST(metrics_array.metrics);\n\n-- (Logs[N]) -> (_, Logs) x N\nCREATE MATERIALIZED VIEW logs AS\nSELECT\n    resource,\n    scope,\n    attributes,\n    timeUnixNano,\n    observedTimeUnixNano,\n    severityNumber,\n    severityText,\n    flags,\n    traceId,\n    spanId,\n    eventName,\n    body\nFROM logs_array, UNNEST(logs_array.logs);\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Finally, we have extracted individual ",(0,r.jsx)(s.code,{children:"Metric"})," and ",(0,r.jsx)(s.code,{children:"LogRecords"})," to extract individual records."]}),"\n",(0,r.jsx)(s.h4,{id:"step-4-process-spans-and-add-derived-fields",children:"Step 4: Process Spans and Add Derived Fields"}),"\n",(0,r.jsx)(s.p,{children:"For spans, we not only extract individual records but also compute useful derived fields:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"elapsedTimeMillis"}),": The duration of the span in milliseconds."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"eventTime"}),": Timestamp indicating when the span started",(0,r.jsx)(s.sup,{children:(0,r.jsx)(s.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-sql",children:"-- Convert nanoseconds to seconds\nCREATE FUNCTION NANOS_TO_SECONDS(NANOS BIGINT) RETURNS BIGINT AS\n(NANOS / 1000000000::BIGINT);\n\n-- Convert nanoseconds to milliseconds\nCREATE FUNCTION NANOS_TO_MILLIS(NANOS BIGINT) RETURNS BIGINT AS\n(NANOS / 1000000::BIGINT);\n\n-- Convert to TIMESTAMP type from a BIGINT that represents time in nanoseconds\nCREATE FUNCTION MAKE_TIMESTAMP_FROM_NANOS(NANOS BIGINT) RETURNS TIMESTAMP AS\nTIMESTAMPADD(SECOND, NANOS_TO_SECONDS(NANOS), DATE '1970-01-01');\n\n-- (Spans[N]) -> (Span, elapsedTimeMillis, eventTime) x N\nCREATE MATERIALIZED VIEW spans AS\nSELECT\n    resource,\n    scope,\n    traceId,\n    spanId,\n    tracestate,\n    parentSpanId,\n    flags,\n    name,\n    kind,\n    startTimeUnixNano,\n    endTimeUnixNano,\n    attributes,\n    events,\n    NANOS_TO_MILLIS(endTimeUnixNano::BIGINT - startTimeUnixNano::BIGINT) as elapsedTimeMillis,\n    MAKE_TIMESTAMP_FROM_NANOS(startTimeUnixNano) as eventTime\nFROM spans_array, UNNEST(spans_array.spans);\n"})}),"\n","\n",(0,r.jsxs)(s.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(s.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{id:"user-content-fn-1",children:["\n",(0,r.jsxs)(s.p,{children:["Note that in Feldera, the ",(0,r.jsx)(s.code,{children:"TIMESTAMP"})," type doesn't include time zone information. ",(0,r.jsx)(s.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);