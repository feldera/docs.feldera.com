"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[2628],{5319:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"pipelines/latency","title":"Measuring Pipeline Latency","description":"Incremental View Maintenance (IVM) enables Feldera to quickly incorporate changes to input data into analytical queries.","source":"@site/docs/pipelines/latency.md","sourceDirName":"pipelines","slug":"/pipelines/latency","permalink":"/pipelines/latency","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Efficient Bulk Data Processing using Transactions","permalink":"/pipelines/transactions"},"next":{"title":"Troubleshooting","permalink":"/operations/guide"}}');var r=t(74848),i=t(28453),a=t(11470),l=t(19365);const o={},c="Measuring Pipeline Latency",d={},u=[{value:"Background: Understanding pipeline latency",id:"background-understanding-pipeline-latency",level:2},{value:"Latency metrics",id:"latency-metrics",level:2},{value:"Completion latency (<code>input_connector_completion_latency_seconds</code>)",id:"completion-latency-input_connector_completion_latency_seconds",level:3},{value:"Processing latency (<code>input_connector_processing_latency_seconds</code>)",id:"processing-latency-input_connector_processing_latency_seconds",level:3},{value:"Step latency (<code>dbsp_step_latency_seconds</code>)",id:"step-latency-dbsp_step_latency_seconds",level:3},{value:"Measuring end-to-end latency with input frontiers",id:"measuring-end-to-end-latency-with-input-frontiers",level:2},{value:"Example",id:"example",level:3},{value:"Related topics",id:"related-topics",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"measuring-pipeline-latency",children:"Measuring Pipeline Latency"})}),"\n",(0,r.jsx)(n.p,{children:"Incremental View Maintenance (IVM) enables Feldera to quickly incorporate changes to input data into analytical queries.\nIn practice it is often important to know exactly how much processing delay a Feldera pipeline introduces to your application.\nThis article covers the key latency metrics Feldera exposes, and explain how they can help you measure\nand understand the end-to-end processing latency of your pipelines."}),"\n",(0,r.jsx)(n.h2,{id:"background-understanding-pipeline-latency",children:"Background: Understanding pipeline latency"}),"\n",(0,r.jsx)(n.p,{children:"A Feldera pipeline processes data in several stages:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input connectors"})," read data from the data source (e.g., a database table or a Kafka stream) and parse it\ninto a stream of data change events (inserts, deletes, and updates to SQL tables).\nThe connector buffers incoming data in its input queue until the IVM engine is ready to\nprocess it. If the pipeline keeps up with data arrival, input queues stay nearly empty. When data arrives\nfaster than the engine can process it, the queue fills up, leading to higher latency."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IVM engine"})," repeatedly dequeues batches of changes from\ninput queues and computes updates to all affected output views."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output queues"})," buffer outputs produced by the engine until output connectors process them. If an output\nconnector keeps up with changes, its queue is nearly empty. Otherwise, changes accumulate in the queue,\nleading to higher end-to-end latencies."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/connectors#configuring-the-output-buffer",children:"Output buffers"})})," can be optionally configured for output\nconnectors to batch multiple updates before sending them to the connector. They increase the end-to-end\nlatency by delaying outputs up to a user-configurable bound."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output connectors"})," serialize output updates and send them to target data sinks."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Understanding pipeline latency",src:t(22398).A+"",width:"2314",height:"820"})}),"\n",(0,r.jsx)(n.h2,{id:"latency-metrics",children:"Latency metrics"}),"\n",(0,r.jsxs)(n.p,{children:["A pipeline exposes key latency metrics through its ",(0,r.jsx)(n.a,{href:"https://docs.feldera.com/api/retrieve-circuit-metrics-of-a-running-or-paused-pipeline/",children:(0,r.jsx)(n.code,{children:"/metrics"})}),"\nendpoint.  See complete list of metrics ",(0,r.jsx)(n.a,{href:"/operations/metrics",children:"here"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"completion-latency-input_connector_completion_latency_seconds",children:["Completion latency (",(0,r.jsx)(n.code,{children:"input_connector_completion_latency_seconds"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scope"}),": Per input connector"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": End-to-end latency, from ingestion of a batch by the input connector until all resulting outputs have been sent to all sinks."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reported as"}),": Histogram over the last 600 seconds or 10,000 batches (whichever is smaller)."]}),"\n",(0,r.jsx)(n.p,{children:"Note that the granularity of a batch is determined by the input connector, e.g., a Kafka connector\ncan read and enqueue multiple messages at a time. The Delta Lake connector"}),"\n",(0,r.jsxs)(n.h3,{id:"processing-latency-input_connector_processing_latency_seconds",children:["Processing latency (",(0,r.jsx)(n.code,{children:"input_connector_processing_latency_seconds"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scope"}),": Per input connector"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Latency from ingestion of a batch until the IVM engine has computed all updates (before they are delivered to sinks)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reported as"}),": Histogram over the last 600 seconds or 10,000 batches (whichever is smaller)."]}),"\n",(0,r.jsxs)(n.h3,{id:"step-latency-dbsp_step_latency_seconds",children:["Step latency (",(0,r.jsx)(n.code,{children:"dbsp_step_latency_seconds"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scope"}),": Pipeline-wide"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Time the IVM engine takes to complete a single processing step."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reported as"}),": Histogram over the last 60 seconds or 1,000 steps (whichever is smaller)."]}),"\n",(0,r.jsx)(n.h2,{id:"measuring-end-to-end-latency-with-input-frontiers",children:"Measuring end-to-end latency with input frontiers"}),"\n",(0,r.jsxs)(n.p,{children:["The metrics above capture ",(0,r.jsx)(n.em,{children:"internal"})," pipeline delays only.\nThey exclude the time between when data is written to the source and when it is picked up by Feldera,\ne.g., the time between a new message was written Kafka until it was dequeued by the pipeline.\nAccounting for this latency is essential to measuring the pipeline's contribution to the\nend-to-end processing latency of your application."]}),"\n",(0,r.jsxs)(n.p,{children:["While this latency is not measured by the pipeline itself, the pipeline exposes\nmetadata that helps the user to measure this latency. This per-connector metadata is only\navailable for certain connector types,\nvia the ",(0,r.jsx)(n.a,{href:"https://docs.feldera.com/api/retrieve-statistics-e-g-performance-counters-of-a-running-or-paused-pipeline",children:(0,r.jsx)(n.code,{children:"/stats"})}),"\nendpoint in the ",(0,r.jsx)(n.code,{children:".inputs[<connector_index>].completed_frontier"})," field.\nIt describes the latest offset in the input data stream fully processed by the pipeline.\nIt includes the following fields:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Field"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Format"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"metadata"})}),(0,r.jsx)(n.td,{children:"Connector-specific metadata that describes the latest offset in the input stream fully processed by the pipeline (e.g., Kafka partition/offset pairs)."}),(0,r.jsx)(n.td,{children:"connector-specific (see below)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ingested_at"})}),(0,r.jsx)(n.td,{children:"Timestamp when data was ingested from the wire."}),(0,r.jsx)(n.td,{children:"RFC 3339 timestamp"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"processed_at"})}),(0,r.jsx)(n.td,{children:"Timestamp when the IVM engine finished processing it."}),(0,r.jsx)(n.td,{children:"RFC 3339 timestamp"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"completed_at"})}),(0,r.jsx)(n.td,{children:"Timestamp when all resulting outputs were delivered to all sinks."}),(0,r.jsx)(n.td,{children:"RFC 3339 timestamp"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"completed_frontier"})," property is currently supported for the following connectors:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/connectors/sources/kafka",children:"Kafka input connector"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/connectors/sources/delta",children:"Delta Lake connector"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These connectors support the following metadata formats:"}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsxs)(l.A,{value:"delta",label:"Delta Lake",children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "version": N\n}\n'})}),(0,r.jsxs)(n.p,{children:["where ",(0,r.jsx)(n.code,{children:"version"})," is the latest Delta table version processed by the pipeline."]})]}),(0,r.jsxs)(l.A,{value:"kafka",label:"Kafka",children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "offsets": [\n    {\n        "start": START_OFFSET1,\n        "end": END_OFFSET1\n    },\n    {\n        "start": START_OFFSET2,\n        "end": END_OFFSET2,\n    },\n    ...\n    ]\n}\n'})}),(0,r.jsxs)(n.p,{children:["where the ",(0,r.jsx)(n.code,{children:"offsets"})," array stores the offset range in the last processed batch per Kafka partition."]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Consider a ",(0,r.jsx)(n.a,{href:"/connectors/sources/delta",children:"Delta Lake connector"})," that reports the following completed frontier:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "metadata": {\n        "version":10\n    },\n    "ingested_at":"2025-09-20T22:32:32.916501+00:00",\n    "processed_at":"2025-09-20T22:33:34.112410+00:00",\n    "completed_at":"2025-09-20T22:33:34.112414+00:00"\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"When this data is reported,\nthis means that the pipeline has fully processed all Delta table versions up to version 10.\nTo determine how far behind the current state of the Delta table the pipeline lags,\nwe have to go outside of Feldera to query the timestamp of the\nthe first Delta table version after version 10 (if any). For example, using Spark SQL:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"WITH history AS (\n  DESCRIBE HISTORY my_table\n)\nSELECT\n  CASE WHEN version = 11 THEN timestamp END AS v11_timestamp,\n  (unix_timestamp(now()) - unix_timestamp(v11_timestamp)) AS seconds_between\nFROM history;\n"})}),"\n",(0,r.jsx)(n.p,{children:"which produces output similar to this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"+-----------------------+----------------+\n| v11_timestamp         | seconds_between|\n+-----------------------+----------------+\n| 2025-09-20 22:31:15   |             5  |\n+-----------------------+----------------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"This means that the outputs written by the pipeline to its data sinks reflect the contents of the Delta table\nas of 5 seconds ago."}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/connectors/completion-tokens",children:"Completion tokens"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},11470:(e,n,t)=>{t.d(n,{A:()=>_});var s=t(96540),r=t(34164),i=t(23104),a=t(56347),l=t(205),o=t(57485),c=t(31682),d=t(70679);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((({props:{value:e,label:n,attributes:t,default:s}})=>({value:e,label:n,attributes:t,default:s})))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function m({queryString:e=!1,groupId:n}){const t=(0,a.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,o.aZ)(r),(0,s.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=h(e),[a,o]=(0,s.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i}))),[c,u]=m({queryString:t,groupId:r}),[f,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,d.Dv)(n);return[t,(0,s.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:r}),x=(()=>{const e=c??f;return p({value:e,tabValues:i})?e:null})();(0,l.A)((()=>{x&&o(x)}),[x]);return{selectedValue:a,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),g(e)}),[u,g,i]),tabValues:i}}var g=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=t(74848);function j({className:e,block:n,selectedValue:t,selectValue:s,tabValues:a}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,i.a_)(),c=e=>{const n=e.currentTarget,r=l.indexOf(n),i=a[r].value;i!==t&&(o(n),s(i))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:a.map((({value:e,label:n,attributes:s})=>(0,y.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...s,className:(0,r.A)("tabs__item",x.tabItem,s?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function b({lazy:e,children:n,selectedValue:t}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find((e=>e.props.value===t));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function v(e){const n=f(e);return(0,y.jsxs)("div",{className:(0,r.A)("tabs-container",x.tabList),children:[(0,y.jsx)(j,{...n,...e}),(0,y.jsx)(b,{...n,...e})]})}function _(e){const n=(0,g.A)();return(0,y.jsx)(v,{...e,children:u(e.children)},String(n))}},19365:(e,n,t)=>{t.d(n,{A:()=>a});t(96540);var s=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function a({children:e,hidden:n,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,t),hidden:n,children:e})}},22398:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/latency-82a0ac32c493809c43c094378aa45208.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);