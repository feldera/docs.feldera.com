"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[1364],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var l=t(96540);const s={},i=l.createContext(s);function r(e){const n=l.useContext(i);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),l.createElement(i.Provider,{value:n},e.children)}},90008:(e,n,t)=>{t.d(n,{A:()=>l});const l=t.p+"assets/images/spreadsheet-architecture-parts-59cc4b6f1153fd4b409cb80b9a25a43a.svg"},98295:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"use_cases/real_time_apps/part1","title":"Incremental, live web applications","description":"In this three-part series, we\u2019ll build a real-time, scalable, and incremental web application with Feldera by creating a collaborative online spreadsheet:","source":"@site/docs/use_cases/real_time_apps/part1.mdx","sourceDirName":"use_cases/real_time_apps","slug":"/use_cases/real_time_apps/part1","permalink":"/use_cases/real_time_apps/part1","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Real-time Fraud Detection","permalink":"/use_cases/fraud_detection/"},"next":{"title":"Exposing Feldera Pipelines to many clients","permalink":"/use_cases/real_time_apps/part2"}}');var s=t(74848),i=t(28453);const r={},d="Incremental, live web applications",c={},a=[{value:"Spreadsheets",id:"spreadsheets",level:2},{value:"A Spreadsheet Pipeline",id:"a-spreadsheet-pipeline",level:2},{value:"Storing the Cells in a Table",id:"storing-the-cells-in-a-table",level:3},{value:"Compute latest cells and find references of cells",id:"compute-latest-cells-and-find-references-of-cells",level:3},{value:"Find the values of referenced cells",id:"find-the-values-of-referenced-cells",level:3},{value:"Evaluating Formulas",id:"evaluating-formulas",level:3},{value:"It works, almost",id:"it-works-almost",level:3},{value:"Resolve references recursively",id:"resolve-references-recursively",level:3},{value:"Incremental recursive spreadsheets",id:"incremental-recursive-spreadsheets",level:3},{value:"Conclusion",id:"conclusion",level:3}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{LiteYouTubeEmbed:l}=n;return l||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteYouTubeEmbed",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"incremental-live-web-applications",children:"Incremental, live web applications"})}),"\n",(0,s.jsx)(n.p,{children:"In this three-part series, we\u2019ll build a real-time, scalable, and incremental web application with Feldera by creating a collaborative online spreadsheet:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Part 1 (this article):"})," Implement core spreadsheet logic using Feldera SQL."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Part 2:"})," ",(0,s.jsx)(n.a,{href:"/use_cases/real_time_apps/part2",children:"Expose pipeline data to clients via a server"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Part 3:"})," ",(0,s.jsx)(n.a,{href:"/use_cases/real_time_apps/part3",children:"Add a browser-based UI"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"spreadsheet-architecture-parts",src:t(90008).A+"",width:"665",height:"370"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Try the ",(0,s.jsx)(n.a,{href:"https://xls.feldera.io",children:"live demo"})," and see the ",(0,s.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet",children:"GitHub repo"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Watch the Webinar accompanying this series on Youtube:"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(l,{id:"ROa4duVqoOs"}),"\n",(0,s.jsx)(n.h2,{id:"spreadsheets",children:"Spreadsheets"}),"\n",(0,s.jsx)(n.p,{children:"Spreadsheets are everywhere (Excel, Google Sheets), and this use-case highlights how incremental computation helps with large spreadsheets (billions of cells) and many concurrent users:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cells can reference any other cell, making it hard to simply partition computation."}),"\n",(0,s.jsx)(n.li,{children:"Updates to one cell should only re-compute affected cells to avoid unncessary compute and network traffic."}),"\n",(0,s.jsx)(n.li,{children:"Formulas can perform arbitrary computations and chain references recursively."}),"\n",(0,s.jsx)(n.li,{children:"Clients view only small portions of the spreadsheet, so we only want to send relevant changes to them."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Feldera makes it easy to satisfy these requirements. Let\u2019s start by building the \u201cdatabase\u201d (our Feldera pipeline)."}),"\n",(0,s.jsx)(n.h2,{id:"a-spreadsheet-pipeline",children:"A Spreadsheet Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"To implement the spreadsheet in Feldera we'll:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Store cells in a table."}),"\n",(0,s.jsx)(n.li,{children:"Determine which cells each cell references."}),"\n",(0,s.jsx)(n.li,{children:"Retrieve values for those references."}),"\n",(0,s.jsx)(n.li,{children:"Evaluate formulas using the referenced values."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Follow along in the Feldera Web-console or run Feldera locally or in our ",(0,s.jsx)(n.a,{href:"/get-started",children:"online sandbox"}),". Create a new pipeline named ",(0,s.jsx)(n.code,{children:"xls"})," and paste each SQL and Rust snippet into the Web-console."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The code used in this article is available in our ",(0,s.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet",children:"GitHub repository"})," in the ",(0,s.jsx)(n.code,{children:"feldera"})," folder. While we\u2019ll walk through each step here, you can also download the repository and follow the instructions in the README to deploy the pipeline."]})}),"\n",(0,s.jsx)(n.h3,{id:"storing-the-cells-in-a-table",children:"Storing the Cells in a Table"}),"\n",(0,s.jsx)(n.p,{children:"We need a table to store cell content. Below is the SQL to create it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'create table spreadsheet_data (\n    id bigint not null,\n    ip varchar(45) not null,\n    ts timestamp not null,\n    raw_value varchar(64) not null,\n    background integer not null\n) with (\n    \'materialized\' = \'true\',\n    \'connectors\' = \'[{\n        "transport": {\n        "name": "datagen",\n        "config": {\n            "workers": 1,\n            "plan": [{\n                "limit": 4,\n                "fields": {\n                    "id": { "values": [0, 1, 2, 3] },\n                    "raw_value": { "values": ["41", "1", "=B0", "=A0+C0"] }\n                }\n            }]\n        }\n    }\n}]\'\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"This table has:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"}),": cell's id"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ip"}),": the client\u2019s IP"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ts"}),": insertion timestamp"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"raw_value"})," cell content as written by the user"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"background"}),": cell background color"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the WITH clause:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We declare the table as materialized, allowing ad-hoc queries."}),"\n",(0,s.jsx)(n.li,{children:"We use a datagen configuration to insert four cells with IDs 0, 1, 2, 3 and values 41, 1, =B0, and =A0+C0."}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"We\u2019ll use two \u201ccoordinate systems\u201d for cells: numeric IDs in the table and spreadsheet coordinates (letters for columns, numbers for rows). For example, B100 is the second column in row 100."}),(0,s.jsxs)(n.p,{children:["We currently limit columns to ",(0,s.jsx)(n.code,{children:"A"})," through ",(0,s.jsx)(n.code,{children:"Z"}),", covering numeric IDs from ",(0,s.jsx)(n.code,{children:"0"})," to ",(0,s.jsx)(n.code,{children:"1_040_000_000"}),". Thus, ",(0,s.jsx)(n.code,{children:"A0"})," maps to cell id ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"Z0 \u2192 25"}),", ",(0,s.jsx)(n.code,{children:"A1 \u2192 26"}),", and ",(0,s.jsx)(n.code,{children:"Z39999999"})," \u2192 ",(0,s.jsx)(n.code,{children:"1_040_000_000-1"}),"."]})]}),"\n",(0,s.jsxs)(n.p,{children:["The four cells we added \u2014 IDs ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"1"}),", ",(0,s.jsx)(n.code,{children:"2"}),", ",(0,s.jsx)(n.code,{children:"3"})," \u2014 map to ",(0,s.jsx)(n.code,{children:"A0"}),", ",(0,s.jsx)(n.code,{children:"B0"}),", ",(0,s.jsx)(n.code,{children:"C0"}),", and ",(0,s.jsx)(n.code,{children:"D0"}),". When the pipeline is running, they should compute to ",(0,s.jsx)(n.code,{children:"41"}),", ",(0,s.jsx)(n.code,{children:"1"}),", ",(0,s.jsx)(n.code,{children:"1"}),", and ",(0,s.jsx)(n.code,{children:"42"})," respectively."]}),"\n",(0,s.jsx)(n.h3,{id:"compute-latest-cells-and-find-references-of-cells",children:"Compute latest cells and find references of cells"}),"\n",(0,s.jsxs)(n.p,{children:["In many database scenarios, you might expect a PRIMARY KEY on id. However, we want to keep a complete history of spreadsheet edits, so we allow multiple entries per id. This means we need a way to identify the latest value for any given cell, which we handle by looking at the timestamp (",(0,s.jsx)(n.code,{children:"ts"}),") we can do that by writing a new view for this subset of ",(0,s.jsx)(n.code,{children:"latest_cells"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We also need to discover if the cell references other cells (e.g., with a formula like ",(0,s.jsx)(n.code,{children:"=A0+B0"}),"). Extracting references from ",(0,s.jsx)(n.code,{children:"raw_value"})," is tricky in SQL because it requires parsing spreadsheet formulas. To handle this, we define a Rust UDF called ",(0,s.jsx)(n.code,{children:"mentions"}),", which returns an array of referenced cell IDs. Below the SQL view that uses the ",(0,s.jsx)(n.code,{children:"mentions"})," function (which we\u2019ll implement in Rust) and selects only the most recent cellll for each id in ",(0,s.jsx)(n.code,{children:"spreadsheet_data"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create function mentions(cell varchar(64)) returns bigint array;\n\ncreate materialized view latest_cells as with\n    max_ts_per_cell as (\n        select\n            id,\n            max(ts) as max_ts\n        from\n            spreadsheet_data\n        group by\n            id\n    )\nselect\n    s.id,\n    s.raw_value,\n    s.background,\n    ARRAY_APPEND(mentions(s.raw_value), null) as mentioned_cell_ids\nfrom\n    spreadsheet_data s\njoin max_ts_per_cell mt on s.id = mt.id and s.ts = mt.max_ts;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This SQL won\u2019t compile yet because we haven\u2019t implemented mentions. Here\u2019s the Rust UDF code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use std::collections::{BTreeMap, VecDeque};\n\nuse xlformula_engine::calculate;\nuse xlformula_engine::parse_formula;\nuse xlformula_engine::NoCustomFunction;\nuse xlformula_engine::types::{Formula, Value, Error, Boolean};\nuse chrono::DateTime;\n\n// Returns a list of references for a spreadsheet formula\n// `42 -> []` `=A0 -> [0]`, `=A0+B0 -> [0, 1]`\npub fn mentions(raw_content: Option<String>) -> Result<Option<Vec<Option<i64>>>, Box<dyn std::error::Error>> {\n    let cell_content = raw_content.unwrap_or_else(|| String::new());\n    let formula = parse_formula::parse_string_to_formula(&cell_content, None::<NoCustomFunction>);\n\n    let mut formulas = VecDeque::from(vec![formula]);\n    let mut references = vec![];\n\n    while !formulas.is_empty() {\n        let formula = formulas.pop_front().unwrap();\n        match formula {\n            Formula::Reference(reference) => {\n                references.push(reference);\n            },\n            Formula::Iterator(iterator) => {\n                formulas.extend(iterator);\n            },\n            Formula::Operation(expression) => {\n                formulas.extend(expression.values);\n            },\n            _ => {}\n        }\n    }\n    let mut cell_ids: Vec<Option<i64>> = references.iter().map(|r| cell_references_to_ids(r)).collect();\n    cell_ids.sort_unstable();\n\n    Ok(Some(cell_ids))\n}\n\n// Transforms spreadsheet coordinates to cell id's\n// `A0 -> 0, B0 -> 1, C0 -> 2 ...`\nfn cell_references_to_ids(crf: &str) -> Option<i64> {\n    let mut col = 0;\n    let mut row = 0;\n    for c in crf.chars() {\n        if c.is_ascii_alphabetic() {\n            col = col * 26 + (c.to_ascii_uppercase() as i64 - 'A' as i64);\n        } else if c.is_ascii_digit() {\n            row = row * 10 + (c as i64 - '0' as i64);\n        } else {\n            return None;\n        }\n    }\n    Some(col + row * 26)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We also add the following udf.toml to pull in crates from the Rust ecosystem:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'xlformula_engine =  { git = "https://github.com/gz/XLFormula-Engine.git", rev = "3b39201" }\nlog = "0.4"\nchrono = "0.4"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.a,{href:"https://docs.rs/xlformula_engine",children:"xlformula_engine"})," crate to parse formulas, like ``=A0+B0`, into a syntax tree:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ascii",children:"         Operation\n       /          \\\nReference(A0)   Reference(B0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Our ",(0,s.jsx)(n.code,{children:"mentions"})," function walks this tree and collects every Reference into a references array. A helper function, ",(0,s.jsx)(n.code,{children:"cell_references_to_ids"}),", converts spreadsheet coordinates (e.g., ",(0,s.jsx)(n.code,{children:"A0"}),", ",(0,s.jsx)(n.code,{children:"B0"}),") to numeric cell IDs."]}),"\n",(0,s.jsxs)(n.p,{children:["Once the UDF is in place, we can run the pipeline, activate the changestream for ",(0,s.jsx)(n.code,{children:"latest_cells"}),", and observe output like this (some columns omitted):"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentions"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"ts"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1970-01-01 00:00:01"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1970-01-01 00:00:02"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null, 1 ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1970-01-01 00:00:03"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null, 0, 2 ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1970-01-01 00:00:04"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Notice null appears in every mentions array. This ensures the array isn\u2019t empty for cells that don\u2019t reference anything, preventing them from being excluded in future joins."}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"To see the latest_cells view in action, you can insert a newer value for cell 0:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"insert into spreadsheet_data values (0, 0, '2025-01-01T00:00:00', '0', 0)\n"})}),(0,s.jsxs)(n.p,{children:["You should see two changes being emitted in the ",(0,s.jsx)(n.code,{children:"latest_cell"}),"\nview, the removal of the cell with value ",(0,s.jsx)(n.code,{children:"42"})," and a new cell with value ",(0,s.jsx)(n.code,{children:"0"}),"."]}),(0,s.jsx)(n.p,{children:"This setup also allows us to easily undo any changes made (by just deleting the most recent entry for a given cell)."})]}),"\n",(0,s.jsx)(n.h3,{id:"find-the-values-of-referenced-cells",children:"Find the values of referenced cells"}),"\n",(0,s.jsx)(n.p,{children:"Now that we know which cells are referenced by any given cell, the next step is to retrieve the values of those referenced cells. Having both the referenced IDs and their values makes it straightforward to compute formulas later."}),"\n",(0,s.jsx)(n.p,{children:"We accomplish this by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Unnesting the ",(0,s.jsx)(n.code,{children:"mentions"})," array from ",(0,s.jsx)(n.code,{children:"latest_cells"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Cross-joining the unnested ",(0,s.jsx)(n.code,{children:"mentions"})," with ",(0,s.jsx)(n.code,{children:"latest_cells"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Rejoining with ",(0,s.jsx)(n.code,{children:"spreadsheet_data"})," to look up each referenced cell\u2019s ",(0,s.jsx)(n.code,{children:"raw_value"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create view latest_cells_with_mentions as\nselect\n    s.id,\n    s.raw_value,\n    s.background,\n    m.mentioned_id\nfrom\n    latest_cells s, unnest(s.mentioned_cell_ids) as m(mentioned_id);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the final line, we cross-join ",(0,s.jsx)(n.code,{children:"latest_cells"})," with a new \u201ctable\u201d created by ",(0,s.jsx)(n.code,{children:"unnest"})," on the ",(0,s.jsx)(n.code,{children:"mentions"})," array. Here\u2019s how the view looks given our inserted data:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentioned_id"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Next, we join this intermediate result with ",(0,s.jsx)(n.code,{children:"spreadsheet_data"})," to find the ",(0,s.jsx)(n.code,{children:"raw_value"})," for each ",(0,s.jsx)(n.code,{children:"mentioned_id"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create materialized view mentions_with_values as\nselect\n    m.id,\n    m.raw_value,\n    m.background,\n    m.mentioned_id,\n    sv.raw_value as mentioned_value\nfrom\n    latest_cells_with_mentions m\n        left join\n    spreadsheet_data sv on m.mentioned_id = sv.id;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This produces the same view as above but with an added ",(0,s.jsx)(n.code,{children:"mentioned_value"})," column:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentioned_id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentioned_value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=41"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, we flatten this data by grouping ",(0,s.jsx)(n.code,{children:"mentioned_id"})," and ",(0,s.jsx)(n.code,{children:"mentioned_value"})," into arrays, producing one row per cell:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create materialized view mentions_aggregated as\nselect\n    id,\n    raw_value,\n    background,\n    ARRAY_AGG(mentioned_id) as mentions_ids,\n    ARRAY_AGG(mentioned_value) as mentions_values\nfrom\n    mentions_with_values\ngroup by\n    id,\n    raw_value,\n    background;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This yields the following result:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentions_ids"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentions_values"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null ]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ null ]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ 1 ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ 1 ]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ 0, 1]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ 0, =B0 ]"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"evaluating-formulas",children:"Evaluating Formulas"}),"\n",(0,s.jsxs)(n.p,{children:["At this point, we have two arrays \u2014 ",(0,s.jsx)(n.code,{children:"mentions_ids"})," and ",(0,s.jsx)(n.code,{children:"mentions_values"})," \u2014 which let us map references in a cell\u2019s formula to their corresponding values. To evaluate these formulas, we add a Rust UDF (",(0,s.jsx)(n.code,{children:"cell_value"}),"), again leveraging the ",(0,s.jsx)(n.code,{children:"xlformula_engine"})," crate."]}),"\n",(0,s.jsxs)(n.p,{children:["First, we introduce a view that calls this UDF and produces a ",(0,s.jsx)(n.code,{children:"computed_value"})," for each cell:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create function cell_value(cell varchar(64), mentions_ids bigint array, mentions_values varchar(64) array) returns varchar(64);\n\ncreate materialized view spreadsheet_view as\nselect\n    id,\n    background,\n    raw_value,\n    cell_value(raw_value, mentions_ids, mentions_values) AS computed_value\nfrom\n    mentions_aggregated;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Below is the Rust code for our ",(0,s.jsx)(n.code,{children:"cell_value"})," UDF (plus helper functions):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Evaluates a formula \"=A0+B0\" and returns it's result\npub fn cell_value(raw_content: Option<String>, mentions_ids: Option<Vec<Option<i64>>>, mentions_values: Option<Vec<Option<String>>>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    let cell_content = raw_content.unwrap_or_else(|| String::new());\n    let formula = parse_formula::parse_string_to_formula(&*cell_content, None::<NoCustomFunction>);\n\n    let mentions_ids = mentions_ids.unwrap_or_else(|| vec![]);\n    let mentions_values = mentions_values.unwrap_or_else(|| vec![]);\n    assert_eq!(mentions_ids.len(), mentions_values.len());\n    let mut context = BTreeMap::new();\n    for (id, value) in mentions_ids.into_iter().zip(mentions_values.into_iter()) {\n        if let (Some(id), Some(value)) = (id, value) {\n            context.insert(id_to_cell_reference(id), parse_as_value(value));\n        }\n    }\n    let data_function = |s: String| context.get(&s).cloned().unwrap_or_else(|| Value::Error(Error::Value));\n\n    let result = calculate::calculate_formula(formula, Some(&data_function));\n    let result_str = calculate::result_to_string(result);\n    Ok(Some(result_str))\n}\n\n// Parses a string to a xlformula Value type\n// (Number, Date or String)\nfn parse_as_value(input: String) -> Value {\n    if let Ok(number) = input.parse::<f32>() {\n        return Value::Number(number);\n    }\n    if let Ok(boolean) = input.parse::<bool>() {\n        return Value::Boolean(if boolean { Boolean::True } else { Boolean::False });\n    }\n    if let Ok(date) = DateTime::parse_from_rfc3339(input.as_str()) {\n        return Value::Date(date);\n    }\n    Value::Text(input)\n}\n\n// Transforms cell id's to spreadsheet coordinates\n// e.g., 0 -> 'A0'\nfn id_to_cell_reference(id: i64) -> String {\n    let mut col = id % 26;\n    let row = id / 26;\n    let mut result = String::new();\n    while col >= 0 {\n        result.push((col as u8 + 'A' as u8) as char);\n        col = col / 26 - 1;\n    }\n    result.push_str(&row.to_string());\n    result\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The UDF builds a ",(0,s.jsx)(n.code,{children:"data_function"})," closure. When ",(0,s.jsx)(n.code,{children:"calculate::calculate_formula"})," encounters a reference, the closure returns the referenced cell\u2019s value from the arrays we passed in."]}),"\n",(0,s.jsx)(n.h3,{id:"it-works-almost",children:"It works, almost"}),"\n",(0,s.jsxs)(n.p,{children:["If we take this code and run it, we'll find that it almost works. Looking at the ",(0,s.jsx)(n.code,{children:"spreadsheet_view"})," output we see:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"computed_value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"#VALUE!"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"The system couldn't evalute the last formula."}),"\n",(0,s.jsx)(n.h3,{id:"resolve-references-recursively",children:"Resolve references recursively"}),"\n",(0,s.jsxs)(n.p,{children:["Looking at the ",(0,s.jsx)(n.code,{children:"mentions_aggregated"})," view, we see why cell 3 fails to compute:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentions_ids"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"mentions_values"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ 0, 1 ]"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"[ 0, =B0 ]"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.code,{children:"compute_value"})," UDF tries to evaluate ",(0,s.jsx)(n.code,{children:"C0"})," for the addition, it encounters ",(0,s.jsx)(n.code,{children:"C0"})," as another reference to ",(0,s.jsx)(n.code,{children:"B0"}),". Since ",(0,s.jsx)(n.code,{children:"B0"})," isn\u2019t in the original mentions array for cell 3, the UDF has no value for it."]}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, Feldera SQL can do recursive queries to solve this. Instead of looking up raw values in ",(0,s.jsx)(n.code,{children:"spreadsheet_data"}),", we can read computed values from ",(0,s.jsx)(n.code,{children:"spreadsheet_view"}),". Although, we initially couldn\u2019t do this (because ",(0,s.jsx)(n.code,{children:"spreadsheet_view"})," didn\u2019t yet exist, and ",(0,s.jsx)(n.code,{children:"mentions_with_values"})," helps build it), recursion lets us reference a view before it\u2019s fully defined."]}),"\n",(0,s.jsxs)(n.p,{children:["Here\u2019s how we update ",(0,s.jsx)(n.code,{children:"mentions_with_values"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create materialized view mentions_with_values as\nselect\n    m.id,\n    m.raw_value,\n    m.background,\n    m.mentioned_id,\n    sv.compute_value as mentioned_value\nfrom\n    latest_cells_with_mentions m\n        left join\n    spreadsheet_view sv on m.mentioned_id = sv.id;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note the three changes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"We now get the final (evaluted) values for every cell:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"sv.compute_value as mentioned_value\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["By reading them from ",(0,s.jsx)(n.code,{children:"spreadsheet_view"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"left join\n    spreadsheet_view sv on m.mentioned_id = sv.id;\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you try to compile at this point, you\u2019ll see:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Error in SQL statement:\nObject 'spreadsheet_view' not found\n   66|    spreadsheet_view sv on m.mentioned_id = sv.id;\n          ^^^^^^^^^^^^^^^^\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That\u2019s because ",(0,s.jsx)(n.code,{children:"spreadsheet_view"})," doesn\u2019t exist when we define ",(0,s.jsx)(n.code,{children:"mentions_with_values"}),". To fix this, add a ",(0,s.jsx)(n.strong,{children:"forward declaration"})," at the start of your program:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"declare recursive view spreadsheet_view (\n    id bigint not null,\n    background integer not null,\n    raw_value varchar(64) not null,\n    computed_value varchar(64)\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The compiler will also complain that the two views ",(0,s.jsx)(n.code,{children:"mentions_with_values"})," and and ",(0,s.jsx)(n.code,{children:"mentions_aggregated"})," need to be declared as ",(0,s.jsx)(n.code,{children:"local"})," instead of materialized. This is because they can't be materialized when used as part of a recursive chain.\nWe can make those changes by replacing the ",(0,s.jsx)(n.code,{children:"materialized"})," keyword with ",(0,s.jsx)(n.code,{children:"local"})," in those two view declarations."]}),"\n",(0,s.jsxs)(n.p,{children:["After recompiling and running, we'll see the following in the ",(0,s.jsx)(n.code,{children:"spreadsheet_view"})," changestream:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"computed_value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=B0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"42"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Cell 3 is now computed correctly thanks to the recursion!"}),"\n",(0,s.jsx)(n.h3,{id:"incremental-recursive-spreadsheets",children:"Incremental recursive spreadsheets"}),"\n",(0,s.jsx)(n.p,{children:"Finally, let's confirm our incremental update promise: changing a single cell should trigger only minimal updates downstream."}),"\n",(0,s.jsx)(n.p,{children:"We can test this by updating cell 0 again:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"insert into spreadsheet_data values (0, 0, '2025-01-01T00:00:00', '0', 0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Checking the ",(0,s.jsx)(n.code,{children:"spreadsheet_view"})," changestream, we see just two cells affected:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"change"}),(0,s.jsx)(n.th,{children:"id"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"raw_value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"compute_value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"delete"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"41"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"delete"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"42"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"insert"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"insert"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"=A0+C0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"1"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["We\u2019ve now built the core of our spreadsheet application. In ",(0,s.jsx)(n.a,{href:"/use_cases/real_time_apps/part2",children:"the next part"})," of this series, we\u2019ll explore how to use Feldera\u2019s API to serve this spreadsheet to clients, creating a publicly accessible API server."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["If you compare the code in this article it with the code in the ",(0,s.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/tree/main/feldera",children:"repository"})," you'll find that we omitted two additional views (to track API limits and statistics) for brevity."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);