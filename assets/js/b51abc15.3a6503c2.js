"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[4665],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},91800:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"tutorials/time-series","title":"Time Series Analysis with Feldera","description":"This guide covers concepts required to effectively process time series","source":"@site/docs/tutorials/time-series.md","sourceDirName":"tutorials","slug":"/tutorials/time-series","permalink":"/tutorials/time-series","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"A browser based UI","permalink":"/use_cases/real_time_apps/part3"},"next":{"title":"Use Case: Fine-Grained Authorization","permalink":"/use_cases/fine_grained_authorization/intro"}}');var s=t(74848),a=t(28453);const r={},o="Time Series Analysis with Feldera",l={},d=[{value:"Timestamp columns and lateness",id:"timestamp-columns-and-lateness",level:2},{value:"Specifying lateness for tables and views",id:"specifying-lateness-for-tables-and-views",level:3},{value:"Guidelines for writing lateness annotations",id:"guidelines-for-writing-lateness-annotations",level:3},{value:"Lateness example",id:"lateness-example",level:3},{value:"How Feldera garbage collects old state",id:"how-feldera-garbage-collects-old-state",level:2},{value:"The data retention algorithm",id:"the-data-retention-algorithm",level:3},{value:"Emitting final values of a view with <code>emit_final</code>",id:"emitting-final-values-of-a-view-with-emit_final",level:2},{value:"Delaying inputs with <code>WATERMARK</code>",id:"delaying-inputs-with-watermark",level:2},{value:"Append-only tables",id:"append-only-tables",level:2},{value:"SQL for time series analytics",id:"sql-for-time-series-analytics",level:2},{value:"Aggregating Time Series Data Over Fixed-Size Time Intervals",id:"aggregating-time-series-data-over-fixed-size-time-intervals",level:3},{value:"Garbage collection",id:"garbage-collection",level:4},{value:"Tumbling and hopping windows",id:"tumbling-and-hopping-windows",level:3},{value:"Rolling aggregates",id:"rolling-aggregates",level:3},{value:"Garbage collection",id:"garbage-collection-1",level:4},{value:"Join over timestamp columns",id:"join-over-timestamp-columns",level:3},{value:"Garbage collection",id:"garbage-collection-2",level:4},{value:"As-of joins",id:"as-of-joins",level:3},{value:"Garbage collection",id:"garbage-collection-3",level:4},{value:"<code>LAG</code> and <code>LEAD</code>",id:"lag-and-lead",level:3},{value:"Garbage collection",id:"garbage-collection-4",level:4},{value:"<code>NOW()</code> and temporal filters",id:"now-and-temporal-filters",level:2},{value:"Garbage collection",id:"garbage-collection-5",level:4},{value:"Further reading",id:"further-reading",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"time-series-analysis-with-feldera",children:"Time Series Analysis with Feldera"})}),"\n",(0,s.jsxs)(n.p,{children:["This guide covers concepts required to effectively process ",(0,s.jsx)(n.strong,{children:"time series"}),"\ndata with Feldera.  A time series is a sequence of events, such as IoT sensor\nreadings or financial transactions, where each event is associated with one or\nmore timestamps.  Time series data is inherently dynamic, changing continuously\nas new events arrive in real-time.  Feldera is designed to\ncompute over changing data, making it well-suited for time series\nanalytics."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:['Most examples in this guide are available as a pre-packaged demo "Time Series Analysis with Feldera"\nthat ships with the\n',(0,s.jsx)(n.a,{href:"https://docs.feldera.com/get-started/docker",children:"Feldera Docker container"})," and the\n",(0,s.jsx)(n.a,{href:"https://try.feldera.com",children:"online sandbox"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["At a high-level, Feldera allows users to efficiently compute on time series data by\nproviding ",(0,s.jsx)(n.a,{href:"#timestamp-columns-and-lateness",children:(0,s.jsx)(n.code,{children:"LATENESS"})}),' annotations on tables and views. These\nannotations describe the datasource and tell Feldera the maximum out-of-orderness in the data.\nFor example, it allows users to convey to Feldera a hint of the form "I know that data from my\nIoT sensor will never get delayed by more than a day". Feldera takes these hints and automatically\ndecides when it is safe to drop state that won\'t affect the output of any of the views. ',(0,s.jsx)(n.strong,{children:"This allows\nFeldera to evaluate various classes of queries on infinite streams of data (like telemetry data)\nwith finite memory, making it extremely resource efficient."})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Feldera does not automatically garbage collect ",(0,s.jsx)(n.a,{href:"/sql/materialized",children:"materialized tables and views"}),".\nIf such a table stores an unbounded time series, it will continue to consume storage without limit.\nIn addition, if the table has a primary key (PK), Feldera will maintain a PK index for this table,\nwhich will only be garbage collected if at least one of the PK columns has a ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotation."]})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Feldera implements an ",(0,s.jsx)(n.code,{children:"INSERT"})," or ",(0,s.jsx)(n.code,{children:"UPDATE"})," in a table with a primary\nkey as a pair of ",(0,s.jsx)(n.code,{children:"INSERT"})," and ",(0,s.jsx)(n.code,{children:"DELETE"})," operations: a new record is\ninserted, and the old record with the same primary key (if present) is\ndeleted.  For tables with ",(0,s.jsx)(n.code,{children:"LATENESS"})," this may cause surprising\neffects: the ",(0,s.jsx)(n.code,{children:"DELETE"})," needs to delete the previous version of the\nrecord, with the old timestamp; if this timestamp is behind the\n",(0,s.jsx)(n.code,{children:"LATENESS"}),' threshold, the entire INSERT or UPDATE is considered late\nand is thus ignored.  This effectivelly means that "old" records in\nsuch a table can never be updated or deleted.']})}),"\n",(0,s.jsxs)(n.p,{children:["Users can further take advantage of ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotations to control\n",(0,s.jsx)(n.strong,{children:"when"})," the output of a query is produced by Feldera using\n",(0,s.jsx)(n.a,{href:"#emitting-final-values-of-a-view-with-emit_final",children:(0,s.jsx)(n.code,{children:"emit_final"})}),"\nannotations."]}),"\n",(0,s.jsx)(n.p,{children:"In the following sections, we will explain lateness and other key concepts with\nwhich users can efficiently compute over timeseries data."}),"\n",(0,s.jsxs)(n.p,{children:["The last part of this guide lists ",(0,s.jsx)(n.a,{href:"#sql-for-time-series-analytics",children:"SQL patterns"}),"\nfrequently used in time series analysis. Feldera supports garbage collection for\nmost of these patterns, meaning that the can be evaluated efficiently using\nbounded memory."]}),"\n",(0,s.jsx)(n.h2,{id:"timestamp-columns-and-lateness",children:"Timestamp columns and lateness"}),"\n",(0,s.jsx)(n.p,{children:"A timestamp column is a column in a SQL table or view that indicates a specific\npoint in time associated with each row."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"There can be any number of timestamp columns in a table. For instance, a\ntable that describes taxi rides can store the time when the ride order was\nreceived, pickup time, dropoff time, and the time when the payment was\nprocessed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Timestamp columns can have any temporal (",(0,s.jsx)(n.code,{children:"TIMESTAMP"}),", ",(0,s.jsx)(n.code,{children:"DATE"}),", ",(0,s.jsx)(n.code,{children:"TIME"}),") or\nnumeric type."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A timestamp column can grow monotonically or almost monotonically"}),". Time\nseries data often arrives ordered by timestamp, i.e., every event has the same\nor larger timestamp than the previous event.  In some cases, events can get\nreordered and delayed, but this delay is bounded, e.g., it may not exceed 1\nhour.  We refer to this bound as ",(0,s.jsx)(n.strong,{children:"lateness"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lateness"})," is a constant bound ",(0,s.jsx)(n.code,{children:"L"})," associated with a timestamp column in a\ntable or view, such that if the table contains a record with timestamp equal to\n",(0,s.jsx)(n.code,{children:"TS"}),", then any future records inserted to or removed from the table will have\ntimestamps greater than or equal to ",(0,s.jsx)(n.code,{children:"TS - L"}),".  In other words, updates to the\ntable cannot arrive more than ",(0,s.jsx)(n.code,{children:"L"})," time units out of order.\nA lateness value of zero indicates that updates to the table arrive strictly in\norder, with each new update having a timestamp equal to or later than the previous one."]}),"\n",(0,s.jsx)(n.p,{children:"The Feldera query engine uses lateness information to optimize the execution of\nqueries."}),"\n",(0,s.jsx)(n.h3,{id:"specifying-lateness-for-tables-and-views",children:"Specifying lateness for tables and views"}),"\n",(0,s.jsxs)(n.p,{children:["To specify lateness for a table column, the column declaration is annotated with\nthe ",(0,s.jsx)(n.code,{children:"LATENESS"})," attribute:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE purchase (\n   customer_id INT,\n   ts TIMESTAMP NOT NULL LATENESS INTERVAL 1 HOURS,\n   amount BIGINT\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The value of the ",(0,s.jsx)(n.code,{children:"LATENESS"})," attribute is a constant expression that must have a\ntype that can be subtracted from the column type.  In the above example,\nlateness for a column of type ",(0,s.jsx)(n.code,{children:"TIMESTAMP"})," is specified as an ",(0,s.jsx)(n.code,{children:"INTERVAL"})," type.\n",(0,s.jsx)(n.code,{children:"LATENESS"})," for an integer column is specified as an integer constant."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Views can have lateness too"}),". Lateness is a property of input data; however\nit is not always possible to associate a lateness annotation with an input table\ncolumn.  For instance, input data can arrive as JSON strings, which must be\n",(0,s.jsx)(n.a,{href:"/sql/json/#parse_json",children:"parsed"})," to extract the actual payload fields, including\ntimestamps.  In such situations, columns with lateness appear in intermediate\nviews.  To specify lateness for a view, the ",(0,s.jsx)(n.code,{children:"LATENESS"})," statement must be used.\nThe statement specifies a view, a column of the view, and an expression for the\nlateness value.  The statement may appear before or after the view declaration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW v AS SELECT t.col1, t.col2 FROM t;\nLATENESS v.col1 INTERVAL 1 HOUR;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"guidelines-for-writing-lateness-annotations",children:"Guidelines for writing lateness annotations"}),"\n",(0,s.jsx)(n.p,{children:"Keep in mind the following guidelines when choosing lateness annotations for\ntables and views:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lateness is NOT time-to-live"}),".  Lateness should not be confused with\ntime-to-live annotations used by some stream processing systems.  Declaring\na column with ",(0,s.jsx)(n.code,{children:"LATENESS"})," 1 hour does not mean that the data will be discarded\nafter an hour. The compiler decides what data to store and for how long by\nanalyzing the entire SQL program.  ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotations simply inform this\nanalysis."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"LATENESS does not affect the output of the program"}),".  Assuming lateness\nannotations are accurate, i.e., input records do not arrive more than lateness\ntime units out of order, the output of the program with lateness annotations\nis guaranteed to be identical to outputs of the same program without annotations."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"LATENESS does NOT delay computation"}),".  Feldera does not delay computation\nuntil all out-of-order records have been received.  It always computes the\noutput of the queries given all inputs received so far and incrementally updates\nthese outputs as new out-of-order inputs arrive.  (See ",(0,s.jsx)(n.a,{href:"#delaying-inputs-with-watermark",children:"below"}),"\nfor an experimental feture that allows delaying inputs on demand)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Inputs that violate lateness are discarded."}),"  When a program receives a record\nthat is more than lateness time units behind the most recent timestamp value\npreviously observed in the same column, the pipeline will drop such a record."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We recommend choosing conservative ",(0,s.jsx)(n.code,{children:"LATENESS"})," values, leaving sufficient time for any\ndelayed inputs to arrive.  In practice, this may require accounting for potential\nupstream failures, such as an IoT device losing cloud connectivity."]}),"\n",(0,s.jsx)(n.h3,{id:"lateness-example",children:"Lateness example"}),"\n",(0,s.jsxs)(n.p,{children:["Consider the ",(0,s.jsx)(n.code,{children:"purchase"})," table declared above with 1-hour lateness on the ",(0,s.jsx)(n.code,{children:"ts"})," column\nand the following sequence of inserts into this table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"INSERT INTO purchase VALUES(1, '2020-01-01 00:00:00', 10);\n\nINSERT INTO purchase VALUES(1, '2020-01-01 01:00:00', 20);\n\n-- Late row, but within the lateness bound.\nINSERT INTO purchase VALUES(1,'2020-01-01 00:10:00', 15);\n\nINSERT INTO purchase VALUES(1, '2020-01-01 02:00:00', 12);\n\n-- Late row that violates lateness.\nINSERT INTO purchase VALUES(1, '2020-01-01 00:20:00', 65);\n"})}),"\n",(0,s.jsx)(n.p,{children:"The second insertion arrives in order, since its timestamp is\nlarger than the timestamp of the first insertion.  The third insertion\nis out of order, since its timestamp is smaller than the second\ninsertion.  But it does not violate lateness, since it is\nonly 50 minutes late, whereas the specified lateness is 1 hour.\nThe fifth row violates lateness, since it is 100 minutes late with\nrespect to the fourth row, and will be discarded."}),"\n",(0,s.jsx)(n.p,{children:"Note that lateness is a soft bound.  A pipeline is guaranteed to\naccept any records that arrive within the bound; but can also accept\nlate records for a short period of time.  The reason for this is that\nFeldera ingests input records in chunks and advances the cutoff timestamp,\nbelow which inputs are discarded, after processing the whole chunk."}),"\n",(0,s.jsx)(n.h2,{id:"how-feldera-garbage-collects-old-state",children:"How Feldera garbage collects old state"}),"\n",(0,s.jsxs)(n.p,{children:["Consider the ",(0,s.jsx)(n.code,{children:"purchase"})," table from before.  As new purchase records are added\nover time, the table will keep growing.  How much of its history do we need to\nstore?  A conventional database, serving as a system of record, must store every\nrecord added to it, until it is deleted by the user, so that it can answer\nqueries over this data on-demand.  In contrast, the Feldera query engine\nincrementally maintains a set of views defined ahead of time and\nonly keeps state needed by those views."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Feldera also supports on-demand queries (also known as ",(0,s.jsx)(n.strong,{children:"ad hoc queries"}),") for\nmaterialized tables and views.  See ",(0,s.jsx)(n.a,{href:"/sql/materialized#inspecting-materialized-tables-and-views",children:"documentation"})," for details."]})}),"\n",(0,s.jsxs)(n.p,{children:["Let\u2019s assume the ",(0,s.jsx)(n.code,{children:"purchase"})," table is used to compute a single view that tracks\nthe daily maximum purchase amount:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW daily_max AS\nSELECT\n    TIMESTAMP_TRUNC(ts, DAY) as d,\n    MAX(amount) AS max_amount\nFROM\n    purchase\nGROUP BY\n    TIMESTAMP_TRUNC(ts, DAY);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.code,{children:"purchase"})," table did not have the ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotation,\nthe query engine would assume that records can be inserted and deleted\nwith arbitrary timestamps, e.g., it would be possible to delete a year-old\nrecord.  Deleting an old record requires re-computing the daily maximum\nfor the corresponding date.  This in turn requires storing the entire\npurchase history permanently."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["We can do better with ",(0,s.jsx)(n.code,{children:"LATENESS"})]}),".  The ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotation guarantees\nthat changes to the table cannot get delayed by more than one hour relative\nto each other.  Hence, daily maxima can only change for the current and, possibly,\nprevious day.  Since we will never need to reevaluate the query for earlier dates,\nwe do not need to store older data."]}),"\n",(0,s.jsx)(n.h3,{id:"the-data-retention-algorithm",children:"The data retention algorithm"}),"\n",(0,s.jsx)(n.p,{children:"To explain how Feldera discards unused state, we need to introduce a new concept:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Waterline"})," of a relation with respect to a timestamp column is a timestamp value\n",(0,s.jsx)(n.code,{children:"W"}),", such that all future additions or deletions in the relation will have timestamps\ngreater than or equal to ",(0,s.jsx)(n.code,{children:"W"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Feldera uses the following procedure to identify and discard unused data:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Compute waterlines of all program relations"}),". Starting from user-supplied\n",(0,s.jsx)(n.code,{children:"LATENESS"})," annotations, Feldera identifies all tables and views in the program\nthat produce outputs monotonic in the input timestamp and computes\nwaterlines for them."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Compute state retention bounds"}),". For each view in the program, the query engine\ndetermines how much state it needs to maintain in order to evaluate the view incrementally.\nSome queries, such as simple projections and filters, do not require keeping any state.\nOthers, such as joins and aggregates, may require storing the state of their input\nrelations.  In this case, the query engine determines ",(0,s.jsx)(n.strong,{children:"how long the state\nshould be retained"})," based on the semantics of the query and the waterlines\ncomputed at the previous step."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Discard old records"}),". Feldera continuously runs background jobs that garbage\ncollect old records that fall below retention bounds."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Not all queries support discarding old inputs"}),". We list the operators for which\nFeldera implements garbage collection ",(0,s.jsx)(n.a,{href:"#sql-for-time-series-analytics",children:"below"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Relations can have multiple waterlines"}),". The query engine can derive waterlines\nfor multiple columns in a table or view. All these waterlines can be utilized for\ngarbage collection. For example, if the ",(0,s.jsx)(n.code,{children:"purchase"})," table included an additional\ntimestamp column that recorded the time when payment was received, and this column\nhad its own ",(0,s.jsx)(n.code,{children:"LATENESS"})," attribute, we could create a view computing daily totals\nbased on this column, and garbage collection would work for this view as well."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Discarding old records is not equivalent to deleting them"}),". These are\nfundamentally different operations.  Deleting a record means that any outputs\nderived from it should be updated.  For example, deleting a year-old purchase\nrequires recomputing the ",(0,s.jsx)(n.code,{children:"daily_max"})," query for the corresponding date.\nIn contrast, a discarded record is conceptually still part of the relation;\nhowever it will not participate in computing any future incremental updates\nand therefore does not need to be stored."]}),"\n",(0,s.jsxs)(n.h2,{id:"emitting-final-values-of-a-view-with-emit_final",children:["Emitting final values of a view with ",(0,s.jsx)(n.code,{children:"emit_final"})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"emit_final"})," feature is still experimental, and it may be removed\nor substantially modified in the future."]})}),"\n",(0,s.jsx)(n.p,{children:"By default, Feldera updates SQL views incrementally whenever new\ninputs arrive. Such incremental updates include deleting existing\nrows and inserting new rows into the view.  By monitoring these\nupdates, the user can observe the most up-to-date results of the\ncomputation.  However, some applications only need to observe its\nfinal outputs, i.e., rows that are guaranteed to\nnever get deleted or updated."}),"\n",(0,s.jsx)(n.p,{children:"Consider the following query that computes the sum of all purchases\nfor each day."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW daily_total AS\nSELECT\n    TIMESTAMP_TRUNC(ts, DAY) as d,\n    SUM(amount) AS total\nFROM\n    purchase\nGROUP BY\n    TIMESTAMP_TRUNC(ts, DAY);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Suppose that a new ",(0,s.jsx)(n.code,{children:"purchase"})," record arrives every second.  In response,\nFeldera updates the ",(0,s.jsx)(n.code,{children:"daily_total"})," value for the current date,\ndeleting the old value and inserting a new one.  The user may observe\n86400 such updates per day.  In some cases this is precisely what the user\nwants--to keep track of the latest value of the aggregate with low latency.\nBut if the application only requires the final value of the aggregate at\nthe end of the day, handling all the intermediate updates may introduce\nunnecessary overheads. Some applications may not be able to handle\nintermediate updates at all.  Typical reasons for this are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The application is unable to process row deletions"}),". Some\ndatabases and database connectors cannot ingest deletions\nefficiently or at all."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The application cannot handle a large volume of incremental\nupdates."}),"  As we see in this example, the volume of intermediate\nupdates can be much larger than the final output, potentially\noverwhelming the application."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The application is only allowed to act on the final\noutput"}),". Consider an application that sends an\nemail, approves a stock trade or performs some other irreversible\naction based on the output or the view. Such actions should only\nbe taken when the output is final. Handling intermediate outputs can\ncomplicate the logic of the application, as the application may\nnot be able to reliably identify and discard intermediate values."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"emit_final"})," attribute instructs Feldera to only output final rows\nof a view, as in the following example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW daily_total_final\nWITH ('emit_final' = 'd')\nAS\nSELECT\n    TIMESTAMP_TRUNC(ts, DAY) as d,\n    SUM(amount) AS total\nFROM\n    purchase\nGROUP BY\n    TIMESTAMP_TRUNC(ts, DAY);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"emit_final"})," annotation causes the view to emit only the rows that\nhave a value in the specified column that is before the view's current\nwaterline.  Let us insert some records in the ",(0,s.jsx)(n.code,{children:"purchase"})," table and\nobserve how this affects the waterlines and the output of the view\nwith and without ",(0,s.jsx)(n.code,{children:"emit_final"})," annotations."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.code,{children:"INSERT INTO purchase"})}),(0,s.jsxs)(n.th,{children:["Output without ",(0,s.jsx)(n.code,{children:"emit_final"})]}),(0,s.jsxs)(n.th,{children:["Output with ",(0,s.jsx)(n.code,{children:"emit_final"})]})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VALUES(1, '2020-01-01 01:00:00', 10)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'insert: {"d":"2020-01-01 00:00:00","total":10}'})}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VALUES(1, '2020-01-01 02:00:00', 10)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'delete: {"d":"2020-01-01 00:00:00","total":10}'})}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'insert: {"d":"2020-01-01 00:00:00","total":20}'})}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VALUES(1, '2020-01-02 00:00:00', 10)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'insert: {"d":"2020-01-02 00:00:00","total":10}'})}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VALUES(1, '2020-01-02 01:00:00', 10)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'delete: {"d":"2020-01-02 00:00:00","total":10}'})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'insert: {"d":"2020-01-01 00:00:00","total":20}'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'insert: {"d":"2020-01-02 00:00:00","total":20}'})}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Without ",(0,s.jsx)(n.code,{children:"emit_final"}),", every input update produces an output update,\ndeleting any outdated records and inserting new records instead."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.code,{children:"emit_final"})," only outputs below the current waterline are\nproduced. In this example, the waterline of the ",(0,s.jsx)(n.code,{children:"daily_total.d"}),"\ntimestamp column remains at ",(0,s.jsx)(n.code,{children:"2020-01-01 00:00:00"})," until the last\ninput, which adds a record with timestamp ",(0,s.jsx)(n.code,{children:"2020-01-02 01:00:00"}),".\nSince ",(0,s.jsx)(n.code,{children:"purchase.ts"})," has ",(0,s.jsx)(n.code,{children:"LATENESS"})," of 1 hour, no new updates for\nthe previous date can be received after this.  The waterline\nmoves forward by one day and the final value for ",(0,s.jsx)(n.code,{children:"2020-01-01"})," is output."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"emit_final"})," property must specify either a column name that\nexists in the view, or a column number, where 0 is the leftmost view\ncolumn."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that using ",(0,s.jsx)(n.code,{children:"emit_final"})," can significantly delay the output of a view.\nIn the example above, the aggregation is performed over a 1-day window,\nresulting in a 1-day delay before the output is produced. If the aggregation\nwindow were extended to 1 year, the view would not produce any outputs for\nan entire year."]}),"\n",(0,s.jsxs)(n.p,{children:["The use of ",(0,s.jsx)(n.code,{children:"emit_final"})," is subject to the following restrictions:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the query engine cannot infer a waterline for the specified\ncolumn of the view, it will emit an error at compilation time."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Currently this annotation is only allowed on views that are not\n",(0,s.jsx)(n.a,{href:"/sql/grammar/#creating-views",children:(0,s.jsx)(n.code,{children:"LOCAL"})}),".  It takes effect only\nfor the view used as output.  If the view is used in defining\nother views, these derived views will receive the non-delayed data."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"delaying-inputs-with-watermark",children:["Delaying inputs with ",(0,s.jsx)(n.code,{children:"WATERMARK"})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"WATERMARK"})," feature is still experimental, and it may be removed\nor substantially modified in the future."]})}),"\n",(0,s.jsx)(n.p,{children:"Feldera can process data received either in-order or out-of-order.  In both\nscenarios, it continuously maintains query results computed based on the inputs\nreceived so far, updating these results as new data arrives.  However, some\napplications may not be able to handle results derived from out-of-order data\ncorrectly and prefer to wait until all out-of-order events have been delivered."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"WATERMARK"})," is an annotation on a column of a table that delays the processing\nof the input rows by a specified amount of time.  More precisely, given a ",(0,s.jsx)(n.code,{children:"WATERMARK"}),"\nannotation with value ",(0,s.jsx)(n.code,{children:"WM"}),", an input row with a value ",(0,s.jsx)(n.code,{children:"X"}),' for the watermarked column\nwill be "held up" until another row with a timestamp ',(0,s.jsx)(n.code,{children:">=X + WM"})," is received, at which\npoint the program will behave as if the row with value ",(0,s.jsx)(n.code,{children:"X"})," has only just been received."]}),"\n",(0,s.jsxs)(n.p,{children:["This delay allows ",(0,s.jsx)(n.code,{children:"WM"})," time units for out-of-order data to arrive.\nFor a column with a ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotation, setting ",(0,s.jsx)(n.code,{children:"WATERMARK"})," to be equal\nto ",(0,s.jsx)(n.code,{children:"LATENESS"})," ensures that all received data is processed in-order."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"WATERMARK"})," is specified as an expression that evaluates to a constant value.\nThe expression must have a type that can be subtracted from the column\ntype.  For example, a column of type ",(0,s.jsx)(n.code,{children:"TIMESTAMP"})," may have a watermark\nspecified as an ",(0,s.jsx)(n.code,{children:"INTERVAL"})," type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE purchase_watermark (\n   customer_id INT,\n   ts TIMESTAMP NOT NULL WATERMARK INTERVAL 1 HOURS,\n   amount BIGINT\n);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["The current version of the SQL compiler does not support multiple\n",(0,s.jsx)(n.code,{children:"WATERMARK"})," columns in a single table."]})}),"\n",(0,s.jsx)(n.h2,{id:"append-only-tables",children:"Append-only tables"}),"\n",(0,s.jsxs)(n.p,{children:["Time series tables are often append-only: once an event has been received, it\ncannot be modified or deleted.  Feldera is able to leverage this property to\noptimize certain types of queries. Consider the ",(0,s.jsx)(n.code,{children:"daily_max"})," view from above:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW daily_max AS\nSELECT\n    TIMESTAMP_TRUNC(ts, DAY) as d,\n    MAX(amount) AS max_amount\nFROM\n    purchase\nGROUP BY\n    TIMESTAMP_TRUNC(ts, DAY);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Maintaining the ",(0,s.jsx)(n.code,{children:"MAX"})," aggregate incrementally requires permanently storing the\nentire contents of the ",(0,s.jsx)(n.code,{children:"purchase"})," table (ignoring the ",(0,s.jsx)(n.code,{children:"LATENESS"})," annotation on\n",(0,s.jsx)(n.code,{children:"purchase.ts"}),").  However, if the table is append-only, then the ",(0,s.jsx)(n.code,{children:"MAX"})," aggregate\ncan only increase monotonically as new records are added to the table, and we\nonly need to store the current largest value for each 1-day window."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"append_only"})," annotation on a table instructs Feldera that the table will\nonly receive ",(0,s.jsx)(n.code,{children:"INSERT"})," updates, enabling this and other optimizations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE purchase (\n   customer_id INT,\n   ts TIMESTAMP NOT NULL LATENESS INTERVAL 1 HOURS,\n   amount BIGINT\n) WITH (\n    'append_only' = 'true'\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"append_only"})," annotations are only supported for tables; however\nthe Feldera query engine automatically derives it for views that depend on\nappend-only tables."]}),"\n",(0,s.jsx)(n.h2,{id:"sql-for-time-series-analytics",children:"SQL for time series analytics"}),"\n",(0,s.jsx)(n.p,{children:"In this section, we present a catalog of SQL operators and patterns frequently used in\ntime series analysis. Although these operators are applicable to both time-series and\nnon-time-series data, they are particularly beneficial when working with time series."}),"\n",(0,s.jsx)(n.p,{children:"Feldera offers efficient incremental implementations of these constructs and\nsupports garbage collection for most of them, meaning that they can be evaluated\nefficiently in both time and space."}),"\n",(0,s.jsx)(n.h3,{id:"aggregating-time-series-data-over-fixed-size-time-intervals",children:"Aggregating Time Series Data Over Fixed-Size Time Intervals"}),"\n",(0,s.jsxs)(n.p,{children:["A common practice in time series analysis is to segment the timeline into fixed-size\nintervals\u2014such as minutes, hours, days, or years\u2014and aggregate the data within each\nsegment. Earlier, we encountered two examples of such queries: ",(0,s.jsx)(n.code,{children:"daily_max"})," and\n",(0,s.jsx)(n.code,{children:"daily_sum"}),", which apply the ",(0,s.jsx)(n.code,{children:"MAX"})," and ",(0,s.jsx)(n.code,{children:"SUM"})," aggregation functions over 1-day\nintervals."]}),"\n",(0,s.jsx)(n.h4,{id:"garbage-collection",children:"Garbage collection"}),"\n",(0,s.jsxs)(n.p,{children:["The incremental implementation of aggregation operators stores both\nthe input and output of the operator.  Feldera applies various optimizations to\noptimize storage, for example linear aggregation functions, such as\n",(0,s.jsx)(n.code,{children:"SUM"}),", ",(0,s.jsx)(n.code,{children:"COUNT"}),", ",(0,s.jsx)(n.code,{children:"AVG"}),", ",(0,s.jsx)(n.code,{children:"STDDEV"}),", do not require storing the input relation;\n",(0,s.jsx)(n.code,{children:"MIN"})," and ",(0,s.jsx)(n.code,{children:"MAX"})," aggregates over ",(0,s.jsx)(n.a,{href:"#append-only-tables",children:"append-only"})," collections\nonly store one value per group, etc.  On top of these optimizations, the GC\nmechanism can discard old records under the following conditions:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Old input records get discarded if at least one of the expressions in the\n",(0,s.jsx)(n.code,{children:"GROUP BY"})," clause is a monotonic function of a timestamp column, for which the query\nengine can establish a waterline.  For instance, in the ",(0,s.jsx)(n.code,{children:"daily_max"})," view,\n",(0,s.jsx)(n.code,{children:"TIMESTAMP_TRUNC"})," is a monotonic function over the ",(0,s.jsx)(n.code,{children:"purchase.ts"})," column."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Old output records get discarded if at least one of the output columns\nhas a waterline.  In the ",(0,s.jsx)(n.code,{children:"daily_max"})," view, the ",(0,s.jsx)(n.code,{children:"TIMESTAMP_TRUNC(ts, DAY) as d"}),"\ncolumn has a waterline."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tumbling-and-hopping-windows",children:"Tumbling and hopping windows"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/sql/table/#tumble",children:"Tumbling"})," and ",(0,s.jsx)(n.a,{href:"/sql/table/#tumble",children:"hopping"})," window operators\nprovide a more idiomatic way to slice the timeline into non-overlapping or\noverlapping windows.  These operators do not maintain any state and therefore do\nnot require GC.  The ",(0,s.jsx)(n.code,{children:"daily_max"})," view can be expressed using the ",(0,s.jsx)(n.code,{children:"TUMBLE"})," operator\nas follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE VIEW daily_max_tumbling AS\nSELECT\n    window_start,\n    MAX(amount)\nFROM TABLE(\n  TUMBLE(\n    "DATA" => TABLE purchase,\n    "TIMECOL" => DESCRIPTOR(ts),\n    "SIZE" => INTERVAL 1 DAY))\nGROUP BY\n    window_start;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"rolling-aggregates",children:"Rolling aggregates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.feldera.com/blog/rolling-aggregates",children:"Rolling aggregates"})," offer a\ndifferent way to define time windows. For each data point in a time series, they\ncompute an aggregate over a fixed time frame (such as a day, an hour, or a\nmonth) preceding this data point.  Rolling aggregates can be expressed in SQL using\n",(0,s.jsx)(n.a,{href:"/sql/aggregates#window-aggregate-functions",children:"window aggregate functions"}),".\nHere is a version of ",(0,s.jsx)(n.code,{children:"daily_max"})," that computes ",(0,s.jsx)(n.code,{children:"MAX"})," over the 1-day window\npreceding each event:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW daily_max_rolling AS\nSELECT\n    ts,\n    amount,\n    MAX(amount) OVER window_1_day\nFROM purchase\nWINDOW window_1_day AS (ORDER BY ts RANGE BETWEEN INTERVAL 1 DAY PRECEDING AND CURRENT ROW);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Rolling aggregates provide an accurate summary of recent event history for each data\npoint in the dataset. They are more expensive than\n",(0,s.jsx)(n.a,{href:"#tumbling-and-hopping-windows",children:"tumbling and hopping windows"}),", since they instantiate as many\nindividual windows as there are data points in the table.\nFeldera features an efficient incremental implementation of the rolling aggregate operator,\nthat is capable of evaluating millions of individual windows per second on\na laptop."]}),"\n",(0,s.jsx)(n.h4,{id:"garbage-collection-1",children:"Garbage collection"}),"\n",(0,s.jsxs)(n.p,{children:["GC for rolling aggregates works similar to regular aggregates (see ",(0,s.jsx)(n.a,{href:"#aggregating-time-series-data-over-fixed-size-time-intervals",children:"above"}),"):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Old input records are discarded if the ",(0,s.jsx)(n.code,{children:"ORDER BY"})," expression is a monotonic function\nof a timestamp column, for which the query engine can establish a waterline.  For\ninstance, in the ",(0,s.jsx)(n.code,{children:"rolling_daily_max"})," view above, the ",(0,s.jsx)(n.code,{children:"purchase.ts"})," column, used in the\n",(0,s.jsx)(n.code,{children:"ORDER BY"})," clause, has a waterline."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Old output records get discarded if at least one of the output columns\nhas a waterline.  In the ",(0,s.jsx)(n.code,{children:"rolling_daily_max"})," view, the ",(0,s.jsx)(n.code,{children:"ts"})," column copied\nfrom the input table has a waterline."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"join-over-timestamp-columns",children:"Join over timestamp columns"}),"\n",(0,s.jsxs)(n.p,{children:["The following query computes daily totals over the ",(0,s.jsx)(n.code,{children:"purchase"})," and ",(0,s.jsx)(n.code,{children:"returns"}),"\ntables and joins the results by date in order to construct a daily summary\ncombining both totals for each given day in a single view:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW daily_totals AS\nWITH\n    purchase_totals AS (\n        SELECT\n            TIMESTAMP_TRUNC(purchase.ts, DAY) as purchase_date,\n            SUM(purchase.amount) as total_purchase_amount\n        FROM purchase\n        GROUP BY\n            TIMESTAMP_TRUNC(purchase.ts, DAY)\n    ),\n    return_totals AS (\n        SELECT\n            TIMESTAMP_TRUNC(returns.ts, DAY) as return_date,\n            SUM(returns.amount) as total_return_amount\n        FROM returns\n        GROUP BY\n            TIMESTAMP_TRUNC(returns.ts, DAY)\n    )\nSELECT\n    purchase_totals.purchase_date as d,\n    purchase_totals.total_purchase_amount,\n    return_totals.total_return_amount\nFROM\n    purchase_totals\n    FULL OUTER JOIN\n    return_totals\nON\n    purchase_totals.purchase_date = return_totals.return_date;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"garbage-collection-2",children:"Garbage collection"}),"\n",(0,s.jsxs)(n.p,{children:["The join operator stores both of its input relations.  If at least one pair of\ncolumns being joined on has waterlines (in this case, both ",(0,s.jsx)(n.code,{children:"purchase_totals.purchase_date"}),"\nand ",(0,s.jsx)(n.code,{children:"return_totals.return_date"})," have waterlines), the operator discards old records\nbelow the smaller of the two waterlines."]}),"\n",(0,s.jsx)(n.h3,{id:"as-of-joins",children:"As-of joins"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://www.feldera.com/blog/asof-join",children:(0,s.jsx)(n.code,{children:"ASOF JOIN"})}),' operator is a specialized\ntype of JOIN used between two relations with comparable timestamp columns. It is\nused to answer questions such as "What was the stock price at\nthe exact moment of the transaction?" or "What was the account balance just before\nthe money transfer?"']}),"\n",(0,s.jsxs)(n.p,{children:["For each row in the left input relation, the as-of join operator identifies at most\none row in the right input with the closest timestamp that is no greater than the\ntimestamp in the left row. The example below demonstrates how an as-of join can be\nused to extract the customer\u2019s address at the time of purchase from the ",(0,s.jsx)(n.code,{children:"customer"}),"\ntable."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW purchase_with_address AS\nSELECT\n    purchase.ts,\n    purchase.customer_id,\n    customer.address\nFROM purchase\nLEFT ASOF JOIN customer MATCH_CONDITION(purchase.ts >= customer.ts)\nON purchase.customer_id = customer.customer_id;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"garbage-collection-3",children:"Garbage collection"}),"\n",(0,s.jsxs)(n.p,{children:["The incremental as-of join operator stores both of its input relations.  Feldera\ncurrently implements GC for the left input only: if both timestamp columns\nin the ",(0,s.jsx)(n.code,{children:"MATCH_CONDITION"})," have waterlines, the operator will discard old records\nbelow the smaller of the two waterlines."]}),"\n",(0,s.jsxs)(n.p,{children:["GC for the right input is on our ",(0,s.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/1850",children:"roadmap"}),".\n",(0,s.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/new/",children:"Let us know"})," if you are interested in this feature."]}),"\n",(0,s.jsxs)(n.h3,{id:"lag-and-lead",children:[(0,s.jsx)(n.code,{children:"LAG"})," and ",(0,s.jsx)(n.code,{children:"LEAD"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.a,{href:"/sql/aggregates#window-aggregate-functions",children:[(0,s.jsx)(n.code,{children:"LAG"})," and ",(0,s.jsx)(n.code,{children:"LEAD"})]})," SQL window functions allow access\nto a previous or following row in a relation.  When used with a window ordered by a timestamp\ncolumn, they refer to earlier or later data points in a time series. The following view computes\nprevious and next purchase amounts for each record in the ",(0,s.jsx)(n.code,{children:"purchase"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW purchase_with_prev_next AS\nSELECT\n    ts,\n    customer_id,\n    amount,\n    LAG(amount) OVER(PARTITION BY customer_id ORDER BY ts) as previous_amount,\n    LEAD(amount) OVER(PARTITION BY customer_id ORDER BY ts) as next_amount\nFROM\n    purchase;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"garbage-collection-4",children:"Garbage collection"}),"\n",(0,s.jsxs)(n.p,{children:["GC for ",(0,s.jsx)(n.code,{children:"LAG"})," and ",(0,s.jsx)(n.code,{children:"LEAD"})," functions has not been implemented yet (see our\nGC feature ",(0,s.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/1850",children:"roadmap"}),").\n",(0,s.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/new/",children:"Let us know"})," if you are interested in this feature."]}),"\n",(0,s.jsxs)(n.h2,{id:"now-and-temporal-filters",children:[(0,s.jsx)(n.code,{children:"NOW()"})," and temporal filters"]}),"\n",(0,s.jsxs)(n.p,{children:["All features discussed so far evaluate SQL queries over time series data without\nreferring to the current physical time.  Feldera allows using the current\nphysical time in queries via the ",(0,s.jsx)(n.a,{href:"/sql/datetime/#now",children:(0,s.jsx)(n.code,{children:"NOW()"})})," function.  The primary use of this\nfunction is in implementing ",(0,s.jsx)(n.strong,{children:"temporal filters"}),", i.e., queries that filter\nrecords based on the current time values, e.g.:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW recent_purchases AS\nSELECT * FROM purchase\nWHERE\n    ts >= NOW() - INTERVAL 7 DAYS;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"NOW()"})," is the only construct in Feldera that can cause the pipeline to produce\noutputs without receiving any new input.  In the above example, the pipeline will\noutput deletions for records that fall outside the 7-day window as the physical\nclock ticks forward."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/sql/datetime/#now",children:(0,s.jsx)(n.code,{children:"NOW()"})})," documentation for more details."]}),"\n",(0,s.jsx)(n.h4,{id:"garbage-collection-5",children:"Garbage collection"}),"\n",(0,s.jsxs)(n.p,{children:["Feldera implements garbage collection for temporal filters by discarding records older\nthan the left window bound (e.g., records more than 7 days old in the above example).\nThis optimization is sound because ",(0,s.jsx)(n.code,{children:"NOW()"})," grows monotonically, and not ",(0,s.jsx)(n.em,{children:"not"})," require\nthe timestamp column to have a waterline."]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.feldera.com/blog/lateness-in-streaming-programs",children:"Blog post: LATENESS in streaming programs"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);