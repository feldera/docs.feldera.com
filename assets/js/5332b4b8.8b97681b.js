"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8472],{11470:(e,n,t)=>{t.d(n,{A:()=>w});var s=t(96540),i=t(34164),a=t(23104),r=t(56347),o=t(205),c=t(57485),l=t(31682),d=t(70679);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return h(e).map((({props:{value:e,label:n,attributes:t,default:s}})=>({value:e,label:n,attributes:t,default:s})))}(t);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function m({queryString:e=!1,groupId:n}){const t=(0,r.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})}),[i,t])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,a=u(e),[r,c]=(0,s.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a}))),[l,h]=m({queryString:t,groupId:i}),[x,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,d.Dv)(n);return[t,(0,s.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:i}),g=(()=>{const e=l??x;return p({value:e,tabValues:a})?e:null})();(0,o.A)((()=>{g&&c(g)}),[g]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),f(e)}),[h,f,a]),tabValues:a}}var f=t(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(74848);function b({className:e,block:n,selectedValue:t,selectValue:s,tabValues:r}){const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),l=e=>{const n=e.currentTarget,i=o.indexOf(n),a=r[i].value;a!==t&&(c(n),s(a))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},e),children:r.map((({value:e,label:n,attributes:s})=>(0,j.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:l,...s,className:(0,i.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function v({lazy:e,children:n,selectedValue:t}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find((e=>e.props.value===t));return e?(0,s.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function y(e){const n=x(e);return(0,j.jsxs)("div",{className:(0,i.A)("tabs-container",g.tabList),children:[(0,j.jsx)(b,{...n,...e}),(0,j.jsx)(v,{...n,...e})]})}function w(e){const n=(0,f.A)();return(0,j.jsx)(y,{...e,children:h(e.children)},String(n))}},19365:(e,n,t)=>{t.d(n,{A:()=>r});t(96540);var s=t(34164);const i={tabItem:"tabItem_Ymn6"};var a=t(74848);function r({children:e,hidden:n,className:t}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,s.A)(i.tabItem,t),hidden:n,children:e})}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},85619:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"pipelines/transactions","title":"Efficient Bulk Data Processing using Transactions","description":"Transaction support is an experimental feature and may undergo significant","source":"@site/docs/pipelines/transactions.md","sourceDirName":"pipelines","slug":"/pipelines/transactions","permalink":"/pipelines/transactions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Synchronizing checkpoints to object store","permalink":"/pipelines/checkpoint-sync"},"next":{"title":"Measuring Pipeline Latency","permalink":"/pipelines/latency"}}');var i=t(74848),a=t(28453),r=t(11470),o=t(19365);const c={},l="Efficient Bulk Data Processing using Transactions",d={},h=[{value:"Overview",id:"overview",level:2},{value:"Transaction API",id:"transaction-api",level:2},{value:"Start a transaction",id:"start-a-transaction",level:3},{value:"Commit a transaction",id:"commit-a-transaction",level:3},{value:"Monitoring transaction status",id:"monitoring-transaction-status",level:3},{value:"Automatic Transaction Orchestration",id:"automatic-transaction-orchestration",level:2},{value:"Supported Connectors",id:"supported-connectors",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Example",id:"example",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"efficient-bulk-data-processing-using-transactions",children:"Efficient Bulk Data Processing using Transactions"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Transaction support is an experimental feature and may undergo significant\nchanges, including non-backward-compatible modifications in future releases of\nFeldera."})}),"\n",(0,i.jsx)(n.p,{children:"Transactions enable Feldera pipelines to ingest and process large volumes of data atomically\u2014in\none logical unit of work rather than piece-by-piece.  Transactions are used to achieve:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Efficient backfill"}),": ingest and process large historical datasets."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Atomicity"}),": process multiple inputs atomically without emitting intermediate results."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["By default, Feldera pipelines run in ",(0,i.jsx)(n.strong,{children:"continuous mode"}),": they ingest a chunk of\ndata from input connectors, process it to completion and produce updates to all\nviews before processing the next chunk.  This mode is optimal for low-latency\nincremental view maintenance; but less suited for bulk data ingest."]}),"\n",(0,i.jsxs)(n.p,{children:["A common scenario is when a pipeline must ingest a large volume of historical data\naccumulated over years before processing new real-time inputs. This is known as\nthe ",(0,i.jsx)(n.strong,{children:"backfill"})," problem. While backfill can be performed in continuous mode,\nthis is likely to lead to two issues:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance:"})," computing all intermediate updates can be more expensive than\ncomputing the cumulative update. The exact performance difference depends on\nyour SQL queries and can be very significant in some cases."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Atomicity:"})," in continuous mode the pipeline produces a stream of intermediate\nupdates, which often cancel each other out.  Consider for instance a ",(0,i.jsx)(n.code,{children:"COUNT(*)"}),"\nquery whose output changes any time new records are ingested.  These updates\nexpose intermediate computation results to downstream systems while placing\nexcessive load on the data sinks."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Transactions"})," solve these challenges by allowing input updates to be grouped into\na single batch and processed atomically. In transactional mode,\nFeldera still executes SQL queries incrementally and produces a delta of changes\nto output views. The key difference is in who controls the batch size: instead of the\nengine automatically deciding chunk boundaries, the user explicitly defines the scope\nof each transaction."]}),"\n",(0,i.jsx)(n.p,{children:"The following table summarizes the two modes:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Continuous Mode"}),(0,i.jsx)(n.th,{children:"Transactions"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"When to use"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)("p",{children:"Process real-time inputs with low latency"})}),(0,i.jsx)(n.td,{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Efficiently process bulk data"}),(0,i.jsx)("li",{children:"Process multiple updates atomically"})]})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"When query evaluation is triggered"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)("p",{children:"When an input chunk is ingested"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)("p",{children:"On transaction commit"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Strong consistency"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)("p",{children:"Yes: after processing an input chunk, the contents of all views matches all the inputs received so far."})}),(0,i.jsx)(n.td,{children:(0,i.jsx)("p",{children:"Yes: after committing a transaction the contents of all matches all the inputs received so far, including inputs received as part of the transaction."})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"transaction-api",children:"Transaction API"}),"\n",(0,i.jsx)(n.h3,{id:"start-a-transaction",children:"Start a transaction"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"/api/begin-transaction",children:(0,i.jsx)(n.code,{children:"start_transaction"})})," API to start a transaction. The API returns a transaction ID:"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"rest",label:"REST API",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'$ curl -X POST http://localhost:8080/v0/pipelines/my_pipeline/start_transaction\n\n{"transaction_id":1}\n'})})}),(0,i.jsx)(o.A,{value:"python",label:"Python SDK",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from feldera.pipeline import Pipeline\n\ntransaction_id = pipeline.start_transaction()\n"})})}),(0,i.jsx)(o.A,{value:"fda",label:"fda CLI",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"$ fda start-transaction my_pipeline\n\nTransaction started successfully with ID: 1\n"})})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"start_transaction"})," call will fail if there is already a transaction in progress."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"During a transaction, the pipeline ingests incoming data without producing output, performing only minimal processing such as resolving primary keys and indexing inputs."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Any inputs received by the pipeline between ",(0,i.jsx)(n.code,{children:"start_transaction"})," and ",(0,i.jsx)(n.code,{children:"commit_transaction"}),", along with data buffered by input connectors but not yet processed at the time ",(0,i.jsx)(n.code,{children:"start_transaction"})," is called, are processed as part of the transaction."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"commit-a-transaction",children:"Commit a transaction"}),"\n",(0,i.jsxs)(n.p,{children:["Once the pipeline has ingested all inputs that must be processed as part of the transaction,\ncommit the transaction using the ",(0,i.jsx)(n.a,{href:"/api/commit-transaction",children:(0,i.jsx)(n.code,{children:"commit_transaction"})})," API."]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"rest",label:"REST API",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'$ curl -X POST http://localhost:8080/v0/pipelines/my_pipeline/commit_transaction\n"Transaction commit initiated"\n'})})}),(0,i.jsx)(o.A,{value:"python",label:"Python SDK",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"transaction_id = pipeline.commit_transaction(transaction_id, wait = True)\n"})})}),(0,i.jsx)(o.A,{value:"fda",label:"fda CLI",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"$ fda commit-transaction my_pipeline\n\nTransaction committed successfully.\n"})})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"commit_transaction"})," REST API initiates the commit. The commit can take some time and complete later.\nUse the ",(0,i.jsxs)(n.a,{href:"#monitoring-transaction-status",children:[(0,i.jsx)(n.code,{children:"/stats"})," endpoint"]})," to monitor transaction status."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The Python SDK and ",(0,i.jsx)(n.code,{children:"fda"})," CLI provide both blocking and non-blocking variants of the commit operation.\nThe blocking variant waits until the commit is complete before returning control to the caller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"During a transaction commit, the pipeline computes updates to all views in the\nprogram. Depending on the volume of ingested data and the complexity of the\nviews, this process can take a significant amount of time. While the commit is\nin progress, the pipeline neither ingests new inputs nor produces outputs. To\nprovide visibility, the pipeline periodically (every 10 seconds) logs the\nprogress of the current commit operation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Once the commit is complete, the pipeline outputs a batch of updates for every view in the program.\nThese updates are processed by the output connectors, which send them to their associated data sinks."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When the transaction is complete, the pipeline goes back into continuous processing mode. The user can start a new transaction any time."}),"\n",(0,i.jsx)(n.h3,{id:"monitoring-transaction-status",children:"Monitoring transaction status"}),"\n",(0,i.jsxs)(n.p,{children:["The user can monitor the transaction handling status of the pipeline using the ",(0,i.jsx)(n.a,{href:"/api/get-pipeline-stats",children:(0,i.jsx)(n.code,{children:"/stats"})})," endpoint. The status can be one of:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Status"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"NoTransaction"})}),(0,i.jsx)(n.td,{children:"There is currently no active transaction. The pipeline is running in continuous mode."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TransactionInProgress"})}),(0,i.jsx)(n.td,{children:"There is an active transaction in progress."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"CommitInProgress"})}),(0,i.jsx)(n.td,{children:"The current transaction is being committed."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["When the status is ",(0,i.jsx)(n.code,{children:"TransactionInProgress"})," or ",(0,i.jsx)(n.code,{children:"CommitInProgress"}),", the ",(0,i.jsx)(n.code,{children:"transaction_id"})," attribute contains the current transaction ID."]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"rest",label:"REST API",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"$ curl -s http://localhost:8080/v0/pipelines/my_pipeline/stats | jq -r '.global_metrics.transaction_status'\nTransactionInProgress\n\n$ curl -s http://localhost:8080/v0/pipelines/my_pipeline/stats | jq -r '.global_metrics.transaction_id'\n1\n"})})}),(0,i.jsx)(o.A,{value:"python",label:"Python SDK",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"transaction_status = pipeline.transaction_status()\ntransaction_id = pipeline.transaction_id()\n"})})}),(0,i.jsx)(o.A,{value:"fda",label:"fda CLI",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"$ fda stats my_pipeline --format json | jq -r '.global_metrics.transaction_status'\nCommitInProgress\n\n$ fda stats my_pipeline --format json | jq -r '.global_metrics.transaction_id'\n1\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"automatic-transaction-orchestration",children:"Automatic Transaction Orchestration"}),"\n",(0,i.jsxs)(n.p,{children:["In addition to initiating transactions programmatically via the API, certain input connectors can also be configured to initiate transactions automatically.\nThis feature enables users to leverage transactions ",(0,i.jsx)(n.strong,{children:"declaratively"})," within the pipeline\u2019s SQL definition."]}),"\n",(0,i.jsx)(n.p,{children:"Use cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Backfill"})," \u2014 When a pipeline starts, input connectors often start with ingesting historical data from their associated data sources.\nIt is beneficial to ingest and process this data as part of a single transaction as explained in the previous sections."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Atomic processing of related updates"})," \u2014 Some data sources, such as Delta Lake, partition the input stream into groups of updates that must be applied together as a single atomic unit.\nBy processing each of these groups as one Feldera transaction, the system preserves atomicity end-to-end, ensuring that all related updates are applied together."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Multiple connectors attached to the same or different SQL tables may initiate transactions concurrently.\nIn this case, Feldera automatically combines these individual transaction requests into a single coordinated transaction:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The transaction ",(0,i.jsx)(n.strong,{children:"begins"})," when the first connector initiates it."]}),"\n",(0,i.jsxs)(n.li,{children:["The transaction ",(0,i.jsx)(n.strong,{children:"commits"})," when the last participating connector commits the transaction."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example, if several connectors performing backfill are configured to use transactions, their operations will be merged into one composite transaction, effectively\nequivalent to initiating a single transaction through the REST API that ingests all historical inputs together."}),"\n",(0,i.jsx)(n.h3,{id:"supported-connectors",children:"Supported Connectors"}),"\n",(0,i.jsxs)(n.p,{children:["Automatic transaction orchestration is currently supported only for the ",(0,i.jsx)(n.strong,{children:"Delta Lake connector"}),".\nRefer to the ",(0,i.jsx)(n.a,{href:"/connectors/sources/delta#transactions",children:"Delta Lake connector documentation"})," for details."]}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Concurrent transactions are not supported. At most one transaction can run at a time. All inputs ingested by the pipeline while the transaction is active are processed as part of the transaction."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Checkpointing is disabled during a transaction. A checkpoint initiated during a transaction gets delayed until the transaction has committed."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["A transaction currently cannot be aborted or rolled back. Let us know if this feature is important for your use case by ",(0,i.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/4710",children:"leaving a comment"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'# Create a simple pipeline that copies all records in table `t` to view `v`.\n$ echo \'create table t(x int); create materialized view v as select * from t;\' | fda create transaction_test --stdin\nPipeline created successfully.\n\n$ fda start transaction_test\nPipeline started successfully.\n\n# Update the table.\n$ fda query transaction_test "insert into t values(1)"\n+-------+\n| count |\n+-------+\n| 1     |\n+-------+\n\n# The change is instantly reflected in the output view.\n$ fda query transaction_test "select * from v"\n+---+\n| x |\n+---+\n| 1 |\n+---+\n\n# Start a transaction.\n$ fda start-transaction transaction_test\nTransaction started successfully with ID: 1\n\n# Insert more records.\n$ fda query transaction_test "insert into t values(2)"\n+-------+\n| count |\n+-------+\n| 1     |\n+-------+\n\n$ fda query transaction_test "insert into t values(3)"\n+-------+\n| count |\n+-------+\n| 1     |\n+-------+\n\n# The view remains unmodified since the transaction has not been committed.\n$ fda query transaction_test "select * from v"\n+---+\n| x |\n+---+\n| 1 |\n+---+\n\n# Commit the transaction.\n$ fda commit-transaction transaction_test\nTransaction committed successfully.\n\n# Updates performed during the transaction are now propagated to all views.\n$ fda query transaction_test "select * from v"\n+---+\n| x |\n+---+\n| 2 |\n| 3 |\n| 1 |\n+---+\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);