"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[465],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var s=t(96540);const i={},a=s.createContext(i);function l(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(a.Provider,{value:n},e.children)}},37655:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"use_cases/otel/insights","title":"Extracting High-Level Metrics","description":"In the previous step, we pre-processed the data to make it easier to analyze in SQL. Next, we want to generate valuable insights from it.","source":"@site/docs/use_cases/otel/insights.md","sourceDirName":"use_cases/otel","slug":"/use_cases/otel/insights","permalink":"/use_cases/otel/insights","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Sending OTel data to Feldera","permalink":"/use_cases/otel/preprocessing"},"next":{"title":"Grafana Integration","permalink":"/use_cases/otel/grafana"}}');var i=t(74848),a=t(28453);const l={},r="Extracting High-Level Metrics",o={},c=[{value:"P95 Latency",id:"p95-latency",level:3},{value:"Step 1: Define a Tumbling Window",id:"step-1-define-a-tumbling-window",level:4},{value:"Step 2: Define a Rust UDF for P95 Calculation",id:"step-2-define-a-rust-udf-for-p95-calculation",level:4},{value:"SQL Definition for P95 Rust UDF",id:"sql-definition-for-p95-rust-udf",level:5},{value:"Rust Implementation of P95",id:"rust-implementation-of-p95",level:5},{value:"Step 3: Compute P95 Latency per 10 Second Window",id:"step-3-compute-p95-latency-per-10-second-window",level:4},{value:"Throughput",id:"throughput",level:3},{value:"Operation Execution Time",id:"operation-execution-time",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"extracting-high-level-metrics",children:"Extracting High-Level Metrics"})}),"\n",(0,i.jsx)(n.p,{children:"In the previous step, we pre-processed the data to make it easier to analyze in SQL. Next, we want to generate valuable insights from it."}),"\n",(0,i.jsx)(n.h3,{id:"p95-latency",children:"P95 Latency"}),"\n",(0,i.jsx)(n.p,{children:"P95 latency is a common statistical measure used for network performance analysis.\nIt means that 95% of requests were served faster than this value, while 5% took longer than this."}),"\n",(0,i.jsx)(n.h4,{id:"step-1-define-a-tumbling-window",children:"Step 1: Define a Tumbling Window"}),"\n",(0,i.jsxs)(n.p,{children:["To compute P95 latency over time, we first define a ",(0,i.jsx)(n.strong,{children:"10-second tumbling window"})," on the ",(0,i.jsx)(n.code,{children:"spans"})," view\nwe defined previously."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- continuation of the SQL program from the previous page\n\nCREATE LOCAL VIEW spans_tumble_10s AS\nSELECT * FROM TABLE(\n\tTUMBLE(\n\t\tTABLE spans,\n\t\tDESCRIPTOR(eventTime),\n\t\tINTERVAL '10' SECOND\n\t)\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"This groups spans into non-overlapping 10-second time windows."}),"\n",(0,i.jsx)(n.h4,{id:"step-2-define-a-rust-udf-for-p95-calculation",children:"Step 2: Define a Rust UDF for P95 Calculation"}),"\n",(0,i.jsxs)(n.p,{children:["Typically, the SQL function ",(0,i.jsx)(n.code,{children:"PERCENTILE"})," can be used to calculate the P95 latency. However, Feldera SQL\ndoesn't support it yet. This presents us an opportunity to use a Rust ",(0,i.jsx)(n.a,{href:"https://docs.feldera.com/sql/udf",children:"UDFs"}),".\nThis UDF will be a function that given an array of integers, returns the 95th percentile value from it."]}),"\n",(0,i.jsx)(n.h5,{id:"sql-definition-for-p95-rust-udf",children:"SQL Definition for P95 Rust UDF"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- UDF to calculate p95 value given an integer array\nCREATE FUNCTION p95(x BIGINT ARRAY NOT NULL) RETURNS BIGINT;\n"})}),"\n",(0,i.jsx)(n.h5,{id:"rust-implementation-of-p95",children:"Rust Implementation of P95"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// udf.rs\n\npub fn p95(x: Vec<Option<i64>>) -> Result<Option<i64>, Box<dyn std::error::Error>> {\n\tlet mut x: Vec<i64> = x.into_iter().filter_map(|x| x).collect();\n\n\tif x.is_empty() {\n\t\treturn Ok(None);\n\t}\n\n\tx.sort_unstable();\n\n\tlet rank = 0.95 * x.len() as f64 - 1.0;\n\tlet lower = rank.floor() as usize;\n\tlet upper = rank.ceil() as usize;\n\n\tif lower == upper {\n\t\tOk(Some(x[lower]))\n\t} else {\n\t\tlet weight = rank - lower as f64;\n\t\tOk(Some((x[lower] as f64 * (1.0 - weight) + x[upper] as f64 * weight) as i64))\n\t}\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This function:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Filters out null values and sorts the values."}),"\n",(0,i.jsx)(n.li,{children:"Finds the 95th percentile index."}),"\n",(0,i.jsx)(n.li,{children:"Interpolates and returns the P95 value."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"step-3-compute-p95-latency-per-10-second-window",children:"Step 3: Compute P95 Latency per 10 Second Window"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Calculate the p95 latency in milliseconds\nCREATE MATERIALIZED VIEW p95_latency AS\nSELECT\n\tp95(array_agg(elapsedTimeMillis)) as latencyMs,\n\twindow_start as 'time'\nFROM spans_tumble_10s\nWHERE\n\tparentSpanId = '' -- Only consider top-level requests\nGROUP BY\n\twindow_start;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This filters only the top level traces and aggregates ",(0,i.jsx)(n.code,{children:"elapsedTimeMillis"})," values into an array and calls the ",(0,i.jsx)(n.code,{children:"p95"})," function."]}),"\n",(0,i.jsx)(n.h3,{id:"throughput",children:"Throughput"}),"\n",(0,i.jsx)(n.p,{children:"Throughput measures the number of top-level requests processed per second.\nIn this demo however, we calculate throughput on 10 second time buckets instead of per second."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW throughput AS\nSELECT\n\tCOUNT(*) as throughput,\n\twindow_start as 'time'\nFROM\n\tspans_tumble_10s\nWHERE\n\tparentSpanId = ''\nGROUP BY\n\twindow_start;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operation-execution-time",children:"Operation Execution Time"}),"\n",(0,i.jsx)(n.p,{children:"Operation execution time measures how long each operation actually took, excluding time spent in child spans."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW operation_execution_time as\nSELECT\n    s.name,\n    SUM(\n        s.elapsedTimeMillis -\n        coalesce(\n            select\n                sum(elapsedTimeMillis)\n                FROM spans k\n                WHERE k.traceId = s.traceId\n                AND k.parentSpanId = s.spanId,\n            0\n        )\n    ) as elapsed\nFROM spans s\nGROUP BY s.name;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Explanation:\n4. ",(0,i.jsx)(n.code,{children:"s.elapsedTimeMillis"}),": Total execution time of the operation.\n5. Subtracts time spent in child spans to compute actual execution time.\n6. Groups results by operation name ",(0,i.jsx)(n.code,{children:"s.name"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);