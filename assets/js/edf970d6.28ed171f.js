"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8020],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var t=s(96540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},51568:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"sql/identifiers","title":"Identifiers","description":"The names of tables, columns, functions, user-defined types, field","source":"@site/docs/sql/identifiers.md","sourceDirName":"sql","slug":"/sql/identifiers","permalink":"/sql/identifiers","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"SQL Grammar","permalink":"/sql/grammar"},"next":{"title":"Data Types","permalink":"/sql/types"}}');var i=s(74848),a=s(28453);const r={},d="Identifiers",c={},l=[{value:"Name lookup",id:"name-lookup",level:2},{value:"Lateral column aliasing",id:"lateral-column-aliasing",level:2},{value:"Comments",id:"comments",level:2}];function o(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"identifiers",children:"Identifiers"})}),"\n",(0,i.jsx)(n.p,{children:"The names of tables, columns, functions, user-defined types, field\nnames, and other metadata elements used in a SQL query are represented\nby identifiers."}),"\n",(0,i.jsxs)(n.p,{children:["Unquoted identifiers, such as ",(0,i.jsx)(n.code,{children:"emp"}),", must start with a letter and can\nonly contain letters, digits, and underscores. They are automatically\nconverted to all-lower case.  So ",(0,i.jsx)(n.code,{children:"emp"}),", ",(0,i.jsx)(n.code,{children:"EMP"}),", and ",(0,i.jsx)(n.code,{children:"eMp"})," are all\nconverted to the same lowercase identifier ",(0,i.jsx)(n.code,{children:"emp"}),", and they all\nrepresent the same identifier."]}),"\n",(0,i.jsxs)(n.p,{children:["Quoted identifiers, such as ",(0,i.jsx)(n.code,{children:'"Employee Name"'}),", start and end with\ndouble quotes. They may contain virtually any character, including\nspaces and other punctuation. If you wish to include a double quote in\nan identifier, use another double quote to escape it, like this: ",(0,i.jsx)(n.code,{children:'"An employee called ""Fred""."'}),".  The identifiers ",(0,i.jsx)(n.code,{children:'"emp"'})," and ",(0,i.jsx)(n.code,{children:'"EMP"'})," are\nthus different.  Quoted identifiers are left unchanged."]}),"\n",(0,i.jsx)(n.p,{children:'A variant of quoted identifiers allows including escaped Unicode\ncharacters identified by their code points. This variant starts with\nU& (upper or lower case U followed by ampersand) immediately before\nthe opening double quote, without any spaces in between, for example\nU&"foo".  Inside the quotes, Unicode characters can be specified in\nescaped form by writing a backslash followed by the four-digit\nhexadecimal code point number. For example, the identifier "data"\ncould be written as'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'U&"d\\0061t\\0061"'})}),"\n",(0,i.jsxs)(n.p,{children:["If a different escape character than backslash is desired, it can be\nspecified using the UESCAPE clause after the string, for example using\n",(0,i.jsx)(n.code,{children:"!"})," as the escape character:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"U&\"d!0061t!0061\" UESCAPE '!'"})}),"\n",(0,i.jsx)(n.p,{children:"The escape character can be any single character other than a\nhexadecimal digit, the plus sign, a single quote, a double quote, or a\nwhitespace character. Note that the escape character is written in\nsingle quotes, not double quotes, after UESCAPE."}),"\n",(0,i.jsx)(n.p,{children:"To include the escape character in the identifier literally, write it\ntwice."}),"\n",(0,i.jsx)(n.h2,{id:"name-lookup",children:"Name lookup"}),"\n",(0,i.jsx)(n.p,{children:"Unquoted identifiers are all converted automatically to lowercase\nduring parsing.  Quoted identifiers are left unchanged."}),"\n",(0,i.jsxs)(n.p,{children:["After these conversions, table, view, user-defined type names,\nuser-defined field names, ",(0,i.jsx)(n.code,{children:"ROW"})," type field names, user-defined\nfunction names, and column names are looked-up in a case-sensitive\nmanner.  However, for the pre-defined functions, name lookup is\ncase-insensitive.  This means that users ",(0,i.jsx)(n.em,{children:"cannot"})," define new functions\nor types whose names match existing function names, if they only\ndiffer in case."]}),"\n",(0,i.jsx)(n.h2,{id:"lateral-column-aliasing",children:"Lateral column aliasing"}),"\n",(0,i.jsxs)(n.p,{children:["Feldera SQL supports an extension to standard SQL where columns\ndefined within a ",(0,i.jsx)(n.code,{children:"SELECT"})," statement can be used immediately by\nexpressions that appear to the right of their definition in the same\n",(0,i.jsx)(n.code,{children:"SELECT"})," statement.  These columns can also be referenced within the\nassociated ",(0,i.jsx)(n.code,{children:"GROUP BY"})," and ",(0,i.jsx)(n.code,{children:"HAVING"})," statements.  This is a feature\navailable in some SQL dialects such as Spark SQL, DuckDB, Snowflake,\nand Redshift."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE T(x INT);\nINSERT INTO T VALUES(3);\n\nSELECT 1 as X, X+X as Y;\n-- result is 1, 2\n\nSELECT x+1 as Y\nFROM T\nGROUP BY Y;\n-- result is 4\n\nSELECT x+1 as Y\nFROM T\nGROUP BY Y\nHAVING Y > 0;\n-- result is 4\n"})}),"\n",(0,i.jsx)(n.p,{children:"These statements are illegal in standard SQL, but legal in Feldera\nSQL."}),"\n",(0,i.jsx)(n.p,{children:"Such statements are compiled by substituting the expression defining\nthe column for the column name everywhere the column name is used.  So\nthe above programs are equivalent to the following standard SQL\nprograms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT 1 as X, 1+1 as Y;\n\nSELECT x+1 as Y\nFROM T\nGROUP BY x+1;\n\nSELECT x+1 as Y\nFROM T\nGROUP BY x+1\nHAVING x+1 > 0;\n"})}),"\n",(0,i.jsx)(n.p,{children:"::: danger"}),"\n",(0,i.jsxs)(n.p,{children:["In order to preserve the semantics of standard SQL programs unchanged,\na new column alias is used only if there is no column with the same\nname already available in the ",(0,i.jsx)(n.code,{children:"FROM"})," statement.  In the following\nexample:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT 1+1 as x, x+x as Y FROM T;\n-- result is 2, 6, and not 2, 4!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["the ",(0,i.jsx)(n.code,{children:"SELECT"})," statement uses for ",(0,i.jsx)(n.code,{children:"x"})," the value of the column from table\n",(0,i.jsx)(n.code,{children:"T"}),", and ",(0,i.jsx)(n.em,{children:"not"})," the newly defined column ",(0,i.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,i.jsx)(n.p,{children:":::"}),"\n",(0,i.jsx)(n.h2,{id:"comments",children:"Comments"}),"\n",(0,i.jsx)(n.p,{children:"A comment is a sequence of characters beginning with double dashes and\nextending to the end of the line, e.g.:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"-- This is a standard SQL comment\n"})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively, C-style block comments can be used:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* multiline comment\n * with nesting: /* nested block comment */\n */\n"})}),"\n",(0,i.jsxs)(n.p,{children:["where the comment begins with ",(0,i.jsx)(n.code,{children:"/*"})," and extends to the matching\noccurrence of ",(0,i.jsx)(n.code,{children:"*/"}),".  Note that block comments cannot be nested unlike\nthe requirements of the SQL standard."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);