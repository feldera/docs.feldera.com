"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[1098],{10762:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"use_cases/real_time_apps/part2","title":"Exposing Feldera Pipelines to many clients","description":"This article is the second part of our series on building a billion cell spreadsheet in three parts:","source":"@site/docs/use_cases/real_time_apps/part2.md","sourceDirName":"use_cases/real_time_apps","slug":"/use_cases/real_time_apps/part2","permalink":"/use_cases/real_time_apps/part2","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Incremental, live web applications","permalink":"/use_cases/real_time_apps/part1"},"next":{"title":"A browser based UI","permalink":"/use_cases/real_time_apps/part3"}}');var r=s(74848),a=s(28453);const i={},l="Exposing Feldera Pipelines to many clients",c={},d=[{value:"Architecture",id:"architecture",level:2},{value:"API Server",id:"api-server",level:2},{value:"Sending Cell Data: <code>GET /api/spreadsheets</code>",id:"sending-cell-data-get-apispreadsheets",level:3},{value:"Sending ad-hoc queries to Feldera",id:"sending-ad-hoc-queries-to-feldera",level:4},{value:"Connecting to change streams in Feldera",id:"connecting-to-change-streams-in-feldera",level:4},{value:"Editing Cells: <code>POST /api/spreadsheets</code>",id:"editing-cells-post-apispreadsheets",level:3},{value:"Comments on Hosting",id:"comments-on-hosting",level:2},{value:"Conclusion",id:"conclusion",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"exposing-feldera-pipelines-to-many-clients",children:"Exposing Feldera Pipelines to many clients"})}),"\n",(0,r.jsx)(n.p,{children:"This article is the second part of our series on building a billion cell spreadsheet in three parts:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Part 1:"})," ",(0,r.jsx)(n.a,{href:"/use_cases/real_time_apps/part1",children:"Implement core spreadsheet logic using Feldera SQL"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Part 2 (this article):"})," Expose pipeline data to clients via a server."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Part 3:"})," ",(0,r.jsx)(n.a,{href:"/use_cases/real_time_apps/part3",children:"Add a browser-based UI"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"spreadsheet-architecture-parts",src:s(11144).A+"",width:"665",height:"370"})}),"\n",(0,r.jsxs)(n.p,{children:["Try the ",(0,r.jsx)(n.a,{href:"https://xls.feldera.io",children:"live demo"})," and see the ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet",children:"GitHub repo"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.p,{children:"To make our spreadsheet accessible to multiple clients, we created a simple REST API server that acts as a layer between the Feldera pipeline and those clients."}),"\n",(0,r.jsx)(n.p,{children:"The API server:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lets clients fetch cell content for a specified range and automatically receives updates when those cells change."}),"\n",(0,r.jsx)(n.li,{children:"Validates and forwards client updates to the pipeline."}),"\n",(0,r.jsx)(n.li,{children:"Is stateless, enabling easy scalability across many instances."}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The code for this article is in the ",(0,r.jsx)(n.code,{children:"server"})," folder of our ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet",children:"GitHub repository"}),". Clone the repo and follow the README instructions to run and deploy the demo."]})}),"\n",(0,r.jsx)(n.h2,{id:"api-server",children:"API Server"}),"\n",(0,r.jsxs)(n.p,{children:["Our REST server is written in Rust using the ",(0,r.jsx)(n.a,{href:"https://docs.rs/axum/latest/axum/",children:"axum framework"}),". The entry point is in the ",(0,r.jsx)(n.code,{children:"main.rs"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[tokio::main]\nasync fn main() {\n    let _r = env_logger::try_init();\n\n    let stats_subscription = feldera::subscribe_change_stream("spreadsheet_statistics", 128);\n    let xls_subscription = feldera::subscribe_change_stream("spreadsheet_view", 4096);\n    let api_limits = feldera::api_limit_table();\n\n    let state = AppState {\n        stats_subscription,\n        xls_subscription,\n        api_limits,\n    };\n\n    let app = Router::new()\n        .route("/", get(|| async { "xls app!" }))\n        .route("/api/stats", get(stats::stats))\n        .route("/api/spreadsheet", get(spreadsheet::ws_handler))\n        .route("/api/spreadsheet", post(spreadsheet::post_handler))\n        .with_state(state);\n    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();\n    axum::serve(\n        listener,\n        app.into_make_service_with_connect_info::<SocketAddr>(),\n    )\n    .await\n    .unwrap();\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Here are the two main tasks it handles:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connect to change streams"})," of the Feldera pipeline: spreadsheet_view, spreadsheet_statistics, and api_limits. (If you\u2019ve read the first article, you\u2019re already familiar with spreadsheet_view.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Start a web server"})," with three API endpoints:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"GET /api/stats"}),"\n",(0,r.jsx)(n.li,{children:"GET /api/spreadsheets"}),"\n",(0,r.jsx)(n.li,{children:"POST /api/spreadsheets"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We\u2019ll focus on the spreadsheet endpoints and skip stats because it\u2019s similar to fetching cell data (except it sends spreadsheet statistics)."}),"\n",(0,r.jsxs)(n.h3,{id:"sending-cell-data-get-apispreadsheets",children:["Sending Cell Data: ",(0,r.jsx)(n.code,{children:"GET /api/spreadsheets"})]}),"\n",(0,r.jsx)(n.p,{children:"This endpoint provides an initial snapshot of the requested Feldera spreadsheet cells, then streams any subsequent changes within that range to the client."}),"\n",(0,r.jsx)(n.p,{children:"We use a WebSocket endpoint for a bidirectional connection, following a simple protocol:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Client request"})," \u2013 The client requests a range of cells, sending for example: e.g., ",(0,r.jsx)(n.code,{children:"{ from: 0, to: 4 }"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Initial response"})," \u2013 The server returns the cell contents in ndjson format:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{ id: 0, raw_value: 41, computed_value: 41 }\n{ id: 1, raw_value: 1, computed_value: 1 }\n{ id: 2, raw_value: '=B0', computed_value: 1 }\n{ id: 3, raw_value: '=A0+C0', computed_value: 41 }\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Updates"})," \u2013 If cells within that range change, the server sends incremental updates:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{ id: 0, raw_value: 0, computed_value: 0 }\n{ id: 3, raw_value: 1, computed_value: 1 }\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Range changes"})," \u2013 The client can request a different range by sending a new JSON line with updated ",(0,r.jsx)(n.code,{children:"from"})," and ",(0,r.jsx)(n.code,{children:"to"})," values, receiving a fresh snapshot and corresponding updates."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The implementation resides in ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/blob/5abfb3aedc1ffa38b23341df2ed951726aef86f0/server/src/spreadsheet.rs#L46",children:"spreadsheet.rs"}),". It includes exhaustive error handling, so we\u2019ll only show key snippets here."]}),"\n",(0,r.jsxs)(n.p,{children:["The HTTP handler is brief: it upgrades the connection to WebSocket and calls ",(0,r.jsx)(n.code,{children:".subscribe()"})," on ",(0,r.jsx)(n.code,{children:"xls_subscription"})," which listens to changes from Feldera\u2019s spreadsheet_view."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub(crate) async fn ws_handler(\n    ws: WebSocketUpgrade,\n    ConnectInfo(addr): ConnectInfo<SocketAddr>,\n    State(state): State<AppState>,\n) -> impl IntoResponse {\n    debug!("{addr} connected.");\n    ws.on_upgrade(move |socket| handle_socket(state.xls_subscription.subscribe(), socket, addr))\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Let's look at the main logic which is in ",(0,r.jsx)(n.code,{children:"handle_socket"}),". This function internally spawns ",(0,r.jsx)(n.strong,{children:"two asynchronous tasks"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client messages"})," \u2013 The first task listens for messages from the client in the form ",(0,r.jsx)(n.code,{children:"{ from: x, to: y }"}),", indicating which cells the client wants. When such a request arrives, we send an ",(0,r.jsx)(n.a,{href:"/api/execute-ad-hoc-sql",children:"ad-hoc query"})," to Feldera to fetch that range and forward the result to the client:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'match process_message(msg, who) {\nControlFlow::Continue(Some(region)) => {\n    match adhoc_query(\n        format!(\n            "SELECT * FROM spreadsheet_view WHERE id >= {} and id < {}",\n            region.from, region.to\n        )\n        .as_str(),\n    )\n    .await\n    {\n        Ok(snapshot) => {\n            region_tx.send_replace(region);\n            for line in snapshot.split(\'\\n\') {\n                match change_fwder.send(line.to_string()).await {\n                    Ok(_) => {}\n                    Err(e) => {\n                        warn!("Error sending change to sender task: {e}");\n                        return cnt;\n                    }\n                }\n            }\n        }\n        Err(e) => {\n            warn!("Error querying spreadsheet_view: {e}");\n            return cnt;\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Change stream updates"})," \u2013 The second task listens to the ",(0,r.jsx)(n.code,{children:"spreadsheet_view"})," change stream. If an update falls within the client\u2019s requested cell range, it\u2019s forwarded to the client:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let mut change_task = tokio::spawn(async move {\nlet mut cnt = 0;\nloop {\n    cnt += 1;\n    match xls_changes.recv().await {\n        Ok(Ok(change)) => match serde_json::from_str::<Cell>(&change) {\n            Ok(cell) => {\n                let region = { *region_rx.borrow_and_update() };\n                if cell.id >= region.from && cell.id < region.to {\n                    match change_fwder.send(change).await {\n                        Ok(_) => {}\n                        Err(e) => {\n                            warn!("Error sending change to sender task: {e}");\n                            return cnt;\n                        }\n                    }\n                }\n            }\n            // ... omitted error handling\n        },\n    // ... omitted error handling\n    }\n}\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"sending-ad-hoc-queries-to-feldera",children:"Sending ad-hoc queries to Feldera"}),"\n",(0,r.jsxs)(n.p,{children:["In the first task, the complexity of sending an ",(0,r.jsx)(n.a,{href:"/api/execute-ad-hoc-sql",children:"ad-hoc query"})," to Feldera is hidden behind the ",(0,r.jsx)(n.code,{children:"adhoc_query"})," function. Below is the implementation."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub(crate) async fn adhoc_query(sql: &str) -> Result<String, XlsError> {\n    let url = format!("{}/v0/pipelines/{PIPELINE_NAME}/query", &*FELDERA_HOST);\n    let client = Client::new();\n    let response = client\n        .get(url)\n        .bearer_auth(&*FELDERA_API_KEY)\n        .query(&[("sql", sql), ("format", "json")])\n        .send()\n        .await\n        .map_err(XlsError::from)?;\n\n    if !response.status().is_success() {\n        return Err(XlsError::from(format!(\n            "Failed to fetch data: HTTP {}: {:?}",\n            response.status(),\n            response.text().await.unwrap_or_else(|e| e.to_string())\n        )));\n    }\n\n    let body = response.text().await.map_err(XlsError::from)?;\n\n    Ok(body)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, we send an HTTP request to the ",(0,r.jsx)(n.code,{children:"/query"})," endpoint of the Feldera instance, including the ",(0,r.jsx)(n.a,{href:"https://docs.feldera.com/tutorials/rest_api/#setup",children:"auth token"}),". We specify the SQL query and response format, and Feldera returns a set of ndjson lines\u2014one for each row in the result."]}),"\n",(0,r.jsx)(n.h4,{id:"connecting-to-change-streams-in-feldera",children:"Connecting to change streams in Feldera"}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, the second task listens for spreadsheet changes from a broadcast channel in ",(0,r.jsx)(n.code,{children:"match xls_changes.recv().await"}),". We saw this mechanism in the first article while exploring the changestream through the Webconsole. Now, we're programmatically fetching the same updates in Rust."]}),"\n",(0,r.jsxs)(n.p,{children:["Recall the ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/blob/5abfb3aedc1ffa38b23341df2ed951726aef86f0/server/src/main.rs#L25",children:"line that connects to the change stream"})," in main:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let xls_subscription = feldera::subscribe_change_stream("spreadsheet_view", 4096);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When we look at the implementation of ",(0,r.jsx)(n.code,{children:"subscribe_change_stream"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub(crate) fn subscribe_change_stream(\n    view_name: &str,\n    capacity: usize,\n) -> Sender<Result<String, XlsError>> {\n    let (tx, _) = tokio::sync::broadcast::channel(capacity);\n    let subscribe = tx.clone();\n    let client = Client::new();\n    let url = format!(\n        "{}/v0/pipelines/{PIPELINE_NAME}/egress/{view_name}",\n        &*FELDERA_HOST\n    );\n    let view = String::from(view_name);\n\n    tokio::spawn(async move {\n        loop {\n            let response = client\n                .post(url.clone())\n                .bearer_auth(&*FELDERA_API_KEY)\n                .header("Content-Type", "application/json")\n                .query(&[\n                    ("format", "json"),\n                    ("backpressure", "false"),\n                    ("array", "false"),\n                ])\n                .send()\n                .await;\n\n            match response {\n                Ok(resp) if resp.status().is_success() => {\n                    let stream = resp\n                        .bytes_stream()\n                        .map_err(|e| io::Error::new(io::ErrorKind::Other, e));\n                    let reader = tokio_util::io::StreamReader::new(stream);\n                    let mut decoder = tokio_util::codec::FramedRead::new(\n                        reader,\n                        tokio_util::codec::LinesCodec::new(),\n                    );\n\n                    while let Some(line) = decoder.next().await {\n                        match line {\n                            Ok(line) => {\n                                match serde_json::from_str::<Record>(&line) {\n                                    Ok(record) => {\n                                        \'inner: for change in\n                                            record.json_data.unwrap_or_else(|| vec![]).iter().rev()\n                                        {\n                                            if let Change::Insert(value) = change {\n                                                let mut value_str = value.to_string();\n                                                value_str.push(\'\\n\');\n                                                if tx.send(Ok(value_str)).is_err() {\n                                                    break \'inner;\n                                                }\n                                            }\n                                        }\n                                    }\n                            // ... omitted error handling\n            }\n\n            warn!("Lost connection to change stream at {url}, wait 10 seconds before retrying to get changes again");\n            tokio::time::sleep(Duration::from_secs(10)).await;\n        }\n    });\n\n    subscribe\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"we see that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A new broadcast channel"})," is created, allowing multiple readers and a single writer to distribute changes internally in our server application."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We connect to the change stream using the ",(0,r.jsx)(n.a,{href:"/api/subscribe-to-view",children:"Feldera egress endpoint"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We read and parse changes from the resulting HTTP stream sent by Feldera. Changes appear as ndjson and have the following format"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{ sequence_number: 1, json_data: [\n    { insert: { id: 0, raw_value: 0, computed_value: 0 }},\n    { delete: { id: 0, raw_value: 42, computed_value: 42 }},\n    { delete: { id: 3, raw_value: '=A0+C0', computed_value: 42 }},\n    { insert: { id: 3, raw_value: '=A0+C0', computed_value: 1 }}\n]}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Only ",(0,r.jsx)(n.code,{children:"insert"})," records are passed to our broadcast channel, so active client subscriptions receive just the relevant updates (this is sufficient in our case because we only overwrite cells)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"editing-cells-post-apispreadsheets",children:["Editing Cells: ",(0,r.jsx)(n.code,{children:"POST /api/spreadsheets"})]}),"\n",(0,r.jsxs)(n.p,{children:["To let clients update cells, we add a POST endpoint that writes new cell content to ",(0,r.jsx)(n.code,{children:"spreadsheet_table"})," in Feldera. Compared to retrieving cells, this API ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/blob/5abfb3aedc1ffa38b23341df2ed951726aef86f0/server/src/spreadsheet.rs#L225",children:"is just a few lines of code"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub(crate) async fn post_handler(\n    headers: HeaderMap,\n    ConnectInfo(addr): ConnectInfo<SocketAddr>,\n    State(state): State<AppState>,\n    Json(update_request): Json<UpdateRequest>,\n) -> impl IntoResponse {\n    // Load balancer puts the client IP in the HTTP header\n    const CLIENT_IP_HEADER: &str = "Fly-Client-IP";\n    let client_ip = headers.get(CLIENT_IP_HEADER).map(|ip| {\n        String::from_utf8_lossy(ip.as_bytes()).chars().take(45).collect::<String>()\n    }).unwrap_or(addr.ip().to_string().chars().take(45).collect::<String>());\n\n    if state.api_limits.contains(&client_ip) {\n        return (\n            axum::http::StatusCode::INTERNAL_SERVER_ERROR,\n            Json(serde_json::json!({"error": "API limit exceeded"})),\n        );\n    }\n    if !UpdateRequest::ID_RANGE.contains(&update_request.id) {\n        return (\n            axum::http::StatusCode::BAD_REQUEST,\n            Json(serde_json::json!({"error": "Invalid cell ID"})),\n        );\n    }\n    let raw_value = update_request.raw_value.chars().take(64).collect::<String>();\n\n    let payload = UpdatePayload {\n        id: update_request.id,\n        raw_value,\n        background: update_request.background,\n        ip: client_ip,\n        ts: Utc::now().format("%Y-%m-%d %H:%M:%S%.3f").to_string(),\n    };\n\n    insert("spreadsheet_data", payload).await\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Here\u2019s what happens:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"We get the client\u2019s IP address."}),"\n",(0,r.jsxs)(n.li,{children:["We check if the IP is under rate limit. We haven't discussed rate limiting but it's actually quite simple to implement it thanks to writing it ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/blob/5abfb3aedc1ffa38b23341df2ed951726aef86f0/feldera/program.sql#L118",children:"as a Feldera view"})," based on the ",(0,r.jsx)(n.code,{children:"spreadsheet_data"})," table."]}),"\n",(0,r.jsx)(n.li,{children:"We sanitize the input and add a timestamp."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/blob/5abfb3aedc1ffa38b23341df2ed951726aef86f0/server/src/feldera.rs#L159",children:"insert"})," the data using a REST call to the ",(0,r.jsx)(n.a,{href:"/api/insert-data",children:"Feldera ingress endpoint"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"comments-on-hosting",children:"Comments on Hosting"}),"\n",(0,r.jsxs)(n.p,{children:["We deploy this application on ",(0,r.jsx)(n.a,{href:"https://fly.io",children:"fly.io"}),". Follow the instructions in the ",(0,r.jsx)(n.a,{href:"https://github.com/feldera/techdemo-spreadsheet/blob/main/README.md",children:"README"})," to host your own instance or run it locally. In principle, any hosting provider will work. However, for real-time Feldera applications, we generally recommend avoiding serverless platforms:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shared resources"})," \u2013 A dedicated instance can maintain a single connection to Feldera\u2019s changestream. In serverless environments, each request might open its own connection, increasing bandwidth consumption and pipeline load."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Long-lived connections"})," \u2013 This demo uses long-running HTTP connections. Serverless platforms often limit connection duration, making reconnect logic necessary and adding unnecessary complexity."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["In this article, we walked through how to expose spreadsheet data to multiple clients via a simple REST server, including the logic for handling ad-hoc queries, real-time change streams, and editing cells. By leveraging Rust, Axum, and Feldera\u2019s APIs, we can efficiently broadcast updates to any number of clients. In ",(0,r.jsx)(n.a,{href:"/use_cases/real_time_apps/part3",children:"the final part"})," of this series, we\u2019ll explore adding a browser-based UI, completing our billion-cell spreadsheet solution."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},11144:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/spreadsheet-architecture-parts-59cc4b6f1153fd4b409cb80b9a25a43a.svg"},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var t=s(96540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);