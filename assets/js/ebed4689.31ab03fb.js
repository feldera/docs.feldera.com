"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[4662],{28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var r=n(96540);const s={},t=r.createContext(s);function a(e){const i=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:i},e.children)}},46340:(e,i,n)=>{n.d(i,{A:()=>r});const r=n.p+"assets/images/object-graph-32f11e8500f5d86a66406d3f5d66b2c4.png"},50219:(e,i,n)=>{n.d(i,{A:()=>r});const r=n.p+"assets/images/fga-architecture-incremental-f29c81634e955ec7e730da5d7e042d67.png"},60652:(e,i,n)=>{n.d(i,{A:()=>r});const r=n.p+"assets/images/fga-architecture-e131f794c34e775598536e5194861606.png"},84945:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"use_cases/fine_grained_authorization/intro","title":"Use Case: Fine-Grained Authorization","description":"This use case demonstrates how to build a high-performance, real-time policy engine using Feldera.","source":"@site/docs/use_cases/fine_grained_authorization/intro.md","sourceDirName":"use_cases/fine_grained_authorization","slug":"/use_cases/fine_grained_authorization/intro","permalink":"/use_cases/fine_grained_authorization/intro","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Time Series Analysis with Feldera","permalink":"/tutorials/time-series"},"next":{"title":"Implementing a static FGA model","permalink":"/use_cases/fine_grained_authorization/static"}}');var s=n(74848),t=n(28453);const a={},o="Use Case: Fine-Grained Authorization",l={},c=[{value:"FGA basics",id:"fga-basics",level:2},{value:"Object graph",id:"object-graph",level:3},{value:"Example: shared file manager",id:"example-shared-file-manager",level:4},{value:"Rules",id:"rules",level:3},{value:"Example",id:"example",level:4},{value:"FGA system architecture",id:"fga-system-architecture",level:3},{value:"FGA as an incremental computation problem",id:"fga-as-an-incremental-computation-problem",level:2},{value:"FGA and recursion",id:"fga-and-recursion",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"use-case-fine-grained-authorization",children:"Use Case: Fine-Grained Authorization"})}),"\n",(0,s.jsxs)(i.p,{children:["This use case demonstrates how to build a high-performance, real-time ",(0,s.jsx)(i.strong,{children:"policy engine"})," using Feldera.\nA policy engine enforces access control ",(0,s.jsx)(i.strong,{children:"rules"})," that determine which actions users can perform on various\nresources, and under which conditions.\nWe focus on a family of access control models called ",(0,s.jsx)(i.strong,{children:"Fine-Grained-Authorization"})," (FGA) models, which were\nfirst popularized by Google's ",(0,s.jsx)(i.a,{href:"https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/",children:"Zanzibar"}),"\nsystem."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"We demonstrate how Feldera's best-in-class support for incremental computation and mutually recursive SQL queries\nenables users to implement complex authorization policies with only a few lines of SQL, and to\nhandle authorization queries efficiently and consistently at scale."})}),"\n",(0,s.jsx)(i.p,{children:"This guide is designed for the following audiences:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Application developers seeking to add an efficient authorization layer to their applications."}),"\nExample: You\u2019re building a collaborative wiki platform, and need a robust access control layer.\nBy defining a declarative access control policy as a set of rules, you can use Feldera to evaluate these rules across millions of\nobjects and thousands of users cost-effectively."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Policy engine developers looking to scale their compute layer."}),"\nExample: You\u2019re developing your own FGA engine, similar to ",(0,s.jsx)(i.a,{href:"https://openfga.dev/",children:"OpenFGA"}),", and need a query\nengine that can efficiently evaluate complex rule sets over large dynamic object graphs."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"In this guide, we will:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"#fga-basics",children:"Introduce the basics of FGA"})}),"\n",(0,s.jsxs)(i.li,{children:["Discuss how FGA benefits from ",(0,s.jsx)(i.a,{href:"#fga-as-an-incremental-computation-problem",children:"incremental computation"}),"\nand ",(0,s.jsx)(i.a,{href:"#fga-and-recursion",children:"mutually recursive SQL queries"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Build two types of FGA engines using Feldera:","\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/use_cases/fine_grained_authorization/static",children:"Static FGA Engine"}),": Implements a fixed set of access control rules,\nsuitable for enforcing a predefined authorization policy created by application developers."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/use_cases/fine_grained_authorization/dynamic",children:"Dynamic FGA Engine"}),": Supports a dynamically evolving set of rules,\nideal for configurable policies where both system objects and authorization rules can change at runtime."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"By the end of this guide, you will have a clear understanding of how to leverage Feldera to build scalable and\nefficient policy engines."}),"\n",(0,s.jsx)(i.h2,{id:"fga-basics",children:"FGA basics"}),"\n",(0,s.jsx)(i.h3,{id:"object-graph",children:"Object graph"}),"\n",(0,s.jsxs)(i.p,{children:["An FGA policy is defined over an ",(0,s.jsx)(i.strong,{children:"object graph"}),", where nodes represent system objects such as users,\ndocuments, bank accounts, shopping carts, etc. The edges in this graph capture the ",(0,s.jsx)(i.strong,{children:"relationships"}),"\nbetween these objects, such as ",(0,s.jsx)(i.code,{children:"parent"}),", ",(0,s.jsx)(i.code,{children:"owner"}),", ",(0,s.jsx)(i.code,{children:"member"}),", etc. The specific types of objects and relationships\nvary depending on the application\u2019s requirements, allowing developers to implement application-specific\nauthorization policies."]}),"\n",(0,s.jsx)(i.h4,{id:"example-shared-file-manager",children:"Example: shared file manager"}),"\n",(0,s.jsx)(i.p,{children:"We will use a simple shared file management service as a running example throughout this guide.\nThis application works with three types of objects:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Users"})," represent individual users of the service."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"User groups"})," group users with similar permissions."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Files and folders"}),". For simplicity, we model files and folders using a single object type. A folder\nis simply a file that has one or more children."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Objects are connected by the following relationships:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"member"})," - a relationship between a user and a group."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"parent"})," - a relationship between files that defines the folder hierarchy."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"editor"})," - a relationship between a group and a file that gives the group the permission to read or write the file."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"viewer"})," - a relationship between a group and a file that gives the group the permission to read the file."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["We use ",(0,s.jsx)(i.code,{children:"relationship(object1, object2)"})," notation for relationships, e.g., ",(0,s.jsx)(i.code,{children:"member(alice, engineering)"}),", ",(0,s.jsx)(i.code,{children:"parent(folder1, file1)"}),",\n",(0,s.jsx)(i.code,{children:"editor(admins, folder1)"}),", etc."]}),"\n",(0,s.jsxs)(i.p,{children:["Here is an example object graph that shows several users, groups, and files.  Note that objects can have\n",(0,s.jsx)(i.strong,{children:"attributes"}),", e.g., ",(0,s.jsx)(i.code,{children:"is_banned"}),"."]}),"\n",(0,s.jsx)("a",{id:"example-object-graph"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Object graph",src:n(46340).A+"",width:"2339",height:"1581"})}),"\n",(0,s.jsx)(i.h3,{id:"rules",children:"Rules"}),"\n",(0,s.jsxs)(i.p,{children:["An FGA policy consists of rules that derive new relationships from the object graph.  A rule consists\nof ",(0,s.jsx)(i.strong,{children:"prerequisites"})," that must hold for the rule to fire and the ",(0,s.jsx)(i.strong,{children:"derived clause"})," that holds if the prerequisites\nare satisfied. The language of valid rules depends on a specific FGA implementation. In this tutorial we\nconsider two most common types of rules:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Rules with one prerequisite:"}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"relationship1(object1, object2) and condition(object1, object2) -> relationship2(object1, object2)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["where ",(0,s.jsx)(i.code,{children:"condition"})," is an arbitrary predicate over atributes of ",(0,s.jsx)(i.code,{children:"object1"})," and ",(0,s.jsx)(i.code,{children:"object2"}),".  This rule states\nthat if there exists relationship ",(0,s.jsx)(i.code,{children:"relationship1"})," between ",(0,s.jsx)(i.code,{children:"object1"})," and ",(0,s.jsx)(i.code,{children:"object2"}),", which satisfy ",(0,s.jsx)(i.code,{children:"condition"}),",\nthen ",(0,s.jsx)(i.code,{children:"object1"})," and ",(0,s.jsx)(i.code,{children:"object2"})," are related by ",(0,s.jsx)(i.code,{children:"relationship2"}),"."]}),"\n",(0,s.jsxs)(i.ol,{start:"2",children:["\n",(0,s.jsx)(i.li,{children:"Rules with two prerequisites:"}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"relationship1(object1, object2) and relationship2(object2, object3) and condition(object1, object3) -> relationship3(object1, object3)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["More complex rules, e.g., rules with more than two prerequisites or rules with arbitrary combinations of ",(0,s.jsx)(i.code,{children:"and"})," and ",(0,s.jsx)(i.code,{children:"or"}),"\noperators, can be decomposed into these two basic types. Some FGA implementations allow negative prerequisites of the\nform ",(0,s.jsx)(i.code,{children:"not relationship1(object1, object2)"}),". Such rules can be expressed in Feldera, but we leave them out for simplicity."]}),"\n",(0,s.jsx)(i.h4,{id:"example",children:"Example"}),"\n",(0,s.jsx)(i.p,{children:"We define the following derived relationships in our file manager example:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"group-can-read(group, file)"})," - ",(0,s.jsx)(i.code,{children:"group"})," is allowed to read ",(0,s.jsx)(i.code,{children:"file"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"group-can-write(group, file)"})," - ",(0,s.jsx)(i.code,{children:"group"})," is allowed to write ",(0,s.jsx)(i.code,{children:"file"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"user-can-read(user, file)"})," - ",(0,s.jsx)(i.code,{children:"user"})," is allowed to read ",(0,s.jsx)(i.code,{children:"file"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"user-can-write(user, file)"})," - ",(0,s.jsx)(i.code,{children:"user"})," is allowed to write ",(0,s.jsx)(i.code,{children:"file"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"These relationships are governed by the following rules:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 1:"})," ",(0,s.jsx)(i.code,{children:"editor(group, file) -> group-can-write(group, file)"})," - if a group is an editor of a file, it can write this file."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 2:"})," ",(0,s.jsx)(i.code,{children:"group-can-write(group, file1) and parent(file1, file2) -> group-can-write(group, file2)"})," - if a group can write\na file, then it can write any of its children."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 3:"})," ",(0,s.jsx)(i.code,{children:"viewer(group, file) -> group-can-read(group, file)"})," - if a group is a viewer of a file, then it can read this file."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 4:"})," ",(0,s.jsx)(i.code,{children:"group-can-write(group, file) -> group-can-read(group, file)"})," - the write permission to a file implies the read\npermission to the same file."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 5:"})," ",(0,s.jsx)(i.code,{children:"group-can-read(group, file1) and parent(file1, file2) -> group-can-read(group, file2)"})," - if a group can read a file,\nthen it can read any of its children."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 6:"})," ",(0,s.jsx)(i.code,{children:"member(user, group) and group-can-write(group, file) and (not user.is_banned) -> user-can-write(user, file)"})," - if a user is a member\nof a group that can write a file and the user is not banned, then the user can write the file."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rule 7:"})," ",(0,s.jsx)(i.code,{children:"member(user, group) and group-can-read(group, file) and (not user.is_banned) -> user-can-read(user, file)"})," - if a user is a member\nof a group that can read a file and the user is not banned, then the user can read the file."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["Given these rules, we can derive the following access permissions to file ",(0,s.jsx)(i.code,{children:"f1"})," from the example object graph above:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"group-can-write(engineering, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"group-can-write(it, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"group-can-read(engineering, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"group-can-read(it, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"group-can-read(accounting, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"user-can-write(emily, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"user-can-read(emily, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"user-can-write(irene, f1)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"user-can-read(irene, f1)"})}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"fga-system-architecture",children:"FGA system architecture"}),"\n",(0,s.jsx)(i.p,{children:"At runtime, the FGA engine is invoked to validate every API request from a client, ensuring that the user making\nthe request has the required permissions. This validation is performed by evaluating the FGA rules against the\nobject graph. The graph, maintained by the application, evolves in real-time as objects and relationships are added,\nremoved, and modified."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"FGA system architecture",src:n(60652).A+"",width:"1859",height:"763"})}),"\n",(0,s.jsx)(i.h2,{id:"fga-as-an-incremental-computation-problem",children:"FGA as an incremental computation problem"}),"\n",(0,s.jsx)(i.p,{children:"Building an efficient FGA engine is a challenging task.\nIn large-scale applications, the engine may need to process thousands of authorization requests\nper second, over a massive object graph. Each request can require an expensive graph traversal.\nThe dynamic nature of the graph makes it hard to cache authorization decisions without compromising consistency."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Incremental computation offers an elegant solution to this challenge."})," Instead of evaluating authorization\ndecisions from scratch for every request, the idea is to precompute all authorization decisions in advance\nand store them in a key-value store, reducing runtime authorization checks to simple, efficient lookups.\nAs the object graph evolves, incremental computation ensures that only rule derivations affected by the\nchange are updated, avoiding full recomputation.  ",(0,s.jsx)(i.strong,{children:"An efficient incremental query engine like Feldera can\nupdate the computation within milliseconds after the object graph changes even for very large graphs,\nmaking sure that runtime authorization checks reflect the current state of the system."})]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"FGA architecture using an incremental policy engine",src:n(50219).A+"",width:"1861",height:"989"})}),"\n",(0,s.jsxs)(i.p,{children:["Precomputing all authorization decisions is often impractical in real-world scenarios, because there can be too\nmany of them. In a system with 1 million users and 1 million public objects, the policy engine could derive\n10^12 ",(0,s.jsx)(i.code,{children:"user-can-read"})," relationships.  We thefore need to optimize the computation to prevent such a blow-up.\nWe will discuss some relevant optimizations ",(0,s.jsx)(i.a,{href:"/use_cases/fine_grained_authorization/dynamic#optimizations",children:"below"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"fga-and-recursion",children:"FGA and recursion"}),"\n",(0,s.jsx)(i.p,{children:"The FGA engine must perform iterative graph traversal, where, at each step, it evaluates FGA\nrules to derive new relationships based on previously discovered ones.  In the file manager\nexample, the engine iteratively traverses the folder hierarchy to determine all files that\nare readable or writable by each user group."}),"\n",(0,s.jsx)(i.p,{children:"Expressing such iterative computations in standard SQL is not possible without support for recursive\nqueries. While many modern SQL dialects offer recursive CTEs, their capabilities are limited. Most\nnotably, they do not support multiple mutually recursive views, which are essential for evaluating more\ncomplex authorization rules."}),"\n",(0,s.jsx)(i.p,{children:"An incremental FGA engine must go a step further by updating recursive computations dynamically as\nthe object graph changes, placing the problem far beyond the capabilities of most query engines."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsxs)(i.strong,{children:["Feldera addresses these challenges by offering support for incremental evaluation of arbitrary SQL\nprograms, including programs with ",(0,s.jsx)(i.a,{href:"/sql/recursion",children:"mutually recursive views"}),"."]}),"\nIn the following sections we will see how this unique capability allows it to handle complex, iterative\ncomputations efficiently while keeping up with real-time changes to the object graph."]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);