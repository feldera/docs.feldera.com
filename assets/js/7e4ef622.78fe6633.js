"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[9442],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>a});var r=s(96540);const i={},t=r.createContext(i);function d(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(t.Provider,{value:n},e.children)}},94556:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"sql/aggregates","title":"Aggregate Operations","description":"Standard aggregate operations","source":"@site/docs/sql/aggregates.md","sourceDirName":"sql","slug":"/sql/aggregates","permalink":"/sql/aggregates","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Data Types","permalink":"/sql/types"},"next":{"title":"Array Operations","permalink":"/sql/array"}}');var i=s(74848),t=s(28453);const d={},a="Aggregate Operations",o={},l=[{value:"Standard aggregate operations",id:"standard-aggregate-operations",level:2},{value:"Window aggregate functions",id:"window-aggregate-functions",level:2},{value:"Pivots",id:"pivots",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Example",id:"example",level:3},{value:"On the efficiency of aggregates computations",id:"on-the-efficiency-of-aggregates-computations",level:2},{value:"Window aggregates",id:"window-aggregates",level:3},{value:"<code>DISTINCT</code>",id:"distinct",level:3},{value:"Linear aggregation functions",id:"linear-aggregation-functions",level:3},{value:"Non-linear aggregation functions",id:"non-linear-aggregation-functions",level:3},{value:"Efficient aggregation functions",id:"efficient-aggregation-functions",level:3},{value:"Append only collections",id:"append-only-collections",level:3},{value:"Expensive aggregation functions",id:"expensive-aggregation-functions",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"aggregate-operations",children:"Aggregate Operations"})}),"\n",(0,i.jsx)(n.h2,{id:"standard-aggregate-operations",children:"Standard aggregate operations"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"SELECT"})," expression in the ",(0,i.jsx)(n.a,{href:"/sql/grammar",children:"SQL grammar"})," can contain one\nor more aggregation functions.  Aggregate functions are specified\nusing the following grammar:"]}),"\n",(0,i.jsx)("a",{id:"filter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"aggregateCall:\n      agg '(' [ ALL | DISTINCT ] value [, value ]* ')'\n      [ WITHIN DISTINCT '(' expression [, expression ]* ')' ]\n      [ FILTER '(' WHERE condition ')' ]\n  |   agg '(' '*' ')' [ FILTER (WHERE condition) ]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["where ",(0,i.jsx)(n.code,{children:"agg"})," is one of the operators in the following table."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"FILTER"})," is present, the aggregate function only considers rows for\nwhich condition evaluates to ",(0,i.jsx)(n.code,{children:"TRUE"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"DISTINCT"})," is present, duplicate argument values are eliminated\nbefore being passed to the aggregate function."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"WITHIN DISTINCT"})," is present, argument values are made distinct\nwithin each value of specified keys before being passed to the\naggregate function."]}),"\n",(0,i.jsxs)(n.p,{children:["Most aggregation functions produce results of the same type as the\ninput data, but compute using higher precision intermediate data\ntypes; aggregation of ",(0,i.jsx)(n.code,{children:"UNSIGNED"})," values uses signed types for\nintermediate results.  If you expect the result to require a higher\nprecision than the aggregated data type, we recommend converting the\ndata to a wider data type, e.g.: instead of ",(0,i.jsx)(n.code,{children:"SELECT SUM(col)"}),", you\nshould write ",(0,i.jsx)(n.code,{children:"SELECT SUM(CAST col AS BIGINT)"}),"."]}),"\n",(0,i.jsxs)("table",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aggregate"}),(0,i.jsx)("th",{children:"Description"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"array_agg"}),(0,i.jsx)("code",{children:"ARRAY_AGG([ ALL | DISTINCT ] value [ RESPECT NULLS | IGNORE NULLS ] [ORDER BY orderItem [, orderItem]*] )"})]}),(0,i.jsxs)("td",{children:["Gathers all values in an array.  If ",(0,i.jsx)(n.code,{children:"ORDER BY"})," is not present, the order of the values in the array is unspecified (but it is deterministic)."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"avg"}),(0,i.jsx)("code",{children:"AVG( [ ALL | DISTINCT ] numeric)"})]}),(0,i.jsx)("td",{children:"Returns the average (arithmetic mean) of numeric across all input values"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"arg_max"}),(0,i.jsx)("code",{children:"ARG_MAX(value, compared)"})]}),(0,i.jsxs)("td",{children:["Returns a ",(0,i.jsx)("code",{children:"value"})," for one of the rows containing the maximum value of ",(0,i.jsx)("code",{children:"compared"})," in the group.\nThe rule for selecting the value is not specified if there are multiple rows with the same maximum value."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"arg_min"}),(0,i.jsx)("code",{children:"ARG_MIN(value, compared)"})]}),(0,i.jsxs)("td",{children:["Returns a  ",(0,i.jsx)("code",{children:"value"})," for one of the rows containing the minimum value of ",(0,i.jsx)("code",{children:"compared"})," in the group.\nThis rule for selecting the value is not specified if there are multiple rows with the same minimum value."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"bit_and"}),(0,i.jsx)("code",{children:"BIT_AND( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the bitwise AND of all non-null input values, or null if none; integer and binary types are supported"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"bit_or"}),(0,i.jsx)("code",{children:"BIT_OR( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the bitwise OR of all non-null input values, or null if none; integer and binary types are supported"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"bit_xor"}),(0,i.jsx)("code",{children:"BIT_XOR( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the bitwise XOR of all non-null input values, or null if none; integer and binary types are supported"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"countstar"}),(0,i.jsx)("code",{children:"COUNT(*)"})]}),(0,i.jsx)("td",{children:"Returns the number of input rows"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"count"}),(0,i.jsx)("code",{children:"COUNT( [ ALL | DISTINCT ] value [, value ]*)"})]}),(0,i.jsxs)("td",{children:["Returns the number of input rows for which value is not null.  If the argument contains multiple expressions, it counts only expressions where ",(0,i.jsx)(n.em,{children:"all"})," fields are non-null."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"countif"}),(0,i.jsx)("code",{children:"COUNTIF( boolean )"})]}),(0,i.jsx)("td",{children:"Returns the number of input rows for which the condition is true."})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"every"}),(0,i.jsx)("code",{children:"EVERY(condition)"})]}),(0,i.jsxs)("td",{children:["Returns ",(0,i.jsx)("code",{children:"TRUE"})," if all of the values of condition are ",(0,i.jsx)("code",{children:"TRUE"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"logical_and"}),(0,i.jsx)("code",{children:"LOGICAL_AND"})," or ",(0,i.jsx)("code",{children:"BOOL_AND"})]}),(0,i.jsxs)("td",{children:["Same as ",(0,i.jsx)("code",{children:"EVERY"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"logical_or"}),(0,i.jsx)("code",{children:"LOGICAL_OR"})," or ",(0,i.jsx)("code",{children:"BOOL_OR"})]}),(0,i.jsxs)("td",{children:["Same as ",(0,i.jsx)("code",{children:"SOME"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"max"}),(0,i.jsx)("code",{children:"MAX( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the maximum value of value across all input values"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"min"}),(0,i.jsx)("code",{children:"MIN( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the minimum value of value across all input values"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"some"}),(0,i.jsx)("code",{children:"SOME(condition)"})]}),(0,i.jsxs)("td",{children:["Returns ",(0,i.jsx)("code",{children:"TRUE"})," if one or more of the values of condition is ",(0,i.jsx)("code",{children:"TRUE"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"sum"}),(0,i.jsx)("code",{children:"SUM( [ ALL | DISTINCT ] numeric)"})]}),(0,i.jsx)("td",{children:"Returns the sum of numeric across all input values"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"stddev"}),(0,i.jsx)("code",{children:"STDDEV( [ ALL | DISTINCT ] value)"})]}),(0,i.jsxs)("td",{children:["Synonym for ",(0,i.jsx)("code",{children:"STDDEV_SAMP"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"stddev_pop"}),(0,i.jsx)("code",{children:"STDDEV_POP( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the population standard deviation of numeric across all input values"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"stddev_samp"}),(0,i.jsx)("code",{children:"STDDEV_SAMP( [ ALL | DISTINCT ] value)"})]}),(0,i.jsx)("td",{children:"Returns the sample standard deviation of numeric across all input values"})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Comparisons like ",(0,i.jsx)(n.code,{children:"MAX"}),", ",(0,i.jsx)(n.code,{children:"MIN"}),", ",(0,i.jsx)(n.code,{children:"ARG_MIN"}),", and ",(0,i.jsx)(n.code,{children:"ARG_MAX"})," are defined\nfor all data types, and they use the standard ",(0,i.jsx)(n.a,{href:"/sql/comparisons",children:"comparison\noperations"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"FILTER"})," is specified, then only the input rows for which the\nfilter_clause evaluates to true are fed to the aggregate function;\nother rows are discarded. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT\n    count(*) AS unfiltered,\n    count(*) FILTER (WHERE i < 5) AS filtered\nFROM TABLE\n"})}),"\n",(0,i.jsx)(n.p,{children:"In addition, the following two constructors act as aggregates:"}),"\n",(0,i.jsx)("a",{id:"array"}),"\n",(0,i.jsx)("a",{id:"map"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Constructor"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ARRAY(sub-query)"})}),(0,i.jsx)(n.td,{children:"Creates an array from the result of a sub-query. If the subquery returns a tuple, the array will be an array of tuples."}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"SELECT ARRAY(SELECT empno FROM emp)"})," or ",(0,i.jsx)(n.code,{children:"SELECT ARRAY(SELECT empno, dept FROM emp)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"MAP(sub-query)"})}),(0,i.jsx)(n.td,{children:"Creates a map from the result of a sub-query that returns two columns. If multiple entries have the same key, the largest value wins."}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SELECT MAP(SELECT empno, deptno FROM emp)"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"window-aggregate-functions",children:"Window aggregate functions"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"SELECT"})," expression in the ",(0,i.jsx)(n.a,{href:"/sql/grammar",children:"SQL grammar"})," can also\ncontain a ",(0,i.jsx)(n.a,{href:"/sql/grammar#window-aggregates",children:"window aggregate function"}),".\nThe following window aggregate functions are supported:"]}),"\n",(0,i.jsxs)("table",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aggregate"}),(0,i.jsx)("th",{children:"Description"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"window-avg"}),"AVG(numeric)"]}),(0,i.jsx)("td",{children:"Returns the average (arithmetic mean) of numeric across all values in window"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"window-count"}),(0,i.jsx)("code",{children:"COUNT("}),"value [, value ]*",(0,i.jsx)("code",{children:")"})]}),(0,i.jsx)("td",{children:"Returns the number of rows in window for which value is not null"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"window-countstar"}),(0,i.jsx)("code",{children:"COUNT(*)"})]}),(0,i.jsx)("td",{children:"Returns the number of rows in window"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"dense_rank"}),(0,i.jsx)("code",{children:"DENSE_RANK()"})]}),(0,i.jsxs)("td",{children:["Returns the rank of the current row without gaps.  ",(0,i.jsx)(n.code,{children:"DENSE_RANK"})," is currently only supported if\nthe window is used to compute a TopK aggregate."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"lag"}),(0,i.jsx)("code",{children:"LAG("}),(0,i.jsx)("em",{children:"expression"}),", [",(0,i.jsx)("em",{children:"offset"}),", [ ",(0,i.jsx)("em",{children:"default"})," ] ]",(0,i.jsx)("code",{children:")"})]}),(0,i.jsxs)("td",{children:["Returns ",(0,i.jsx)("em",{children:"expression"})," evaluated at the row that is ",(0,i.jsx)("em",{children:"offset"})," rows before the current row\nwithin the partition; if there is no such row, instead returns ",(0,i.jsx)("em",{children:"default"}),".\nBoth ",(0,i.jsx)("em",{children:"offset"})," and ",(0,i.jsx)("em",{children:"default"})," are evaluated with respect to the current row.\nIf omitted, ",(0,i.jsx)("em",{children:"offset"})," defaults to 1 and ",(0,i.jsx)("em",{children:"default"})," to ",(0,i.jsx)("code",{children:"NULL"}),"."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"lead"}),(0,i.jsx)("code",{children:"LEAD("}),(0,i.jsx)("em",{children:"expression"}),", [",(0,i.jsx)("em",{children:"offset"}),", [ ",(0,i.jsx)("em",{children:"default"})," ] ]",(0,i.jsx)("code",{children:")"})]}),(0,i.jsxs)("td",{children:["Returns ",(0,i.jsx)("em",{children:"expression"})," evaluated at the row that is ",(0,i.jsx)("em",{children:"offset"})," rows after the current row\nwithin the partition; if there is no such row, instead returns ",(0,i.jsx)("em",{children:"default"}),".\nBoth ",(0,i.jsx)("em",{children:"offset"})," and ",(0,i.jsx)("em",{children:"default"})," are evaluated with respect to the current row.\nIf omitted, ",(0,i.jsx)("em",{children:"offset"})," defaults to 1 and ",(0,i.jsx)("em",{children:"default"})," to ",(0,i.jsx)("code",{children:"NULL"}),"."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"window-max"}),(0,i.jsx)("code",{children:"MAX"}),"(",(0,i.jsx)("em",{children:"expression"}),")"]}),(0,i.jsxs)("td",{children:["Returns the maximum value of ",(0,i.jsx)("em",{children:"expression"})," across all values in window"]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"window-min"}),(0,i.jsx)("code",{children:"MIN"}),"(",(0,i.jsx)("em",{children:"expression"}),")"]}),(0,i.jsxs)("td",{children:["Returns the minimum value of ",(0,i.jsx)("em",{children:"expression"})," across all values in window"]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"rank"}),(0,i.jsx)("code",{children:"RANK()"})]}),(0,i.jsxs)("td",{children:["Returns the rank of the current row with gaps.  ",(0,i.jsx)(n.code,{children:"DENSE_RANK"})," is currently only supported if\nthe window is used to compute a TopK aggregate."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"row_number"}),(0,i.jsx)("code",{children:"ROW_NUMBER()"})]}),(0,i.jsxs)("td",{children:["Returns the number of the current row within its partition, counting from 1.\n",(0,i.jsx)(n.code,{children:"ROW_NUMBER"})," is currently only supported if the window is used to compute a TopK aggregate."]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{id:"window-sum"}),(0,i.jsx)("code",{children:"SUM"}),"(",(0,i.jsx)("em",{children:"numeric"}),")"]}),(0,i.jsxs)("td",{children:["Returns the sum of ",(0,i.jsx)("em",{children:"numeric"})," across all values in window"]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Currently, the window aggregate functions ",(0,i.jsx)(n.code,{children:"RANK"}),", ",(0,i.jsx)(n.code,{children:"DENSE_RANK"})," and\n",(0,i.jsx)(n.code,{children:"ROW_NUMBER"})," are only supported if the compiler detects that they are\nbeing used to implement a TopK pattern.  This pattern is expressed in\nSQL with the following structure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM (\n   SELECT empno,\n          row_number() OVER (ORDER BY empno) rn\n   FROM empsalary) emp\nWHERE rn < 3\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pivots",children:"Pivots"}),"\n",(0,i.jsxs)(n.p,{children:["The SQL ",(0,i.jsx)(n.code,{children:"PIVOT"})," operation can be used to turn rows into columns.  It\nusually replaces a ",(0,i.jsx)(n.code,{children:"GROUP-BY"})," operation when the group keys are known\nin advance.  Instead of producing one row for each group, ",(0,i.jsx)(n.code,{children:"PIVOT"})," can\nproduce one ",(0,i.jsx)(n.em,{children:"column"})," for each group."]}),"\n",(0,i.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"PIVOT ( { aggregate_expression [ AS aggregate_expression_alias ] } [ , ... ]\n    FOR column_with_data IN ( column_list ) )\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["aggregate_expression\nSpecifies an aggregate expression (",(0,i.jsx)(n.code,{children:"SUM"}),", ",(0,i.jsx)(n.code,{children:"COUNT(DISTINCT )"}),", etc.)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"aggregate_expression_alias\nSpecifies a column name for the aggregate expression."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"column_with_data\nA column that produces all the values that will become new\ncolumn names."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"column_list\nColumns that show the pivoted data."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE FURNITURE (\n   type VARCHAR,\n   year INTEGER,\n   count INTEGER\n);\nINSERT INTO FURNITURE VALUES\n  ('chair', 2020, 4),\n  ('table', 2021, 3),\n  ('chair', 2021, 4),\n  ('desk', 2023, 1),\n  ('table', 2023, 2);\n\nSELECT year, type, SUM(count) FROM FURNITURE GROUP BY year,type;\nyear | type  | sum\n-------------------\n2020 | chair | 4\n2021 | table | 3\n2021 | chair | 4\n2023 | desk  | 1\n2023 | table | 2\n(5 rows)\n\nSELECT * FROM FURNITURE\nPIVOT (\n    SUM(count) AS ct\n    FOR type IN ('desk' AS desks, 'table' AS tables, 'chair' as chairs)\n);\n\nyear | desks | tables | chairs\n------------------------------\n2020 |       |        |    4\n2021 |       |     3  |    4\n2023 |     1 |     2  |\n(3 rows)\n"})}),"\n",(0,i.jsxs)(n.p,{children:['Notice how the same information is presented in a tabular form where\nwe have a column for each type of object.  PIVOTs require all the\npossible "type"s to be specified when the query is written.  Notice\nthat if we add an additional type, the ',(0,i.jsx)(n.code,{children:"GROUP BY"})," query will produce a\ncorrect result, while the ",(0,i.jsx)(n.code,{children:"PIVOT"})," query will produce the same result."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"INSERT INTO FURNITURE VALUES ('bed', 2020, 5);\nSELECT year, type, SUM(count) FROM FURNITURE GROUP BY year,type;\nyear | type  | sum\n-------------------\n2020 | chair | 4\n2020 | bed   | 5\n2021 | table | 3\n2021 | chair | 4\n2023 | desk  | 1\n2023 | table | 2\n(6 rows)\n\nSELECT * FROM FURNITURE\nPIVOT (\n    SUM(count) AS ct\n    FOR type IN ('desk' AS desks, 'table' AS tables, 'chair' as chairs)\n);\n\nyear | desks | tables | chairs\n------------------------------\n2020 |       |        |    4\n2021 |       |     3  |    4\n2023 |     1 |     2  |\n(3 rows)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"on-the-efficiency-of-aggregates-computations",children:"On the efficiency of aggregates computations"}),"\n",(0,i.jsxs)(n.p,{children:["Computing aggregates incrementally is very different from standard\naggregate evaluation in typical SQL engines.  Some of the observations\nin this section pertain to the current state of the implementation,\nand may change in the future as the implementation improves.  Let us\nassume that the size of the collection aggregated is N, the size of\nthe current change is D, the total number of groups is G, and the\n",(0,i.jsx)(n.em,{children:"total number of elements"})," in the modified groups is M.  Always N > D,\nand N > M > G."]}),"\n",(0,i.jsx)(n.p,{children:"All aggregation functions need to store the result of the aggregation\ninternally -- one value per group, so their space overhead is at least\nO(G), but it may be more."}),"\n",(0,i.jsx)(n.h3,{id:"window-aggregates",children:"Window aggregates"}),"\n",(0,i.jsxs)(n.p,{children:["Window aggregates (e.g., using ",(0,i.jsx)(n.code,{children:"OVER"}),") are incrementally evaluated for\neach window which changes when a new change is ingested, but are\notherwise insensitive to the choice of aggregation function or the\ndata type."]}),"\n",(0,i.jsx)(n.p,{children:"Window aggregation functions need to store the entire collection that\nis being aggregated -- the space overhead is thus O(N).  The work\nperformed is expected to be O(D log N)."}),"\n",(0,i.jsx)(n.h3,{id:"distinct",children:(0,i.jsx)(n.code,{children:"DISTINCT"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"DISTINCT"})," operation can be used with an aggregation or in a\n",(0,i.jsx)(n.code,{children:"SELECT"})," statement; in both cases the cost of ",(0,i.jsx)(n.code,{children:"DISTINCT"})," is O(N) in\nspace and O(D log M) in work."]}),"\n",(0,i.jsx)(n.h3,{id:"linear-aggregation-functions",children:"Linear aggregation functions"}),"\n",(0,i.jsx)(n.p,{children:"A linear aggregation function can compute the change in an aggregate\nonly by looking at the new change -- irrespective of the previous\nvalue of the aggregate.  Linear aggregation functions comprise:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"COUNT"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SUM"})," for all integer, unsigned, and ",(0,i.jsx)(n.code,{children:"DECIMAL"})," data types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AVG"})," for all integer, unsigned, and ",(0,i.jsx)(n.code,{children:"DECIMAL"})," data types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"STDDEV"}),", ",(0,i.jsx)(n.code,{children:"STDDEV_SAMP"}),", ",(0,i.jsx)(n.code,{children:"STDDEV_POP"})," for all integer, unsigned, and\n",(0,i.jsx)(n.code,{children:"DECIMAL"})," data types (note: our current implementation of ",(0,i.jsx)(n.code,{children:"STDDEV"}),"\nis not as efficient as possible)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The space overhead for linear functions is O(G).  The work performed\nfor each change is O(D)."}),"\n",(0,i.jsx)(n.h3,{id:"non-linear-aggregation-functions",children:"Non-linear aggregation functions"}),"\n",(0,i.jsxs)(n.p,{children:["Using a ",(0,i.jsx)(n.code,{children:"FILTER"})," with an aggregation function in general makes it\nnon-linear, so using ",(0,i.jsx)(n.code,{children:"WHERE"})," is preferred to using ",(0,i.jsx)(n.code,{children:"FILTER"}),".\nSometimes the compiler can automatically decompose such an aggregate\ninto a filter followed by a standard aggregate."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"COUNTIF"})," is the same as ",(0,i.jsx)(n.code,{children:"COUNT ... FILTER"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The following functions are non-linear, and require O(N) space and\nO(M) work:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"BIT_OR"}),", ",(0,i.jsx)(n.code,{children:"BIT_XOR"}),", ",(0,i.jsx)(n.code,{children:"BIT_AND"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Any of the functions listed above as linear are actually non-linear\nwhen applied to ",(0,i.jsx)(n.code,{children:"DOUBLE"})," or ",(0,i.jsx)(n.code,{children:"FLOAT"})," values."]}),"\n",(0,i.jsx)(n.h3,{id:"efficient-aggregation-functions",children:"Efficient aggregation functions"}),"\n",(0,i.jsx)(n.p,{children:"The following aggregation functions require O(N) space but perform\nonly O(D log M) work."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MAX"}),", ",(0,i.jsx)(n.code,{children:"MIN"}),", ",(0,i.jsx)(n.code,{children:"ARG_MAX"}),", ",(0,i.jsx)(n.code,{children:"ARG_MIN"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"LOGICAL_AND"}),", ",(0,i.jsx)(n.code,{children:"BOOL_AND"}),", ",(0,i.jsx)(n.code,{children:"LOGICAL_OR"}),", ",(0,i.jsx)(n.code,{children:"BOOL_OR"}),", ",(0,i.jsx)(n.code,{children:"EVERY"}),", ",(0,i.jsx)(n.code,{children:"SOME"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"append-only-collections",children:"Append only collections"}),"\n",(0,i.jsxs)(n.p,{children:["Some aggregates can have more efficient implementations when applied\nto append-only collections.  A table property can be used to indicate\nwhether a table is ",(0,i.jsx)(n.a,{href:"/sql/streaming#append-only-tables",children:"append-only"}),".\nOperations such as SELECT, WHERE, JOIN, UNNEST applied to append-only\ncollections produce append-only results.  Note the results of\naggregation are essentially never append-only."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MAX"}),", ",(0,i.jsx)(n.code,{children:"MIN"}),", ",(0,i.jsx)(n.code,{children:"ARG_MAX"}),", ",(0,i.jsx)(n.code,{children:"ARG_MIN"})," are significantly more efficient\nfor append-only collections.  They require O(G) space and O(D) work."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"expensive-aggregation-functions",children:"Expensive aggregation functions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ARRAY_AGG"})," is very expensive, both in terms of space and time.\nSpace cost is O(N), while work performed is proportional O(M)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The two constructors ",(0,i.jsx)(n.code,{children:"ARRAY"})," and ",(0,i.jsx)(n.code,{children:"MAP"})," with subqueries as arguments\nhave similar costs."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);