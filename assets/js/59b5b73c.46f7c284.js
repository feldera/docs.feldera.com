"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[7649],{884:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"sql/casts","title":"Casts and Data Type Conversions","description":"SQL expressions can mix data of different types in the same","source":"@site/docs/sql/casts.md","sourceDirName":"sql","slug":"/sql/casts","permalink":"/sql/casts","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Boolean Operations","permalink":"/sql/boolean"},"next":{"title":"Comparison Operations","permalink":"/sql/comparisons"}}');var r=s(74848),a=s(28453);const o={},i="Casts and Data Type Conversions",c={},l=[{value:"Safe casts",id:"safe-casts",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"casts-and-data-type-conversions",children:"Casts and Data Type Conversions"})}),"\n",(0,r.jsxs)(n.p,{children:["SQL expressions can mix data of different types in the same\nexpression.  Most operations, however, require operands to have either\nthe same type, or specific type combinations.  The SQL compiler will\nin this case insert implicit type conversion operations, also called\n",(0,r.jsx)(n.em,{children:"casts"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"An explicit cast can be specified in two ways:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["using the ",(0,r.jsx)(n.code,{children:"CAST"})," operator: ",(0,r.jsx)("code",{children:"CAST(value AS type)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)("a",{id:"coloncolon"}),"using an infix operator ",(0,r.jsx)("code",{children:"::"})," from Postgres:\n",(0,r.jsx)("code",{children:"value :: type"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The rules for implicit casts are complex; we ",(0,r.jsx)(n.a,{href:"https://calcite.apache.org/docs/reference.html#conversion-contexts-and-strategies",children:"inherit these\nrules"}),"\nfrom Calcite."]}),"\n",(0,r.jsx)(n.p,{children:'In general SQL casts may discard low order digits but never high order\ndigits.  A cast form a wide to a narrow datatype which cannot\nrepresent the value in the target type will generate a runtime error.\nNote however that casts to floating point values never generate\nruntime errors, since they use "infinity" values to represent out of\nrange values.'}),"\n",(0,r.jsxs)(n.p,{children:["Conversions from decimal and floating point types to integer types\nalways truncate the decimal digits (round towards zero).  For example,\n",(0,r.jsx)(n.code,{children:"CAST(2.9 AS INTEGER)"})," returns 2, while ",(0,r.jsx)(n.code,{children:"CAST(-2.9 AS INTEGER)"}),"\nreturns -2."]}),"\n",(0,r.jsx)(n.p,{children:"Casts of strings to numeric types produce a runtime error when the\nstring cannot be interpreted as a number."}),"\n",(0,r.jsxs)(n.p,{children:["Casts of strings to ",(0,r.jsx)(n.code,{children:"DATE"}),", ",(0,r.jsx)(n.code,{children:"TIME"}),", ",(0,r.jsx)(n.code,{children:"TIMESTAMP"})," produce the result\n",(0,r.jsx)(n.code,{children:"NULL"})," when the string does not have the correct format."]}),"\n",(0,r.jsxs)(n.p,{children:["Casting a ",(0,r.jsx)(n.code,{children:"NULL"})," value to any type produces a ",(0,r.jsx)(n.code,{children:"NULL"})," result."]}),"\n",(0,r.jsxs)(n.p,{children:["A value of type ",(0,r.jsx)(n.code,{children:"VARIANT"})," can be cast to any type and will produce a\nnullable result; this kind of cast will never fail at runtime."]}),"\n",(0,r.jsxs)(n.p,{children:["A value of any type can be cast to a ",(0,r.jsx)(n.code,{children:"VARIANT"})," type."]}),"\n",(0,r.jsxs)(n.p,{children:["A cast to a ",(0,r.jsx)(n.code,{children:"ROW"})," type is only allowed for compatible ",(0,r.jsx)(n.code,{children:"ROW"})," types, or\nfor ",(0,r.jsx)(n.code,{children:"VARIANT"})," types.  Such a cast will cast recursively each field of\nthe source value to the corresponding type of the destination field.\nFor example, the following statment is legal:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT cast(row(1, 2) as row(a integer, b tinyint)) as r;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"safe-casts",children:"Safe casts"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"SAFE_CAST"})," function has the same syntax as ",(0,r.jsx)(n.code,{children:"CAST"}),".  ",(0,r.jsx)(n.code,{children:"SAFE_CAST"}),"\nproduces the same result as ",(0,r.jsx)(n.code,{children:"CAST"})," for all legal inputs.  The main\ndifference is that ",(0,r.jsx)(n.code,{children:"SAFE_CAST"})," never produces a runtime error,\nproducing a ",(0,r.jsx)(n.code,{children:"NULL"})," value when a conversion is illegal."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var t=s(96540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);