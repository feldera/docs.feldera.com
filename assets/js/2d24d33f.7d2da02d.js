"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8887],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(96540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},31087:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"use_cases/batch/part4","title":"Part 4. Sending Output to Multiple Destinations","description":"Once data has been processed, the next step is to deliver it to downstream","source":"@site/docs/use_cases/batch/part4.md","sourceDirName":"use_cases/batch","slug":"/use_cases/batch/part4","permalink":"/use_cases/batch/part4","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Part 3. Working with Historical and Real Time Data","permalink":"/use_cases/batch/part3"},"next":{"title":"Real-time Fraud Detection","permalink":"/use_cases/fraud_detection/"}}');var i=t(74848),r=t(28453);const a={},l="Part 4. Sending Output to Multiple Destinations",d={},c=[{value:"PostgreSQL: Real-Time Materialized Views",id:"postgresql-real-time-materialized-views",level:2},{value:"Step 1: Create the Target Table in PostgreSQL",id:"step-1-create-the-target-table-in-postgresql",level:3},{value:"Step 2: Define an Index for Output View",id:"step-2-define-an-index-for-output-view",level:3},{value:"Step 3: Configure Output Connector in Feldera",id:"step-3-configure-output-connector-in-feldera",level:3},{value:"Step 4: Verifying the Output in PostgreSQL",id:"step-4-verifying-the-output-in-postgresql",level:3},{value:"Kafka",id:"kafka",level:2},{value:"Web Apps / HTTP",id:"web-apps--http",level:2},{value:"Streaming with curl",id:"streaming-with-curl",level:3},{value:"Streaming in Python",id:"streaming-in-python",level:3},{value:"Takeaways",id:"takeaways",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"part-4-sending-output-to-multiple-destinations",children:"Part 4. Sending Output to Multiple Destinations"})}),"\n",(0,i.jsxs)(n.p,{children:["Once data has been processed, the next step is to deliver it to downstream\nsystems. Feldera supports this through ",(0,i.jsx)(n.a,{href:"/connectors/sinks",children:"output connectors"}),",\nwhich can continuously push the contents of the views to a variety of\ndestinations."]}),"\n",(0,i.jsx)(n.p,{children:"Common use cases include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Writing ",(0,i.jsx)(n.strong,{children:"aggregated and enriched data to PostgreSQL"})]}),"\n",(0,i.jsxs)(n.li,{children:["Publishing ",(0,i.jsx)(n.strong,{children:"real-time changes to a Kafka topic"})]}),"\n",(0,i.jsxs)(n.li,{children:["Sending updates to ",(0,i.jsx)(n.strong,{children:"web applications via HTTP"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Architecture Diagram with output to PostgreSQL, Kafka and Web Apps",src:t(51841).A+"",width:"1600",height:"542"})}),"\n",(0,i.jsx)(n.h2,{id:"postgresql-real-time-materialized-views",children:"PostgreSQL: Real-Time Materialized Views"}),"\n",(0,i.jsxs)(n.p,{children:["Feldera can be used to incrementally maintain materialized views in\nPostgreSQL. Unlike traditional materialized views, which must be manually\nrefreshed (by running the query ",(0,i.jsx)(n.code,{children:"REFRESH MATERIALIZED VIEW q1"}),"), these views\nstay in sync with Feldera as changes happen."]}),"\n",(0,i.jsx)(n.h3,{id:"step-1-create-the-target-table-in-postgresql",children:"Step 1: Create the Target Table in PostgreSQL"}),"\n",(0,i.jsx)(n.p,{children:"We connect to PostgreSQL instance running locally:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"psql postgres://postgres:password@localhost:5432/postgres\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Create a table ",(0,i.jsx)(n.code,{children:"q1"})," that will receive output from the Feldera view:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- PostgreSQL\nCREATE TABLE q1 (\n  l_returnflag   CHAR(1) NOT NULL,\n  l_linestatus   CHAR(1) NOT NULL,\n  sum_qty        DECIMAL(15,2),\n  sum_base_price DECIMAL(15,2),\n  sum_disc_price DECIMAL(15,2),\n  sum_charge     DECIMAL(15,2),\n  avg_qty        DECIMAL(15,2),\n  avg_price      DECIMAL(15,2),\n  avg_disc       DECIMAL(15,2),\n  count_order    BIGINT,\n\n  PRIMARY KEY(l_returnflag, l_linestatus)\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-define-an-index-for-output-view",children:"Step 2: Define an Index for Output View"}),"\n",(0,i.jsxs)(n.p,{children:["Create an ",(0,i.jsx)(n.a,{href:"/connectors/unique_keys#views-with-unique-keys",children:"index"})," on the\nunique key columns so that updates and deletions in PostgreSQL can be tracked\ncorrectly:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"create index q1_idx on q1(l_returnflag, l_linestatus);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"important",children:(0,i.jsx)(n.p,{children:"This index needs to be defined after the view definition."})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-configure-output-connector-in-feldera",children:"Step 3: Configure Output Connector in Feldera"}),"\n",(0,i.jsxs)(n.p,{children:["Next, we define the output connector for the view to send updates to PostgreSQL.\nSee docs: ",(0,i.jsx)(n.a,{href:"/connectors/sinks/postgresql",children:"PostgreSQL output connector"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'-- Feldera SQL\ncreate materialized view q1 with (\n    \'connectors\' = \'[{\n        "index": "q1_idx",\n        "transport": {\n            "name": "postgres_output",\n            "config": {\n                "uri": "postgres://postgres:password@localhost:5432/postgres",\n                "table": "q1"\n            }\n        }\n    }]\'\n) as select\n\tl_returnflag,\n\tl_linestatus,\n\tsum(l_quantity) as sum_qty,\n\tsum(l_extendedprice) as sum_base_price,\n\tsum(l_extendedprice * (1 - l_discount)) as sum_disc_price,\n\tsum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,\n\tavg(l_quantity) as avg_qty,\n\tavg(l_extendedprice) as avg_price,\n\tavg(l_discount) as avg_disc,\n\tcount(*) as count_order\nfrom\n\tlineitem\nwhere\n\tl_shipdate <= date \'1998-12-01\' - interval \'90\' day\ngroup by\n\tl_returnflag,\n\tl_linestatus\norder by\n\tl_returnflag,\n\tl_linestatus;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note the ",(0,i.jsx)(n.code,{children:"index"})," attribute that links this PostreSQL connector to the ",(0,i.jsx)(n.code,{children:"q1_idx"}),"\nindex declared above. This enables the connector to group changes to the same\nunique key in the output stream as described\n",(0,i.jsx)(n.a,{href:"/connectors/unique_keys#views-with-unique-keys",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"step-4-verifying-the-output-in-postgresql",children:"Step 4: Verifying the Output in PostgreSQL"}),"\n",(0,i.jsxs)(n.p,{children:["Once the pipeline is running, Feldera will continuously update the view ",(0,i.jsx)(n.code,{children:"q1"})," and\npush its output to the target table defined in PostgreSQL. We can verify that\ndata is flowing correctly by querying the target table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM Q1;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Result:"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"l_returnflag"}),(0,i.jsx)(n.th,{children:"l_linestatus"}),(0,i.jsx)(n.th,{children:"sum_qty"}),(0,i.jsx)(n.th,{children:"sum_base_price"}),(0,i.jsx)(n.th,{children:"sum_disc_price"}),(0,i.jsx)(n.th,{children:"sum_charge"}),(0,i.jsx)(n.th,{children:"avg_qty"}),(0,i.jsx)(n.th,{children:"avg_price"}),(0,i.jsx)(n.th,{children:"avg_disc"}),(0,i.jsx)(n.th,{children:"count_order"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"A"}),(0,i.jsx)(n.td,{children:"F"}),(0,i.jsx)(n.td,{children:"3,774,200.00"}),(0,i.jsx)(n.td,{children:"5,320,753,880.69"}),(0,i.jsx)(n.td,{children:"5,054,096,266.68"}),(0,i.jsx)(n.td,{children:"5,256,751,331.45"}),(0,i.jsx)(n.td,{children:"25.53"}),(0,i.jsx)(n.td,{children:"36,002.12"}),(0,i.jsx)(n.td,{children:"0.05"}),(0,i.jsx)(n.td,{children:"147,790"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"N"}),(0,i.jsx)(n.td,{children:"F"}),(0,i.jsx)(n.td,{children:"95,257.00"}),(0,i.jsx)(n.td,{children:"133,737,795.84"}),(0,i.jsx)(n.td,{children:"127,132,372.65"}),(0,i.jsx)(n.td,{children:"132,286,291.23"}),(0,i.jsx)(n.td,{children:"25.30"}),(0,i.jsx)(n.td,{children:"35,521.32"}),(0,i.jsx)(n.td,{children:"0.04"}),(0,i.jsx)(n.td,{children:"3,765"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"N"}),(0,i.jsx)(n.td,{children:"O"}),(0,i.jsx)(n.td,{children:"7,459,297.00"}),(0,i.jsx)(n.td,{children:"10,512,270,008.90"}),(0,i.jsx)(n.td,{children:"9,986,238,338.38"}),(0,i.jsx)(n.td,{children:"10,385,578,376.59"}),(0,i.jsx)(n.td,{children:"25.54"}),(0,i.jsx)(n.td,{children:"36,000.92"}),(0,i.jsx)(n.td,{children:"0.05"}),(0,i.jsx)(n.td,{children:"292,000"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"R"}),(0,i.jsx)(n.td,{children:"F"}),(0,i.jsx)(n.td,{children:"3,785,523.00"}),(0,i.jsx)(n.td,{children:"5,337,950,526.47"}),(0,i.jsx)(n.td,{children:"5,071,818,532.94"}),(0,i.jsx)(n.td,{children:"5,274,405,503.05"}),(0,i.jsx)(n.td,{children:"25.52"}),(0,i.jsx)(n.td,{children:"35,994.02"}),(0,i.jsx)(n.td,{children:"0.04"}),(0,i.jsx)(n.td,{children:"148,301"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"kafka",children:"Kafka"}),"\n",(0,i.jsxs)(n.p,{children:["A pipeline can have multiple output connectors sending data to a variety of destinations.\nThese connectors can be attached to the same or different SQL views.\nFor example, we can publish the output of ",(0,i.jsx)(n.code,{children:"q2"})," to a Kafka topic:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'-- Feldera SQL\ncreate materialized view q2 with (\n  \'connectors\' = \'[{\n    "transport": {\n      "name": "kafka_output",\n      "config": {\n        "bootstrap.servers": "localhost:9092",\n        "topic": "q2_output"\n      }\n    },\n    "format": {\n      "name": "json",\n      "config": {\n        "update_format": "insert_delete",\n        "array": false\n      }\n    }\n  }]\'\n) as\nselect ...\n'})}),"\n",(0,i.jsx)(n.h2,{id:"web-apps--http",children:"Web Apps / HTTP"}),"\n",(0,i.jsxs)(n.p,{children:["Web applications and backend services can receive ",(0,i.jsx)(n.strong,{children:"live updates"})," from Feldera\nusing the ",(0,i.jsx)(n.a,{href:"/connectors/sinks/http",children:"HTTP output connector"}),". This enables\napplications to consume real-time data streams over standard HTTP. Feldera can\n",(0,i.jsx)(n.strong,{children:"stream updates as they happen"})," without constant re-polling."]}),"\n",(0,i.jsx)(n.h3,{id:"streaming-with-curl",children:"Streaming with curl"}),"\n",(0,i.jsxs)(n.p,{children:["Live stream of updates to the view can be observed using the following ",(0,i.jsx)(n.code,{children:"curl"}),"\ncommand:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"curl -i -X 'POST' http://127.0.0.1:8080/v0/pipelines/batch/egress/q2?format=json\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As the contents of the view change, the changes will be\n",(0,i.jsx)(n.strong,{children:"streamed continuously"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"streaming-in-python",children:"Streaming in Python"}),"\n",(0,i.jsxs)(n.p,{children:["Feldera's ",(0,i.jsx)(n.a,{href:"https://docs.feldera.com/python",children:"Python SDK"})," provides a high-level API to subscribe to view\nupdates in Python applications."]}),"\n",(0,i.jsx)(n.p,{children:"The following snippet demonstrates how to register a callback that runs for\nevery chunk of update:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from feldera import Pipeline, FelderaClient\n\n# define your callback to run on every chunk of data received\n# ensure that it takes two parameters, the chunk (DataFrame) and the sequence number\ndef callback(df: pd.DataFrame, seq_no: int):\n    print(f"\\nSeq No: {seq_no}, DF size: {df.shape[0]}\\n")\n\npipeline = Pipeline.get("batch", FelderaClient.localhost())\n\n# register the callback for data received from the selected view\npipeline.foreach_chunk("q3", callback)\n\n# run the pipeline\npipeline.start()\n\n# wait for the pipeline to finish and shutdown\npipeline.wait_for_completion(shutdown=True)\n'})}),"\n",(0,i.jsx)(n.p,{children:"This is useful for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Updating live dashboards"}),"\n",(0,i.jsx)(n.li,{children:"Triggering side effects in response to new data"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"takeaways",children:"Takeaways"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Feldera allows streaming data directly to popular data sinks like\n",(0,i.jsx)(n.strong,{children:"PostgreSQL"}),", ",(0,i.jsx)(n.strong,{children:"Kafka"}),", ",(0,i.jsx)(n.strong,{children:"Delta Lake"})," and ",(0,i.jsx)(n.strong,{children:"Redis"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"By connecting Feldera's incremental SQL engine to different sources and destinations, you can query data from multiple independent sources and materialize the results in multiple independent destinations in real-time."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},51841:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/part4-arch-b1e0ca40c95a074e2c9905fdb219c900.jpg"}}]);