"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[1762],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},74426:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"sql/materialized","title":"Materialized Tables and Views","description":"By default, Feldera does not maintain the complete contents of tables and views; it only","source":"@site/docs/sql/materialized.md","sourceDirName":"sql","slug":"/sql/materialized","permalink":"/sql/materialized","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"UUID Operations","permalink":"/sql/uuid"},"next":{"title":"Mutually-Recursive Queries","permalink":"/sql/recursion"}}');var s=t(74848),i=t(28453);const r={},l="Materialized Tables and Views",o={},d=[{value:"Inspecting materialized tables and views",id:"inspecting-materialized-tables-and-views",level:2},{value:"Usage considerations",id:"usage-considerations",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"materialized-tables-and-views",children:"Materialized Tables and Views"})}),"\n",(0,s.jsx)(n.p,{children:"By default, Feldera does not maintain the complete contents of tables and views; it only\nstores the data necessary to compute future outputs. However, in some cases, users\nmay need to inspect or query the entire contents of a relation.  This can\nbe useful in the following scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"}),". The user may want to inspect the current contents of tables and views\nto validate their SQL program."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Retrieve full state snapshot"}),".  This is useful, for instance, to sync the output of Feldera with an external\ndatabase on demand."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/sql/ad-hoc",children:(0,s.jsx)(n.strong,{children:"Ad-hoc queries"})}),".  In some applications, users may not want to store a complete copy of the data,\nbut instead query it on demand."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Feldera supports such use cases by allowing users to label tables and views as ",(0,s.jsx)(n.strong,{children:"materialized"}),".\nTo declare a materialized table, use the materialized attribute:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE my_table (...) WITH ('materialized' = 'true');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Tables with a ",(0,s.jsx)(n.code,{children:"PRIMARY KEY"})," constraint are automatically materialized, since the pipeline\nmust maintain an index to enforce the constraint. Therefore, such tables do not need an explicit\n",(0,s.jsx)(n.code,{children:"materialized"})," attribute. The only exception is when a table has a ",(0,s.jsx)(n.code,{children:"LATENESS"})," attribute defined\non one of its primary key columns\u2014in that case, you must specify the ",(0,s.jsx)(n.code,{children:"materialized"})," attribute explicitly."]}),"\n",(0,s.jsxs)(n.p,{children:["To declare a materialized view, use the ",(0,s.jsx)(n.code,{children:"CREATE MATERIALIZED VIEW"})," syntax:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW my_view as SELECT * from my_table;\n"})}),"\n",(0,s.jsx)(n.p,{children:"These declarations instruct Feldera to maintain a complete snapshot of the table or view."}),"\n",(0,s.jsx)(n.h2,{id:"inspecting-materialized-tables-and-views",children:"Inspecting materialized tables and views"}),"\n",(0,s.jsxs)(n.p,{children:["You can explore the contents of materialized tables and views by issuing ",(0,s.jsx)(n.code,{children:"SELECT ..."})," ",(0,s.jsx)(n.a,{href:"/sql/ad-hoc",children:"ad-hoc SQL queries"}),".\nAd-hoc queries are evaluated non-incrementally against the current snapshot of pipeline's tables and views."]}),"\n",(0,s.jsxs)(n.p,{children:["You can run ad-hoc queries in ",(0,s.jsx)(n.a,{href:"/sql/ad-hoc#feldera-web-console",children:"Web Console"}),", ",(0,s.jsx)(n.a,{href:"/sql/ad-hoc#feldera-cli",children:"CLI"})," or via the ",(0,s.jsx)(n.a,{href:"/sql/ad-hoc#feldera-python-sdk",children:"Python SDK"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"usage-considerations",children:"Usage considerations"}),"\n",(0,s.jsxs)(n.p,{children:["Materialized relations can significantly increase the storage used by the program.\nFor example, Feldera can evaluate simple programs with no joins or aggregates without keeping\nany state.  However, materializing inputs or outputs of such programs will make them\n",(0,s.jsx)(n.strong,{children:"stateful"}),", requiring storage proportional to the size of the materialized\nrelations."]}),"\n",(0,s.jsxs)(n.p,{children:["Feldera takes advantage of ",(0,s.jsxs)(n.a,{href:"/sql/streaming#lateness-expressions",children:[(0,s.jsx)(n.code,{children:"LATENESS"})," annotations"]}),"\nto garbage collect old records in time series tables and views (i.e., tables and views with\nmonotonically or near-monotonically growing timestamps).  This allows evaluating complex queries\nover unbounded streams using bounded storage.  Materializing these tables forces Feldera to keep\ntheir entire history, resulting in unbounded storage growth."]}),"\n",(0,s.jsxs)(n.p,{children:["Finally note that materialized tables and views are ",(0,s.jsx)(n.strong,{children:"not a performance optimization"}),".\nFeldera automatically maintains all the state needed to incrementally evaluate user queries\nefficiently.  Materializing additional relations will not make it faster, but can actually\nslow it down, as it needs to write more data to storage."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);