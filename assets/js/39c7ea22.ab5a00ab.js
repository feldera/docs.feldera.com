"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8795],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var t=i(96540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},75118:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/modified_pipeline-eed3c062cbef4112c444d8816f178525.png"},98683:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"pipelines/modifying","title":"Modifying a Pipeline While Preserving its State","description":"This feature is only available in Feldera Enterprise Edition.","source":"@site/docs/pipelines/modifying.md","sourceDirName":"pipelines","slug":"/pipelines/modifying","permalink":"/pipelines/modifying","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Fault tolerance and checkpoint/resume","permalink":"/pipelines/fault-tolerance"},"next":{"title":"Synchronizing checkpoints to object store","permalink":"/pipelines/checkpoint-sync"}}');var s=i(74848),a=i(28453);const o={},r="Modifying a Pipeline While Preserving its State",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Introduction",id:"introduction",level:2},{value:"How bootstrapping works",id:"how-bootstrapping-works",level:2},{value:"1. Stop the pipeline",id:"1-stop-the-pipeline",level:3},{value:"2. Modify the pipeline",id:"2-modify-the-pipeline",level:3},{value:"3. Restart the pipeline",id:"3-restart-the-pipeline",level:3},{value:"Bootstrapping",id:"bootstrapping",level:2},{value:"Caveats and limitations",id:"caveats-and-limitations",level:2},{value:"Caveat 1: Feldera runtime upgrade can modify the pipeline",id:"caveat-1-feldera-runtime-upgrade-can-modify-the-pipeline",level:3},{value:"Caveat 2: Starting from an S3 checkpoint",id:"caveat-2-starting-from-an-s3-checkpoint",level:3},{value:"Caveat 3: Views that have not been modified may require bootstrapping",id:"caveat-3-views-that-have-not-been-modified-may-require-bootstrapping",level:3},{value:"Limitation 1: Tables must be materialized",id:"limitation-1-tables-must-be-materialized",level:3},{value:"Limitation 2: Bootstrapping does not work with <code>LATENESS</code>",id:"limitation-2-bootstrapping-does-not-work-with-lateness",level:3},{value:"Limitation 3: Table evolution is not yet supported",id:"limitation-3-table-evolution-is-not-yet-supported",level:3},{value:"Limitation 4: The pipeline does not detect changes to UDFs",id:"limitation-4-the-pipeline-does-not-detect-changes-to-udfs",level:3},{value:"API",id:"api",level:2},{value:"WebConsole",id:"webconsole",level:2},{value:"How different types of changes are handled",id:"how-different-types-of-changes-are-handled",level:2},{value:"Views",id:"views",level:3},{value:"Adding a view",id:"adding-a-view",level:4},{value:"Modifying a view",id:"modifying-a-view",level:4},{value:"Removing a view",id:"removing-a-view",level:4},{value:"Tables",id:"tables",level:3},{value:"Adding a table",id:"adding-a-table",level:4},{value:"Modifying a table",id:"modifying-a-table",level:4},{value:"Removing a table",id:"removing-a-table",level:4},{value:"Connectors",id:"connectors",level:3},{value:"Adding a connector",id:"adding-a-connector",level:4},{value:"Modifying a connector",id:"modifying-a-connector",level:4},{value:"Removing a connector",id:"removing-a-connector",level:4},{value:"Example",id:"example",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"modifying-a-pipeline-while-preserving-its-state",children:"Modifying a Pipeline While Preserving its State"})}),"\n",(0,s.jsx)(n.admonition,{title:"Enterprise-only feature",type:"note",children:(0,s.jsx)(n.p,{children:"This feature is only available in Feldera Enterprise Edition."})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"This is an experimental feature and may undergo significant\nchanges, including non-backward-compatible modifications, in future releases of\nFeldera."})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Feldera supports ",(0,s.jsx)(n.strong,{children:"incremental pipeline modification"})," through a feature called ",(0,s.jsx)(n.strong,{children:"bootstrapping"}),".\nThis allows you to evolve your SQL pipelines by adding, removing, or modifying table and view\ndefinitions without having to discard the pipeline's existing state and re-ingest all historical data\nfrom scratch."]}),"\n",(0,s.jsx)(n.p,{children:"When you modify a pipeline:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"New and modified views"})," are computed from existing pipeline state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Views not affected by the change"})," continue using their existing state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input data"})," does not need to be re-ingested (unless table schemas change)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"New and modified connectors"})," are added to the pipeline"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Feldera incrementally processes changes to input data. But what happens when the program\nitself needs to change, e.g., the user would like to add, remove, or modify a view definition?\nFeldera is able to handle such changes incrementally as well by only recomputing\nthe modified view and any views derived from it. Whenever possible, it uses existing state\nin tables and internal indexes maintained by the incremental view maintenance engine\nas inputs to evaluate affected views."}),"\n",(0,s.jsxs)(n.p,{children:["This process of building new or modified views from existing state in the pipeline\nis called ",(0,s.jsx)(n.strong,{children:"bootstrapping"}),". Bootstrapping allows you to evolve your SQL pipeline without\nhaving to re-ingest all historical data from scratch."]}),"\n",(0,s.jsx)(n.h2,{id:"how-bootstrapping-works",children:"How bootstrapping works"}),"\n",(0,s.jsx)(n.p,{children:"In this section we describe steps involved in modifying a pipeline while preserving its state."}),"\n",(0,s.jsx)(n.h3,{id:"1-stop-the-pipeline",children:"1. Stop the pipeline"}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline must be stopped before it can be modified. During the ",(0,s.jsx)(n.code,{children:"/stop"})," operation, the state\nof the pipeline is checkpointed in storage. Alternatively, if the pipeline crashes or gets force-stopped,\nits recent state is preserved in the last ",(0,s.jsx)(n.a,{href:"/pipelines/fault-tolerance",children:"periodic checkpoint"}),", as long as checkpointing is\nenabled.  This state will later be used to bootstrap the modified pipeline."]}),"\n",(0,s.jsx)(n.h3,{id:"2-modify-the-pipeline",children:"2. Modify the pipeline"}),"\n",(0,s.jsx)(n.p,{children:"The user modifies the pipeline by making arbitrary changes to its SQL code.\nThis way many changes across multiple tables and views can be performed at\nthe same time. This is particularly useful when working with nested views, where\na change to one of the views, such as adding a new column, may require updates to all\ndownstream views that depend on it."}),"\n",(0,s.jsx)(n.h3,{id:"3-restart-the-pipeline",children:"3. Restart the pipeline"}),"\n",(0,s.jsx)(n.p,{children:"When a modified pipeline is restarted, it performs the following operations:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Opens its latest checkpoint if one exists."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compares the checkpointed program with the new version being started.\nIf the program has not been modified since the checkpoint was made, resumes\nthe pipeline from the checkpoint."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If the program has been modified, the behavior depends on the ",(0,s.jsx)(n.code,{children:"bootstrap_policy"}),"\nargument passed to the pipeline on startup (see ",(0,s.jsx)(n.a,{href:"#api",children:"API section"})," below):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bootstrap_policy=await_approval"})," (default) - the pipeline stops in the ",(0,s.jsx)(n.code,{children:"AwaitingApproval"}),"\nstate. Its ",(0,s.jsx)(n.code,{children:"deployment_runtime_status_details"})," property (returned by the ",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/api/retrieve-a-pipeline",children:"pipeline status endpoint"}),")\nlists tables, views, and connectors\naffected by the changes.\nAt this point the pipeline is paused until the user signals their intention.\nThe user can either approve the changes by calling the\n",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/api/approves-the-pipeline-to-proceed-with-bootstrapping",children:(0,s.jsx)(n.code,{children:"/approve"})}),"\nAPI or terminate the pipeline using ",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/api/stop-the-pipeline-asynchronously-by-updating-the-desired-state",children:(0,s.jsx)(n.code,{children:"/stop?force=true"})}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bootstrap_policy=allow"})," - the pipeline proceeds to bootstrap modified views\nas described in the ",(0,s.jsx)(n.a,{href:"#bootstrapping",children:"Bootstrapping"})," section below."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bootstrap_policy=reject"})," - the pipeline is stopped with an error message\nlisting pipeline modifications. Its checkpointed state is preserved. The user can\nchoose to undo modifications or change ",(0,s.jsx)(n.code,{children:"bootstrap_policy"})," and restart the pipeline\nagain."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"bootstrapping",children:"Bootstrapping"}),"\n",(0,s.jsxs)(n.p,{children:["If pipeline modifications have been approved, the pipeline goes into the ",(0,s.jsx)(n.code,{children:"Bootstrapping"})," state\nand performs the following actions:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Discards any state that has been invalidated, such as state that belongs to deleted or modified\nviews."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The state of any new or modified tables is truncated; all connectors attached to these tables\nare reset to their initial state. Once bootstrapping completes, these tables will start empty and\nwill be populated with data received from input connectors."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A table is considered modified if types, names or the order of its columns have changed in any way,\nits primary key constraint has changed, or its ",(0,s.jsx)(n.code,{children:"materialized"})," or ",(0,s.jsx)(n.code,{children:"append_only"})," properties were added\nor removed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A table is NOT considered modified if only its connector definitions have changed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Any views derived from modified tables are considered modified. During bootstrapping, these\nviews will be evaluated against the empty table. After bootstrapping completes, the views will be\nincrementally updated as the table is populated with data from the input connectors."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Evaluates new and modified views based on existing state inside the pipeline and\noutputs the complete contents of these views to all attached output connectors.\nThis is similar to how the pipeline outputs data while ingesting historical data during regular backfill."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A view is considered modified if its query was altered in any way or if its ",(0,s.jsx)(n.code,{children:"MATERIALIZED"})," attribute\nwas added or removed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A view is NOT considered modified if only its connector definitions have changed."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Data Sink Cleanup Required",type:"warning",children:(0,s.jsx)(n.p,{children:"The pipeline does not output retractions for the old contents of modified views.\nYou must clear any connected data sinks before approving the modified pipeline to\navoid duplicate or stale data."})}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline does not ingest any inputs during bootstrapping. Once bootstrapping completes,\nthe pipeline moves to the ",(0,s.jsx)(n.code,{children:"Running"})," state, where it resumes ingesting and incrementally processing data\nfrom input connectors. Input connectors that were not modified in the new version of the pipeline and\nwhose tables have not changed resume ingestion from their checkpointed position in the input stream;\nother input connectors will start from the initial state specified in their configuration."]}),"\n",(0,s.jsx)(n.h2,{id:"caveats-and-limitations",children:"Caveats and limitations"}),"\n",(0,s.jsx)(n.h3,{id:"caveat-1-feldera-runtime-upgrade-can-modify-the-pipeline",children:"Caveat 1: Feldera runtime upgrade can modify the pipeline"}),"\n",(0,s.jsx)(n.p,{children:"Recompiling a pipeline with a new version of Feldera can modify its query plan and trigger\nbootstrapping even if its SQL code has not changed."}),"\n",(0,s.jsxs)(n.p,{children:["Feldera pipelines are compiled and executed using the SQL runtime associated with the\ninstalled version of the Feldera platform.\nAfter a Feldera upgrade, existing pipelines continue using the runtime with which they\nwere originally compiled; however once the pipeline is recompiled, either via the\n",(0,s.jsxs)(n.a,{href:"https://docs.feldera.com/api/recompile-a-pipeline-with-the-feldera-runtime-version-included-in-the",children:[(0,s.jsx)(n.code,{children:"/update_runtime"})," request"]}),"\nor by editing its SQL code, it will use the SQL runtime\nassociated with the current version of the Feldera platform. This new runtime may generate\na slightly different query plan for the same SQL tables and views, which will require going through the bootstrapping process.\nThe affected views will be recomputed from scratch and streamed to the output connectors even\nthough their contents haven't changed."]}),"\n",(0,s.jsx)(n.p,{children:"If this is undesirable, use one of the following methods to avoid updating the SQL runtime of a pipeline:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Avoid updating pipeline's runtime. As long as you don't invoke ",(0,s.jsx)(n.code,{children:"/update_runtime"})," or modify\nthe pipeline's code, it will continue running with its original runtime."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Pin the pipeline to a specific runtime version using the ",(0,s.jsxs)(n.a,{href:"/pipelines/lifecycle",children:[(0,s.jsx)(n.code,{children:"runtime_version"})," property"]}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"caveat-2-starting-from-an-s3-checkpoint",children:"Caveat 2: Starting from an S3 checkpoint"}),"\n",(0,s.jsxs)(n.p,{children:["Normally, when restarting, a pipeline continues from the checkpoint taken at the point when the pipeline was stopped, containing\nthe pipeline's latest state. If the pipeline crashed or was ",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/api/stop-the-pipeline-asynchronously-by-updating-the-desired-state",children:"force-stopped"}),", it will pick up the\nlast ",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/pipelines/configuration/#program-configuration",children:"periodic checkpoint"}),", if any."]}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, the user can start the pipeline from a checkpoint in an S3-compatible object\nstore, created using the ",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/pipelines/checkpoint-sync",children:"S3 sync"})," feature. This checkpoint may have been created by an older\nversion of the same pipeline or even by a different pipeline.  This situation is handled in the\nsame way: the pipeline computes a diff between the current and the checkpointed query plan, bootstraps\nany new and modified views and clears any tables that are not part of the checkpoint."]}),"\n",(0,s.jsx)(n.h3,{id:"caveat-3-views-that-have-not-been-modified-may-require-bootstrapping",children:"Caveat 3: Views that have not been modified may require bootstrapping"}),"\n",(0,s.jsx)(n.p,{children:"The Feldera SQL compiler performs some global optimizations across multiple views. Modifying or\nremoving one of the views can affect these optimizations, potentially changing the query plan\nfor other views, not directly affected by the change."}),"\n",(0,s.jsx)(n.h3,{id:"limitation-1-tables-must-be-materialized",children:"Limitation 1: Tables must be materialized"}),"\n",(0,s.jsxs)(n.p,{children:["Bootstrapping relies on existing pipeline state to initialize new and modified views.\n",(0,s.jsx)(n.a,{href:"/sql/materialized",children:"Materializing"})," all tables in the program by declaring them with ",(0,s.jsx)(n.code,{children:"'materialized' = 'true'"}),"\nensures that the pipeline can be bootstrapped after arbitrary changes from this materialized\nstate."]}),"\n",(0,s.jsx)(n.p,{children:"A program where not all tables are materialized may fail to start from a checkpoint and require\nclearing the pipeline's state and restarting the pipeline from scratch instead."}),"\n",(0,s.jsxs)(n.h3,{id:"limitation-2-bootstrapping-does-not-work-with-lateness",children:["Limitation 2: Bootstrapping does not work with ",(0,s.jsx)(n.code,{children:"LATENESS"})]}),"\n",(0,s.jsxs)(n.p,{children:["Programs with ",(0,s.jsxs)(n.a,{href:"/tutorials/time-series",children:[(0,s.jsx)(n.code,{children:"LATENESS"})," annotations"]})," currently cannot be bootstrapped. These annotations are used\nby the query engine to discard state that can no longer affect any future updates to any view.\nHowever, if the modified program contains new views that may depend on the discarded data, they cannot be computed."]}),"\n",(0,s.jsxs)(n.p,{children:["We currently do not implement the analysis needed to detect such changes and instead take the more coarse-grained\napproach of simply rejecting changes to pipelines with ",(0,s.jsx)(n.code,{children:"LATENESS"}),". Such pipelines must be\nbackfilled from scratch after any change by clearing their state before restarting."]}),"\n",(0,s.jsx)(n.h3,{id:"limitation-3-table-evolution-is-not-yet-supported",children:"Limitation 3: Table evolution is not yet supported"}),"\n",(0,s.jsx)(n.p,{children:"Adding, removing or renaming a table column will clear the table's state and require the table\nto be ingested from scratch."}),"\n",(0,s.jsx)(n.h3,{id:"limitation-4-the-pipeline-does-not-detect-changes-to-udfs",children:"Limitation 4: The pipeline does not detect changes to UDFs"}),"\n",(0,s.jsx)(n.p,{children:"Feldera currently assumes that a UDF whose name and signature have not changed does not change its behavior.\nIf the user modifies the implementation of a UDF without changing its signature, they need to either clear the\nstate of the pipeline or rename the UDF to trigger the bootstrapping of any views that depend on the modified UDF."}),"\n",(0,s.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,s.jsxs)(n.p,{children:["In this section we describe the REST API elements related to bootstrapping.\nAll of this functionality is also available via the Python SDK and the ",(0,s.jsx)(n.code,{children:"fda"})," CLI tool."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"bootstrap_policy"})," argument to the ",(0,s.jsxs)(n.a,{href:"https://docs.feldera.com/api/stop-the-pipeline-asynchronously-by-updating-the-desired-state",children:[(0,s.jsx)(n.code,{children:"/start"})," endpoint"]}),". This argument specifies how the pipeline should\nbehave when the checkpointed version of the program differs from the current version. The supported values are\n",(0,s.jsx)(n.code,{children:"await_approval"}),", ",(0,s.jsx)(n.code,{children:"allow"}),", and ",(0,s.jsx)(n.code,{children:"reject"}),". The default value is ",(0,s.jsx)(n.code,{children:"await_approval"}),". See the\n",(0,s.jsx)(n.a,{href:"#3-restart-the-pipeline",children:"Restart the pipeline"})," section above for details."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Two runtime states reported by the ",(0,s.jsx)(n.a,{href:"https://docs.feldera.com/api/retrieve-a-pipeline",children:"pipeline status endpoint"})," in the ",(0,s.jsx)(n.code,{children:"deployment_runtime_status"})," field:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AwaitingApproval"})," - When starting the pipeline with ",(0,s.jsx)(n.code,{children:"bootstrap_policy=await_approval"}),", if the pipeline\nrequires bootstrapping, it will stop in the ",(0,s.jsx)(n.code,{children:"AwaitingApproval"})," state waiting for the user to approve the\nchanges. While in this state, the ",(0,s.jsx)(n.code,{children:"deployment_runtime_status_details"})," field lists added, modified, and removed\ntables, views, and connectors in JSON format.\nThe pipeline exits this state when the user either approves the pipeline via the ",(0,s.jsx)(n.code,{children:"/approve"})," API\nor force-stops the pipeline with ",(0,s.jsx)(n.code,{children:"/stop?force=true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Bootstrapping"})," - In this state the pipeline evaluates new and modified views. Once bootstrapping completes,\nthe pipeline automatically moves into the ",(0,s.jsx)(n.code,{children:"Running"})," or ",(0,s.jsx)(n.code,{children:"Paused"})," state."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsxs)(n.a,{href:"https://docs.feldera.com/api/approves-the-pipeline-to-proceed-with-bootstrapping",children:[(0,s.jsx)(n.code,{children:"/approve"})," endpoint"]}),".\nInvoking this endpoint transitions the pipeline from the ",(0,s.jsx)(n.code,{children:"AwaitingApproval"})," to ",(0,s.jsx)(n.code,{children:"Bootstrapping"})," state."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"webconsole",children:"WebConsole"}),"\n",(0,s.jsxs)(n.p,{children:["Bootstrapping is also supported via the WebConsole. The WebConsole always starts pipelines with ",(0,s.jsx)(n.code,{children:"bootstrap_policy=await_approval"}),".\nIf the pipeline has changed since the last checkpoint, it shows a dialog with the list of detected pipeline changes where the user can\napprove the changes or stop the pipeline."]}),"\n",(0,s.jsx)(n.h2,{id:"how-different-types-of-changes-are-handled",children:"How different types of changes are handled"}),"\n",(0,s.jsx)(n.p,{children:"This section describes how the bootstrapping process handles different types of changes\nto your pipeline."}),"\n",(0,s.jsx)(n.h3,{id:"views",children:"Views"}),"\n",(0,s.jsx)(n.h4,{id:"adding-a-view",children:"Adding a view"}),"\n",(0,s.jsx)(n.p,{children:"New views are evaluated during bootstrapping; their full contents are sent to all attached output connectors."}),"\n",(0,s.jsx)(n.h4,{id:"modifying-a-view",children:"Modifying a view"}),"\n",(0,s.jsx)(n.p,{children:"A view is modified when the user changes its SQL definition or as a side effect of a change to an upstream\nview or a runtime upgrade. The old state of modified views is discarded; the view is evaluated from\nscratch, and its full contents are sent to all attached output connectors."}),"\n",(0,s.jsx)(n.h4,{id:"removing-a-view",children:"Removing a view"}),"\n",(0,s.jsx)(n.p,{children:"The view, all of its connectors, and all internal indexes used to maintain the view incrementally\nare discarded."}),"\n",(0,s.jsx)(n.h3,{id:"tables",children:"Tables"}),"\n",(0,s.jsx)(n.h4,{id:"adding-a-table",children:"Adding a table"}),"\n",(0,s.jsx)(n.p,{children:"New tables are created empty.\nNote that renaming an existing table is treated as deleting the old table and creating a new one."}),"\n",(0,s.jsx)(n.h4,{id:"modifying-a-table",children:"Modifying a table"}),"\n",(0,s.jsx)(n.p,{children:"Modifying a table clears the state of the table and all views that depend on it during bootstrapping.\nAll table connectors are reset to their initial states."}),"\n",(0,s.jsx)(n.h4,{id:"removing-a-table",children:"Removing a table"}),"\n",(0,s.jsx)(n.p,{children:"All state of the deleted table is discarded."}),"\n",(0,s.jsx)(n.h3,{id:"connectors",children:"Connectors"}),"\n",(0,s.jsx)(n.h4,{id:"adding-a-connector",children:"Adding a connector"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["New ",(0,s.jsx)(n.em,{children:"input"})," connectors are initialized according to their configuration.\nThey are activated after bootstrapping completes and the pipeline moves to\nthe ",(0,s.jsx)(n.code,{children:"Running"})," state."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["New ",(0,s.jsx)(n.em,{children:"output"})," connectors attached to ",(0,s.jsx)(n.em,{children:"new or modified"})," views are activated during\nbootstrapping. They receive the complete contents of the view computed during\nbootstrapping."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["New ",(0,s.jsx)(n.em,{children:"output"})," connectors attached to ",(0,s.jsx)(n.em,{children:"existing"})," views are activated after the\npipeline moves to the ",(0,s.jsx)(n.code,{children:"Running"})," state. These connectors only receive new changes\nto the views."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Feldera uses connector names to uniquely identify connectors within the scope of\na table or view. Renaming a connector is treated as deleting the old connector\nand adding a new connector with an identical configuration."}),"\n",(0,s.jsx)(n.p,{children:"We recommend explicitly naming all connectors. Anonymous connectors\nare automatically assigned names based on the order of their declaration. Such\nautomatic names are less stable than explicitly assigned names and can cause\nspurious changes to be detected in modified pipelines."}),"\n",(0,s.jsx)(n.h4,{id:"modifying-a-connector",children:"Modifying a connector"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Modified input connectors are initialized according to the new configuration.\nAny checkpointed state (e.g., the latest offset ingested by the connector)\nis discarded and the connector is reset to its initial state.\nAny data previously ingested by the connector is not affected."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Modified output connectors are initialized according to the new configuration."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"removing-a-connector",children:"Removing a connector"}),"\n",(0,s.jsx)(n.p,{children:"When an input connector is removed, any records previously ingested by the connector\nremain in the table."}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"In this example, we use the Python SDK to demonstrate how to modify a running pipeline and bootstrap the changes.\nWe start with a pipeline that tracks student grades and computes average grades per class\nwithin a specific date range. Then we transform the pipeline by:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Extending the date range in the ",(0,s.jsx)(n.code,{children:"avg_grade"})," view, which causes the ",(0,s.jsx)(n.code,{children:"avg_grade_enriched"}),"\nview to change as well."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Adding a new ",(0,s.jsx)(n.code,{children:"avg_grade_all_courses"})," view that computes the overall average across all courses."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Example: modifying and bootstrapping a pipeline",src:i(75118).A+"",width:"1404",height:"697"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from decimal import Decimal\nfrom feldera.enums import BootstrapPolicy, PipelineStatus\nfrom feldera.pipeline_builder import PipelineBuilder\nfrom feldera.runtime_config import RuntimeConfig\nfrom tests import TEST_CLIENT, enterprise_only\nfrom .helper import (\n    gen_pipeline_name,\n)\n\n# SQL program parameterized by start and end dates.\ndef gen_sql(start_date, end_date):\n    return f"""create table students (\n  id bigint,\n  name varchar\n) with (\n  \'materialized\' = \'true\'\n);\n\ncreate table grades (\n  student_id bigint,\n  class string,\n  grade decimal(5,2),\n  class_date date\n) with (\n  \'materialized\' = \'true\'\n);\n\n-- Average grade per student per class over a fixed date range.\ncreate view avg_grade as\nselect\n  student_id,\n\xa0 class,\n  AVG(grade) as class_avg\nfrom grades\nwhere\n  class_date >= date \'{start_date}\' and class_date <= date \'{end_date}\'\ngroup by student_id, class;\n\n-- Similar to avg_grade, but contains student name instead of Id.\ncreate materialized view avg_grade_enriched as\nselect\n  name as student_name,\n  class,\n  class_avg\nfrom\n  avg_grade join students on avg_grade.student_id = students.id;\n"""\n\n# Create and start the pipeline.\npipeline = PipelineBuilder(\n    TEST_CLIENT,\n    pipeline_name,\n    sql=gen_sql("2025-09-01", "2025-12-15"),\n    runtime_config=RuntimeConfig(\n        dev_tweaks={\n            "backfill_avoidance": True\n        },  # This should not be necessary once it is enabled by default.\n    ),\n).create_or_replace()\n\npipeline.start()\nassert pipeline.status() == PipelineStatus.RUNNING\n\n# Feed some input data.\npipeline.execute("insert into students values (1, \'Alice\'), (2, \'Bob\')")\npipeline.execute("""insert into grades values\n(1, \'algebra\', 97, \'2025-09-15\'),\n(1, \'physics\', 89, \'2025-11-15\'),\n(2, \'algebra\', 85, \'2025-10-22\'),\n(2, \'physics\', 93, \'2025-12-05\'),\n(1, \'algebra\', 95, \'2026-01-15\'),\n(1, \'physics\', 87, \'2026-03-15\'),\n(2, \'algebra\', 98, \'2026-04-22\'),\n(2, \'physics\', 91, \'2026-05-05\')\n""")\n\n# Validate outputs.\nresult = list(pipeline.query("SELECT * FROM avg_grade_enriched order by student_name, class"))\nassert result == [\n    {"student_name": "Alice", "class": "algebra", "class_avg": Decimal("97.00")},\n    {"student_name": "Alice", "class": "physics", "class_avg": Decimal("89.00")},\n    {"student_name": "Bob", "class": "algebra", "class_avg": Decimal("85.00")},\n    {"student_name": "Bob", "class": "physics", "class_avg": Decimal("93.00")},\n]\n\npipeline.stop(force=True)\n\nadditional_view = """\ncreate materialized view avg_grade_all_courses as\nselect\n  student_id,\n  avg(class_avg) as avg\nfrom avg_grade\ngroup by student_id;"""\n\n# Make two changes to the pipeline:\n# 1. Add a new view.\n# 2. Modify the avg_grade view, extending its date range.\npipeline.modify(\n    sql=gen_sql("2025-09-01", "2026-06-10") + additional_view\n)\n\n# Start the pipeline with await_approval bootstrap policy.\npipeline.start(bootstrap_policy=BootstrapPolicy.AWAIT_APPROVAL)\nassert pipeline.status() == PipelineStatus.AWAITINGAPPROVAL\n\n# When in the AwaitingApproval state, deployment_runtime_status_details shows\n# changes between the current and the checkpointed version of the pipeline.\n# Note: the avg_grade_enriched view is modified, as it depends on the modified avg_grade view.\ndiff = pipeline.deployment_runtime_status_details()\n\nassert diff == {\n    "added_input_connectors": [],\n    "added_output_connectors": [],\n    "modified_input_connectors": [],\n    "modified_output_connectors": [],\n    "program_diff": {\n        "added_tables": [],\n        "added_views": ["avg_grade_all_courses"],\n        "modified_tables": [],\n        "modified_views": ["avg_grade", "avg_grade_enriched"],\n        "removed_tables": [],\n        "removed_views": [],\n    },\n    "program_diff_error": None,\n    "removed_input_connectors": [],\n    "removed_output_connectors": []}\n\n# Approve the changes and wait for the pipeline to complete bootstrapping new\n# and modified views and reach the RUNNING state.\npipeline.approve()\n\npipeline.wait_for_status(PipelineStatus.RUNNING, timeout=300)\n\n# The new outputs should reflect input data within the modified date range.\nresult = list(pipeline.query("SELECT * FROM avg_grade_enriched order by student_name, class"))\n\nassert result == [\n    {"student_name": "Alice", "class": "algebra", "class_avg": Decimal("96.00")},\n    {"student_name": "Alice", "class": "physics", "class_avg": Decimal("88.00")},\n    {"student_name": "Bob", "class": "algebra", "class_avg": Decimal("91.50")},\n    {"student_name": "Bob", "class": "physics", "class_avg": Decimal("92.00")},\n]\n\nresult = list(pipeline.query("SELECT * FROM avg_grade_all_courses order by student_id"))\nassert result == [\n    {"student_id": 1, "avg": Decimal("92.00")},\n    {"student_id": 2, "avg": Decimal("91.75")},\n]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Pipeline modification with bootstrapping enables you to evolve your Feldera pipelines incrementally:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Modify SQL definitions without re-ingesting historical data"}),"\n",(0,s.jsx)(n.li,{children:"Add new views computed from existing state"}),"\n",(0,s.jsx)(n.li,{children:"Change multiple tables and views atomically"}),"\n",(0,s.jsx)(n.li,{children:"Review and approve changes before they take effect"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Workflow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Stop the pipeline (state is automatically checkpointed)"}),"\n",(0,s.jsx)(n.li,{children:"Modify the SQL code"}),"\n",(0,s.jsxs)(n.li,{children:["Restart with desired ",(0,s.jsx)(n.code,{children:"bootstrap_policy"})," (default: ",(0,s.jsx)(n.code,{children:"await_approval"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Review changes in ",(0,s.jsx)(n.code,{children:"deployment_runtime_status_details"})]}),"\n",(0,s.jsxs)(n.li,{children:["Approve changes via ",(0,s.jsx)(n.code,{children:"/approve"})," endpoint (if using ",(0,s.jsx)(n.code,{children:"await_approval"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Wait for bootstrapping to complete and pipeline to reach ",(0,s.jsx)(n.code,{children:"Running"})," state"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);