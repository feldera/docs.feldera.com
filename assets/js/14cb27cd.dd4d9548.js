"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[9167],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var l=s(96540);const r={},i=l.createContext(r);function d(e){const n=l.useContext(i);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),l.createElement(i.Provider,{value:n},e.children)}},41770:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>t});const l=JSON.parse('{"id":"sql/map","title":"Map Operations","description":"A MAP type can be created using the syntax MAP.","source":"@site/docs/sql/map.md","sourceDirName":"sql","slug":"/sql/map","permalink":"/sql/map","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"JSON and Dynamically-Typed Value Support","permalink":"/sql/json"},"next":{"title":"Operators","permalink":"/sql/operators"}}');var r=s(74848),i=s(28453);const d={},c="Map Operations",a={},t=[{value:"Map literals",id:"map-literals",level:2},{value:"Comparison Operations on Maps",id:"comparison-operations-on-maps",level:2},{value:"Examples:",id:"examples",level:4},{value:"Predefined functions on map values",id:"predefined-functions-on-map-values",level:2},{value:"The <code>UNNEST</code> Operator",id:"the-unnest-operator",level:2}];function o(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"map-operations",children:"Map Operations"})}),"\n",(0,r.jsxs)(n.p,{children:["A MAP type can be created using the syntax ",(0,r.jsx)(n.code,{children:"MAP<type, type>"}),".\nFor example ",(0,r.jsx)(n.code,{children:"MAP<VARCHAR, INT>"})," is a map from strings to integers."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"MAP"})," keys of type ",(0,r.jsx)(n.code,{children:"NULL"})," or ",(0,r.jsx)(n.code,{children:"MAP"})," are not supported."]}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.code,{children:"CREATE TABLE"})," and ",(0,r.jsx)(n.code,{children:"CREATE TYPE"})," declarations there is no way to\nspecify the nullability of the values of a ",(0,r.jsx)(n.code,{children:"MAP"}),".  The compiler will\nalways assume that map keys are ",(0,r.jsx)(n.em,{children:"not"})," nullable, while values elements\n",(0,r.jsx)(n.em,{children:"are"})," nullable:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE T(m MAP<VARCHAR, INT>);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Table ",(0,r.jsx)(n.code,{children:"T"})," will have a single column ",(0,r.jsx)(n.code,{children:"m"})," whose values are nullable\nmaps, the map's keys are non-nullable ",(0,r.jsx)(n.code,{children:"VARCHAR"})," values, while the\nmaps's values are nullable ",(0,r.jsx)(n.code,{children:"INT"})," values."]}),"\n",(0,r.jsx)(n.h2,{id:"map-literals",children:"Map literals"}),"\n",(0,r.jsxs)(n.p,{children:["Map literals have the syntax ",(0,r.jsx)(n.code,{children:"MAP["}),"key ",(0,r.jsx)(n.code,{children:","})," value ( ",(0,r.jsx)(n.code,{children:","})," key ",(0,r.jsx)(n.code,{children:","})," value )* ",(0,r.jsx)(n.code,{children:"]"}),".\nHere is an example: ",(0,r.jsx)(n.code,{children:"SELECT MAP['hi',2]"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"comparison-operations-on-maps",children:"Comparison Operations on Maps"}),"\n",(0,r.jsxs)(n.p,{children:["Comparison operations (",(0,r.jsx)(n.code,{children:"="}),", ",(0,r.jsx)(n.code,{children:"<>"}),", ",(0,r.jsx)(n.code,{children:"!="}),", ",(0,r.jsx)(n.code,{children:">"}),", ",(0,r.jsx)(n.code,{children:"<"}),", ",(0,r.jsx)(n.code,{children:">="}),", ",(0,r.jsx)(n.code,{children:"<="}),") can be applied to maps and work as follows:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The keys are first sorted ",(0,r.jsx)(n.strong,{children:"lexicographically"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"If the keys are not equal, the result is determined by their lexicographical order."}),"\n",(0,r.jsx)(n.li,{children:"If the keys are equal, their corresponding values are compared next."}),"\n",(0,r.jsx)(n.li,{children:"If the values are also equal, the comparison moves to the next key-value pair until a difference is found."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"examples",children:"Examples:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Given a table ",(0,r.jsx)(n.code,{children:"T"})," with columns ",(0,r.jsx)(n.code,{children:"c1 = MAP['v', 11, 'q', 66]"})," and ",(0,r.jsx)(n.code,{children:"c2 = MAP['v': 22]"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SELECT c1 FROM T WHERE c1 < c2;"})," returns:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"MAP['q', 66, 'v', 11]"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Given two maps where previously compared key-value pairs are equal, such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"MAP['f', 1, 'v', 0]"})," and ",(0,r.jsx)(n.code,{children:"MAP['f': 1]"})]}),"\n",(0,r.jsxs)(n.li,{children:["The map with more elements, ",(0,r.jsx)(n.code,{children:"MAP['f', 1, 'v', 0]"}),", is considered larger."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"predefined-functions-on-map-values",children:"Predefined functions on map values"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Example"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.em,{children:"map"}),(0,r.jsx)(n.code,{children:"["}),(0,r.jsx)(n.em,{children:"key"}),(0,r.jsx)(n.code,{children:"]"})]}),(0,r.jsxs)(n.td,{children:["Returns the element in the map with the specified key. If there is no such key, the result is ",(0,r.jsx)(n.code,{children:"NULL"}),"."]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"MAP['x', 4, 'y', 3]['x']"})," => 4"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)("a",{id:"cardinality"}),(0,r.jsx)(n.code,{children:"CARDINALITY"}),"(map)"]}),(0,r.jsx)(n.td,{children:"Returns the number of key-value pairs in the map."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"CARDINALITY(MAP['x', 4])"})," => 1"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)("a",{id:"map_contains_key"}),(0,r.jsx)(n.code,{children:"MAP_CONTAINS_KEY"}),"(map, key)"]}),(0,r.jsxs)(n.td,{children:["Returns true when the map has an item with the specified key; ",(0,r.jsx)(n.code,{children:"NULL"})," if any argument is ",(0,r.jsx)(n.code,{children:"NULL"}),"."]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"MAP_CONTAINS_KEY(MAP['x', 4], 'x')"})," => ",(0,r.jsx)(n.code,{children:"true"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)("a",{id:"map_keys"}),(0,r.jsx)(n.code,{children:"MAP_KEYS"}),"(map)"]}),(0,r.jsx)(n.td,{children:"Returns a sorted ARRAY of the appropriate type with all the keys of the MAP."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"MAP_KEYS(MAP['x', 4, 'y', 5])"})," => ",(0,r.jsx)(n.code,{children:"['x', 'y']"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)("a",{id:"map_values"}),(0,r.jsx)(n.code,{children:"MAP_VALUES"}),"(map)"]}),(0,r.jsx)(n.td,{children:"Returns an ARRAY of the appropriate type with all the values of the MAP."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"MAP_VALUES(MAP['x', 4, 'y', 5])"})," => ",(0,r.jsx)(n.code,{children:"[4, 5]"})]})]})]})]}),"\n",(0,r.jsxs)(n.h2,{id:"the-unnest-operator",children:["The ",(0,r.jsx)(n.code,{children:"UNNEST"})," Operator"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"UNNEST"})," operator takes a ",(0,r.jsx)(n.code,{children:"MAP"})," and returns a table with a row for\neach key-value pair in the ",(0,r.jsx)(n.code,{children:"MAP"}),".  If the input is a\nmap with 5 key-value pairs, the output is a table with 5 rows, each\nrow holding one key-value pair of the map."]}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"UNNEST"})," operator is used in self-joins as follows, an alias needs\nto be used to name the key and value fields (",(0,r.jsx)(n.code,{children:"zips(city, zip)"})," in the example):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE data(zipcodes MAP<VARCHAR, INT>, COUNTRY VARCHAR);\n\nCREATE VIEW V AS SELECT data.country, city, zip\nFROM data CROSS JOIN UNNEST(data.zipcodes) AS zips(city, zip);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"UNNEST"})," applied to a ",(0,r.jsx)(n.code,{children:"NULL"})," value returns an empty table."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);