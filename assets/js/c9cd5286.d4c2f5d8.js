"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[9221],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var t=s(96540);const r={},i=t.createContext(r);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(i.Provider,{value:n},e.children)}},94857:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"sql/udf","title":"User-Defined Functions","description":"The SQL statement CREATE FUNCTION can be used to declare new","source":"@site/docs/sql/udf.md","sourceDirName":"sql","slug":"/sql/udf","permalink":"/sql/udf","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"System Views","permalink":"/sql/system"},"next":{"title":"Connectors: connect to data sources and sinks","permalink":"/connectors/"}}');var r=s(74848),i=s(28453);const d={},l="User-Defined Functions",a={},o=[{value:"User-defined functions written in SQL",id:"user-defined-functions-written-in-sql",level:2},{value:"User-defined functions written in Rust",id:"user-defined-functions-written-in-rust",level:2},{value:"Step 1: Declare a function in the SQL program using <code>CREATE FUNCTION</code>",id:"step-1-declare-a-function-in-the-sql-program-using-create-function",level:3},{value:"Step 2: Locate the auto-generated Rust prototype",id:"step-2-locate-the-auto-generated-rust-prototype",level:3},{value:"Step 3: Implement the UDF in Rust",id:"step-3-implement-the-udf-in-rust",level:3},{value:"Step 4: Deploy the UDF",id:"step-4-deploy-the-udf",level:3},{value:"Using Feldera CLI:",id:"using-feldera-cli",level:4},{value:"Using Feldera Python SDK",id:"using-feldera-python-sdk",level:4},{value:"Using the REST API",id:"using-the-rest-api",level:4},{value:"SQL type representation in Rust",id:"sql-type-representation-in-rust",level:3},{value:"Return types",id:"return-types",level:3},{value:"Developing complex UDFs",id:"developing-complex-udfs",level:3},{value:"Limitations",id:"limitations",level:3},{value:"User-defined aggregates",id:"user-defined-aggregates",level:2},{value:"Creating user-defined linear aggregate functions",id:"creating-user-defined-linear-aggregate-functions",level:3},{value:"Example user-defined aggregate",id:"example-user-defined-aggregate",level:4},{value:"Creating user-defined non-linear aggregate functions",id:"creating-user-defined-non-linear-aggregate-functions",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"user-defined-functions",children:"User-Defined Functions"})}),"\n",(0,r.jsxs)(n.p,{children:["The SQL statement ",(0,r.jsx)(n.code,{children:"CREATE FUNCTION"})," can be used to declare new\nfunctions.  Functions can be implemented either in SQL or in Rust."]}),"\n",(0,r.jsx)(n.h2,{id:"user-defined-functions-written-in-sql",children:"User-defined functions written in SQL"}),"\n",(0,r.jsx)(n.p,{children:"The following example shows a user-defined function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION contains_number(str VARCHAR NOT NULL, value INTEGER)\nRETURNS BOOLEAN NOT NULL\nAS (str LIKE ('%' || CAST(value AS VARCHAR) || '%'));\n\nCREATE VIEW V0 AS SELECT contains_number(CAST('YES: 10 NO:5' AS VARCHAR), 5)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"user-defined-functions-written-in-rust",children:"User-defined functions written in Rust"}),"\n",(0,r.jsx)(n.admonition,{title:"Experimental feature",type:"warning",children:(0,r.jsx)(n.p,{children:"Rust UDF support is currently experimental and may undergo significant changes, including\nnon-backward-compatible modifications, in future releases of Feldera."})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Feldera's incremental query engine assumes that all computations are deterministic. Using\na non-deterministic UDF is likely to result in incorrect outputs. The SQL compiler cannot verify\nthat Rust functions meet this requirement. Therefore, it is the responsibility of the UDF\ndeveloper to ensure that their UDFs are deterministic, i.e., the function's return value\nmust depend solely on its arguments and not on clocks, random number generators, external\ndata sources, or other sources of non-determinism."}),"\n",(0,r.jsxs)(n.p,{children:["We are considering adding support for non-deterministic UDFs in the future. If your use case\nrequires a non-deterministic UDF, please share your feedback by commenting on the associated\n",(0,r.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/2619",children:"GitHub issue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["UDFs are compiled into native binary code and executed directly within the address space of\nthe pipeline. Therefore, only trusted code should be included in UDFs.  UDFs should not contain\npanics or invoke undefined behaviors. These can lead to crashes, memory corruption, or\nunpredictable behavior within the pipeline.  UDFs should handle all runtime errors gracefully,\nby returning a ",(0,r.jsx)(n.code,{children:"Result::Err()"})," (",(0,r.jsx)(n.a,{href:"#return-types",children:"see below"}),"). This ensures that errors are\npropagated in a controlled manner and can be handled by the calling code."]}),"\n"]}),"\n"]})}),"\n",(0,r.jsx)(n.p,{children:"Feldera supports UDFs implemented in Rust. To define a UDF, users declare the function\nin SQL without providing a body. The corresponding Rust implementation is supplied in a separate\nRust file, which contains the logic for all UDFs declared within the SQL program. A complete\nset of files that defines the pipeline in this case is:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"File"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"program.sql"})}),(0,r.jsx)(n.td,{children:"The SQL code, including table, view, and user-defined function declarations."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"stubs.rs"})}),(0,r.jsxs)(n.td,{children:["Auto-generated by the SQL compiler; contains Rust stubs for UDFs (",(0,r.jsx)(n.a,{href:"#step-2-locate-the-auto-generated-rust-prototype",children:"see below"}),")."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"udf.rs"})}),(0,r.jsx)(n.td,{children:"User-provided implementation of UDFs in Rust."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"udf.toml"})}),(0,r.jsxs)(n.td,{children:["User-provided list of external crates required by the code in ",(0,r.jsx)(n.code,{children:"udf.rs"}),". This list is appended to the ",(0,r.jsx)(n.code,{children:"[dependencies]"})," section of the ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," file."]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["We recommend using the Web Console to develop and debug Rust UDFs, as described\nbelow.  The Web Console code editor has a separate tab for each of these files,\nand supports an interactive development workflow.  Once ready, the creation and\ndeployment of the pipeline can be automated with scripts that make use of the\n",(0,r.jsx)(n.a,{href:"#using-feldera-cli",children:"Feldera CLI"}),", the ",(0,r.jsx)(n.a,{href:"#using-feldera-python-sdk",children:"Python API"}),",\nor the ",(0,r.jsx)(n.a,{href:"#using-the-rest-api",children:"REST API"}),".  These scripts and the SQL/Rust code can\nthen be maintained with the usual practices such as version control."]}),"\n",(0,r.jsxs)(n.h3,{id:"step-1-declare-a-function-in-the-sql-program-using-create-function",children:["Step 1: Declare a function in the SQL program using ",(0,r.jsx)(n.code,{children:"CREATE FUNCTION"})]}),"\n",(0,r.jsx)(n.p,{children:"Declare a SQL function without a body:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- UDF which encodes text in base64.\nCREATE FUNCTION base64(s VARBINARY) RETURNS VARCHAR;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-locate-the-auto-generated-rust-prototype",children:"Step 2: Locate the auto-generated Rust prototype"}),"\n",(0,r.jsxs)(n.p,{children:["When the SQL compiler encounters such a function, it generates a Rust stub for it in the ",(0,r.jsx)(n.code,{children:"stubs.rs"}),"\nfile.  The stub is an implementation of the UDF in Rust that simply invokes another function with the\nsame name and signature exported from the ",(0,r.jsx)(n.code,{children:"udf.rs"})," module:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/* stubs.rs */\n...\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    udf::base64(\n        s)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"udf::base64"})," function does not exist yet, so you will see a Rust compiler error similar to this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" error[E0425]: cannot find function `base64` in module `udf`\n  --\x3e project01926e00-f404-7813-b65c-d66ac9959998/src/stubs.rs:11:10\n   |\n11 |     udf::base64(\n   |          ^^^^^^ not found in `udf`\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-implement-the-udf-in-rust",children:"Step 3: Implement the UDF in Rust"}),"\n",(0,r.jsxs)(n.p,{children:["Copy the declaration from ",(0,r.jsx)(n.code,{children:"stubs.rs"})," to ",(0,r.jsx)(n.code,{children:"udf.rs"})," and replace its body with the actual implementation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/* udf.rs */\nuse feldera_sqllib::*;\nuse base64::prelude::*;\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<SqlString>, Box<dyn std::error::Error>> {\n    Ok(s.map(|v| SqlString::from_ref(BASE64_STANDARD.encode(v.as_slice()))))\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"use feldera_sqllib::*"})," directive imports the definitions of the\nRust types that the compiler uses to implement some of the SQL\ndatatypes.  The next section explains what these types are."]}),"\n",(0,r.jsxs)(n.p,{children:["If your UDF uses external crates, list these external dependencies in ",(0,r.jsx)(n.code,{children:"udf.toml"}),".\nThe contents of this file is appended to the ",(0,r.jsx)(n.code,{children:"[dependencies]"})," section in the generated\n",(0,r.jsx)(n.code,{children:"Cargo.toml"})," file."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'base64 = "0.22.1"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-deploy-the-udf",children:"Step 4: Deploy the UDF"}),"\n",(0,r.jsxs)(n.h4,{id:"using-feldera-cli",children:["Using ",(0,r.jsx)(n.a,{href:"/interface/cli",children:"Feldera CLI"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fda create udf_fda_test --udf-rs udf.rs --udf-toml udf.toml program.sql\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"using-feldera-python-sdk",children:["Using ",(0,r.jsx)(n.a,{href:"pathname:///python/",children:"Feldera Python SDK"})]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Click to see how to create a pipeline with a Rust UDF using the Feldera Python SDK"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from feldera import FelderaClient, PipelineBuilder\n\n# SQL program.\nsql = """\n-- UDF which encodes text in base64.\nCREATE FUNCTION base64(s VARBINARY) RETURNS VARCHAR;\n\nCREATE TABLE binary_t(\n    b VARBINARY\n);\n\nCREATE MATERIALIZED VIEW base64_v AS\nSELECT\n    base64(b) as text\nFROM\n    binary_t;\n"""\n\n# UDF implementation in Rust.\nudf_rust = """\nuse feldera_sqllib::*;\nuse base64::prelude::*;\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    Ok(s.map(|v| BASE64_STANDARD.encode(v.as_slice())))\n}"""\n\n# External Rust dependencies.\nudf_toml = """\nbase64 = "0.22.1"\n"""\n\n# Create a pipeline using the above SQL, Rust, and TOML code.\nfeldera = FelderaClient("http://127.0.0.1:8080")\npipeline = PipelineBuilder(\n    feldera, name="udf_test", sql=sql, udf_rust=udf_rust, udf_toml = udf_toml).create_or_replace()\n\npipeline.start()\n\nnext(pipeline.query("insert into binary_t values(X\'0123456789ABCDEF\')"))\noutput = pipeline.query("select * from base64_v")\n\nassert list(output) == [{\'text\': \'ASNFZ4mrze8=\'}]\n\npipeline.shutdown()\npipeline.delete()\n'})})]}),"\n",(0,r.jsxs)(n.h4,{id:"using-the-rest-api",children:["Using the ",(0,r.jsx)(n.a,{href:"/api",children:"REST API"})]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Click to see how to create a pipeline with a Rust UDF using the Feldera REST API"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n\necho "\n-- UDF which encodes text in base64.\nCREATE FUNCTION base64(s VARBINARY) RETURNS VARCHAR;\n\nCREATE TABLE binary_t(\n    b VARBINARY\n);\n\nCREATE MATERIALIZED VIEW base64_v AS\nSELECT\n    base64(b) as text\nFROM\n    binary_t;\n" > program.sql\n\necho "\nuse feldera_sqllib::*;\nuse base64::prelude::*;\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    Ok(s.map(|v| BASE64_STANDARD.encode(v.as_slice())))\n}" > udf.rs\n\necho "\nbase64 = \\"0.22.1\\"\n" > udf.toml\n\n\ncurl -i -X PUT http://127.0.0.1:8080/v0/pipelines/udf_api_test \\\n-H \'Content-Type: application/json\' \\\n-d "$(jq -Rsn \\\n  --rawfile sql program.sql \\\n  --rawfile udf_rust udf.rs \\\n  --rawfile udf_toml udf.toml \\\n  \'{\n    name: "udf_api_test",\n    description: "Create a UDF using REST API",\n    program_code: $sql,\n    runtime_config: {},\n    program_config: {},\n    udf_rust: $udf_rust,\n    udf_toml: $udf_toml\n  }\')"\n'})})]}),"\n",(0,r.jsx)(n.h3,{id:"sql-type-representation-in-rust",children:"SQL type representation in Rust"}),"\n",(0,r.jsx)(n.admonition,{title:"Experimental feature",type:"caution"}),"\n",(0,r.jsxs)(n.p,{children:["The following table shows the Rust representation of standard SQL data\ntypes.  A nullable SQL type is represented by the corresponding rust\n",(0,r.jsx)(n.code,{children:"Option<>"})," type.  Notice that some of these types are not standard\nRust types, but are defined in the\n",(0,r.jsx)(n.a,{href:"https://docs.rs/feldera-sqllib/0.27.0/feldera_sqllib/",children:"feldera-sqllib"}),"\ncrate, which is part of the Feldera SQL runtime."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"SQL"}),(0,r.jsx)(n.th,{children:"Rust"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BOOLEAN"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TINYINT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i8"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SMALLINT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i16"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i32"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BIGINT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i64"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TINYINT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u8"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SMALLINT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u16"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u32"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BIGINT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u64"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DECIMAL(p, s)"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::SqlDecimal<P, S>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"REAL"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::F32"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DOUBLE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::F64"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"CHAR"}),", ",(0,r.jsx)(n.code,{children:"CHAR(n)"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::SqlString"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"VARCHAR"}),", ",(0,r.jsx)(n.code,{children:"VARCHAR(n)"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::SqlString"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"BINARY"}),", ",(0,r.jsx)(n.code,{children:"BINARY(n)"}),", ",(0,r.jsx)(n.code,{children:"VARBINARY"}),", ",(0,r.jsx)(n.code,{children:"VARBINARY(n)"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::ByteArray"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NULL"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"()"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INTERVAL"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"feldera_sqllib::ShortInterval"}),", ",(0,r.jsx)(n.code,{children:"feldera_sqllib::LongInterval"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TIME"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Time"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TIMESTAMP"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Timestamp"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DATE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Date"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"T ARRAY"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Array<T>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"MAP<K, V>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Map<K, V>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"UUID"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Uuid"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"VARIANT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Variant"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ROW"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Tup"}),"N"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"User-defined struct type"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Tup"}),"N"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Multiple SQL types may be represented by the same Rust type.  For\nexample, ",(0,r.jsx)(n.code,{children:"CHAR"}),", ",(0,r.jsx)(n.code,{children:"CHAR(n)"}),", ",(0,r.jsx)(n.code,{children:"VARCHAR(n)"}),", and ",(0,r.jsx)(n.code,{children:"VARCHAR"})," are all\nrepresented by the ",(0,r.jsx)(n.code,{children:"SqlString"})," type."]}),"\n",(0,r.jsxs)(n.p,{children:["The SQL family of ",(0,r.jsx)(n.code,{children:"INTERVAL"})," types translates to one of two Rust\ntypes: ",(0,r.jsx)(n.code,{children:"ShortInterval"})," (representing intervals from days to seconds),\nand ",(0,r.jsx)(n.code,{children:"LongInterval"})," (representing intervals from years to months).\n(Our dialect of SQL does not allow mixing the two kinds of intervals\nin a single expression.)"]}),"\n",(0,r.jsxs)(n.p,{children:["Currently ",(0,r.jsx)(n.code,{children:"feldera_sqlllib::Map"})," is defined as ",(0,r.jsx)(n.code,{children:"type Map = Arc<BTreeMap>"}),", and ",(0,r.jsx)(n.code,{children:"feldera_sqlllib::Array"})," is defined as ",(0,r.jsx)(n.code,{children:"type Array = Arc<Vec>"}),".  Currently ",(0,r.jsx)(n.code,{children:"feldera_sqlllib::SqlString"})," is a thin wrapper\ntype around the ",(0,r.jsx)(n.code,{children:"ArcStr"})," type from the ",(0,r.jsx)(n.code,{children:"arcstr"})," crate."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"ROW"})," type with N fields represented by a Rust ",(0,r.jsx)(n.code,{children:"Tup"}),"N datatype.  A\nuser-defined structure type is also represented by a tuple ",(0,r.jsx)(n.code,{children:"Tup"}),"N\ntype.  These tuple types can be imported from the current crate."]}),"\n",(0,r.jsxs)(n.p,{children:["Here are some examples using ",(0,r.jsx)(n.code,{children:"ROW"})," and user-defined types:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE X AS (x int);\nCREATE FUNCTION f(arg X) RETURNS X;\nCREATE FUNCTION g(x int NOT NULL) RETURNS ROW(a INT, b INT) NOT NULL;\nCREATE VIEW V AS SELECT f(X(1)), g(2).a;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And here is a possible implementation of the used-defined functions\n",(0,r.jsx)(n.code,{children:"f"})," and ",(0,r.jsx)(n.code,{children:"g"})," in Rust:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use crate::{Tup1, Tup2};\nuse feldera_sqllib::*;\npub fn f(x: Option<Tup1<Option<i32>>>) ->\n   Result<Option<Tup1<Option<i32>>>, Box<dyn std::error::Error>> {\n   match x {\n      None => Ok(None),\n      Some(x) => match x.0 {\n         None => Ok(Some(Tup1::new(None))),\n         Some(x) => Ok(Some(Tup1::new(Some(x + 1)))),\n      }\n   }\n}\n\npub fn g(x: i32) -> Result<Tup2<i32, i32>, Box<dyn std::error::Error>> {\n   Ok(Tup2::new(x-1, x+1))\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"return-types",children:"Return types"}),"\n",(0,r.jsxs)(n.p,{children:["In the Rust implementation the function always has to return the type\n",(0,r.jsx)(n.code,{children:"Result<T, Box<dyn std::error::Error>>"}),", where ",(0,r.jsx)(n.code,{children:"T"})," is the Rust\nequivalent of the expected return type of the SQL function.  The Rust\nfunction should return an ",(0,r.jsx)(n.code,{children:"Err"})," only when the function fails at\nruntime with a fatal condition, e.g., array index out of\nbounds, arithmetic overflows, etc."]}),"\n",(0,r.jsx)(n.h3,{id:"developing-complex-udfs",children:"Developing complex UDFs"}),"\n",(0,r.jsxs)(n.p,{children:["While many useful UDFs can be implemented with just a few lines of Rust,\nsome may require more complex code that is easier to develop\nusing a full-featured Rust IDE.  To support the development of such\nUDFs, we made the ",(0,r.jsx)(n.code,{children:"feldera-sqllib"})," crate available on\n",(0,r.jsx)(n.a,{href:"https://crates.io/crates/feldera-sqllib",children:"crates.io"}),".\nIn order to implement a complex Rust UDF (or a library of UDFs) using\na Rust IDE:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create a new Rust crate to serve as the container for your UDFs."}),"\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.code,{children:"feldera-sqllib"})," as a dependency to ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," (use the crate\nversion that matches the version of Feldera you are working with)."]}),"\n",(0,r.jsx)(n.li,{children:"Implement and test your UDFs within this crate."}),"\n",(0,r.jsx)(n.li,{children:"Copy the final Rust code and dependencies to the Feldera Web Console."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If your UDFs require a larger Rust project with multiple modules, we\nrecommend encapsulating the majority of the UDF logic in a crate.\nThis crate can be hosted on ",(0,r.jsx)(n.a,{href:"https://crates.io/",children:"crates.io"})," or GitHub.\nImport this crate to your Feldera pipeline via the ",(0,r.jsx)(n.code,{children:"udf.toml"})," file,\nincluding only wrapper functions that call the API of this crate in\n",(0,r.jsx)(n.code,{children:"udf.rs"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Currently only limited implicit casts are inserted by the compiler for the\nfunction arguments and function result in the SQL program.  For\nexample, a call such as ",(0,r.jsx)(n.code,{children:"CONTAINS_NUMBER('2010-10-20', '5')"})," will\nfail at SQL compilation time because the first argument has type\n",(0,r.jsx)(n.code,{children:"CHAR(8)"})," instead of ",(0,r.jsx)(n.code,{children:"VARCHAR"}),", and the second argument has type\n",(0,r.jsx)(n.code,{children:"CHAR(1)"})," instead of ",(0,r.jsx)(n.code,{children:"INTEGER"}),".  This can be avoided by calling the\nfunction using an explicit cast: ",(0,r.jsx)(n.code,{children:"CONTAINS_NUMBER(CAST('2010-10-20' AS VARCHAR), CAST('5' AS INTEGER))"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"User-defined functions cannot have names identical to standard SQL\nlibrary function names."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Polymorphic functions are not supported.  For example, in SQL the\naddition operation operates on any numeric types; such an operation\ncannot be implemented as a single user-defined function."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"user-defined-aggregates",children:"User-defined aggregates"}),"\n",(0,r.jsx)(n.admonition,{title:"Experimental feature",type:"warning",children:(0,r.jsx)(n.p,{children:"Rust UDA support is currently experimental and may undergo significant\nchanges, including non-backward-compatible modifications, in future\nreleases of Feldera."})}),"\n",(0,r.jsxs)(n.p,{children:["The SQL statement ",(0,r.jsx)(n.code,{children:"CREATE AGGREGATE"})," can be used to extend the set of\naggregate functions supported by Feldera SQL with user-defined\naggregation functions.  Such functions need to be implemented in Rust.\nThe argument and result of ",(0,r.jsx)(n.code,{children:"CREATE AGGREGATE"})," must be nullable."]}),"\n",(0,r.jsx)(n.h3,{id:"creating-user-defined-linear-aggregate-functions",children:"Creating user-defined linear aggregate functions"}),"\n",(0,r.jsx)(n.p,{children:"In general, a function A is linear if it has the following property:\nA(C1 UNION C2) = A(C1) + A(C2), where C1 and C2 are arbitrary\ncollections.  The type of the result produced by the function is\nexpected to have a + operation, and it must be commutative and\nassociative."}),"\n",(0,r.jsx)(n.p,{children:"To implement a user-defined linear aggregate function the user has to\ndefine 3 Rust objects:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["a type for the accumulator; the type name is obtained from the\naggregate function name with the suffix ",(0,r.jsx)(n.code,{children:"_accumulator_type"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The actual arithmetic is performed using values of this type.  The\naccumulator type is thus required to implement several traits\ndefined in the DBSP core library:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://docs.rs/dbsp/latest/dbsp/trace/trait.DBWeight.html",children:(0,r.jsx)(n.code,{children:"DBWeight"})}),"\nwhich is a combination of\n",(0,r.jsx)(n.a,{href:"https://docs.rs/dbsp/latest/dbsp/trace/trait.DBData.html",children:(0,r.jsx)(n.code,{children:"DBData"})}),"\nand\n",(0,r.jsx)(n.a,{href:"https://docs.rs/dbsp/latest/dbsp/algebra/trait.MonoidValue.html",children:(0,r.jsx)(n.code,{children:"MonoidValue"})}),".\n",(0,r.jsx)(n.code,{children:"DBData"})," allows accumulators to be stored in relations which may be\nspilled to disk; amond other traits, it requires ",(0,r.jsx)(n.code,{children:"Ord"})," and\n",(0,r.jsx)(n.code,{children:"ArchivedDBData"}),".  ",(0,r.jsx)(n.code,{children:"MonoidValue"})," essentially requires the traits\n",(0,r.jsx)(n.code,{children:"Zero"}),", ",(0,r.jsx)(n.code,{children:"HasZero"}),", ",(0,r.jsx)(n.code,{children:"Add"})," (and variants such as ",(0,r.jsx)(n.code,{children:"AddByRef"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://docs.rs/dbsp/latest/dbsp/algebra/trait.MulByRef.html",children:(0,r.jsx)(n.code,{children:"MulByRef"})}),"\nwhich allows accumulator values to be multiplied by integer\n(signed and unsigned) weights.  Negative weights are used when\nelements are removed from collections; weights larger than 1 are used\nwhen multiple copies of an element are updated in one operation.\nCurrently the ",(0,r.jsx)(n.code,{children:"Weight"})," type is ",(0,r.jsx)(n.code,{children:"i64"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["a function which converts a collection value into an accumulator\nvalue.  The function's name is obtained from the aggregate function\nname with the suffix ",(0,r.jsx)(n.code,{children:"_map"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["a function to perform additional post-processing on the aggregation\nresult, returning the expected result.  The function's name is\nobtained from the aggregate function name with the suffix ",(0,r.jsx)(n.code,{children:"_post"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'This use of the post-processing function enables linear\nimplementations for aggregates such as "average", where the\naggregation produces a sum and a count, while the post-processing step\nproduces the actual result by computing sum/count.'}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"Add"})," operation for the accumulator type is not linear, the\nresults produced by the program are undefined.  This requirement can\nbe subtle; for example, floating point addition is not associative,\nand thus an computing an aggregate like ",(0,r.jsx)(n.code,{children:"SUM"})," on floating-point values\nusing standard floating point arithmetic will produce incorrect\nresults or runtime crashes."]}),"\n",(0,r.jsx)(n.h4,{id:"example-user-defined-aggregate",children:"Example user-defined aggregate"}),"\n",(0,r.jsxs)(n.p,{children:["We show an example building a user-defined linear aggregate for\ncomputing sum of 128-bit values.  We use the SQL type ",(0,r.jsx)(n.code,{children:"BINARY(16)"})," to\nrepresent 128-bit numbers.  The first step requires declaring the\nuser-defined aggregate function in SQL:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE LINEAR AGGREGATE i128_sum(value BINARY(16)) RETURNS BINARY(16);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Notice that the type of the argument and result are both nullable.  We\ncan then use the user-defined aggregate in a SQL program:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE T(value BINARY(16));\n\nCREATE MATERIALIZED VIEW V0 AS SELECT i128_sum(value) FROM T;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In SQL the ",(0,r.jsx)(n.code,{children:"SUM"})," function is polymorphic, since it works for any\nnumeric SQL type.  Currently user-defined aggregate functions cannot\nbe polymorphic, so one needs to define a new user-defined aggregate\nfunction for each type of values; moreover, the ",(0,r.jsx)(n.code,{children:"SUM"})," function name\ncannot be used for a user-defined aggregate."]}),"\n",(0,r.jsxs)(n.p,{children:["The user needs to add the following 2 dependencies to the ",(0,r.jsx)(n.code,{children:"udf.toml"}),"\nfile:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'i256 = { version = "0.2.2", features = ["num-traits"] }\nnum-traits = "0.2.19"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We will use the ",(0,r.jsx)(n.a,{href:"https://docs.rs/i256/latest/i256/index.html",children:"I256"}),"\nRust crate for 256-bit arithmetic.  In our implementation we wrap this\ntype into the type ",(0,r.jsx)(n.code,{children:"I256Wrapper"}),", for which we implement the required\ntraits.  Most of the code is devoted for this task, and is relatively\nstraightforward."]}),"\n",(0,r.jsxs)(n.p,{children:["For our example the accumulator type that the user has to define is\nnamed ",(0,r.jsx)(n.code,{children:"i128_sum_accumulator_type"}),", holding the partial sum computed,\nstored in an I256 value."]}),"\n",(0,r.jsxs)(n.p,{children:["The user would add the following implementation to the ",(0,r.jsx)(n.code,{children:"udf.rs"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use i256::I256;\nuse feldera_sqllib::*;\nuse crate::{AddAssignByRef, AddByRef, HasZero, MulByRef, SizeOf, Tup3};\nuse derive_more::Add;\nuse num_traits::Zero;\nuse rkyv::Fallible;\nuse std::ops::{Add, AddAssign};\n\n#[derive(Add, Clone, Debug, Default, PartialOrd, Ord, Eq, PartialEq, Hash)]\npub struct I256Wrapper {\n    pub data: I256,\n}\n\nimpl SizeOf for I256Wrapper {\n    fn size_of_children(&self, context: &mut size_of::Context) {}\n}\n\nimpl From<[u8; 32]> for I256Wrapper {\n    fn from(value: [u8; 32]) -> Self {\n        Self { data: I256::from_be_bytes(value) }\n    }\n}\n\nimpl From<&[u8]> for I256Wrapper {\n    fn from(value: &[u8]) -> Self {\n        let mut padded = [0u8; 32];\n        // If original value is negative, pad with sign\n        if value[0] & 0x80 != 0 {\n            padded.fill(0xff);\n        }\n        let len = value.len();\n        if len > 32 {\n            panic!("Slice larger than target");\n        }\n        padded[32-len..].copy_from_slice(&value[..len]);\n        Self { data: I256::from_be_bytes(padded) }\n    }\n}\n\nimpl MulByRef<Weight> for I256Wrapper {\n    type Output = Self;\n\n    fn mul_by_ref(&self, other: &Weight) -> Self::Output {\n        Self {\n            data: self.data.checked_mul_i64(*other)\n                .expect("Overflow during multiplication"),\n        }\n    }\n}\n\nimpl HasZero for I256Wrapper {\n    fn zero() -> Self {\n        Self { data: I256::zero() }\n    }\n\n    fn is_zero(&self) -> bool {\n        self.data.is_zero()\n    }\n}\n\nimpl AddByRef for I256Wrapper {\n    fn add_by_ref(&self, other: &Self) -> Self {\n        Self { data: self.data.add(other.data) }\n    }\n}\n\nimpl AddAssignByRef<Self> for I256Wrapper {\n    fn add_assign_by_ref(&mut self, other: &Self) {\n        self.data += other.data\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialOrd, Ord, Eq, PartialEq)]\npub struct ArchivedI256Wrapper {\n    pub bytes: [u8; 32],\n}\n\nimpl rkyv::Archive for I256Wrapper {\n    type Archived = ArchivedI256Wrapper;\n    type Resolver = ();\n\n    #[inline]\n    unsafe fn resolve(&self, pos: usize, _: Self::Resolver, out: *mut Self::Archived) {\n        out.write(ArchivedI256Wrapper {\n            bytes: self.data.to_be_bytes(),\n        });\n    }\n}\n\nimpl<S: Fallible + ?Sized> rkyv::Serialize<S> for I256Wrapper {\n    #[inline]\n    fn serialize(&self, serializer: &mut S) -> Result<Self::Resolver, S::Error> {\n        Ok(())\n    }\n}\n\nimpl<D: Fallible + ?Sized> rkyv::Deserialize<I256Wrapper, D> for ArchivedI256Wrapper {\n    #[inline]\n    fn deserialize(&self, _: &mut D) -> Result<I256Wrapper, D::Error> {\n        Ok(I256Wrapper::from(self.bytes))\n    }\n}\n\npub type i128_sum_accumulator_type = I256Wrapper;\n\npub fn i128_sum_map(val: ByteArray) -> i128_sum_accumulator_type {\n    I256Wrapper::from(val.as_slice())\n}\n\npub fn i128_sum_post(val: i128_sum_accumulator_type) -> ByteArray {\n    // Check for overflow\n    if val.data < I256::from(i128::MIN) || val.data > I256::from(i128::MAX) {\n        panic!("Result of aggregation {} does not fit in 128 bits", val.data);\n    }\n    ByteArray::new(&val.data.to_be_bytes()[16..])\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The two functions needed to implement the aggregation are\n",(0,r.jsx)(n.code,{children:"i128_sum_map"}),", and ",(0,r.jsx)(n.code,{children:"i128_sum_post"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"i128_sum_map"})," converts a ",(0,r.jsx)(n.code,{children:"BINARY(16)"})," value into an accumulator\nvalue.  Notice that in the SQL runtime library ",(0,r.jsx)(n.code,{children:"BINARY(16)"})," is\nimplemented as a ",(0,r.jsx)(n.code,{children:"ByteArray"}),".  The argument of this function must be\nnon-nullable."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"i128_sum_post"})," converts the accumulator value into the expected\nresult type ",(0,r.jsx)(n.code,{children:"BINARY(16)"}),".  The result must be non-nullable."]}),"\n",(0,r.jsxs)(n.p,{children:["The handling of ",(0,r.jsx)(n.code,{children:"NULL"})," is dictated by the SQL semantics, and cannot be\nchanged: aggregating a collection containing only ",(0,r.jsx)(n.code,{children:"NULL"})," values (or\nempty) produces ",(0,r.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"creating-user-defined-non-linear-aggregate-functions",children:"Creating user-defined non-linear aggregate functions"}),"\n",(0,r.jsx)(n.p,{children:"Currently user-defined non-linear aggregation functions are not\nsupported.  These may be added in the future."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);