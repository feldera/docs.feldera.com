"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8756],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>d});var s=r(96540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},88073:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"sql/binary","title":"Binary (Byte Array) Operations","description":"The BINARY and VARBINARY data types allows storage of binary strings.","source":"@site/docs/sql/binary.md","sourceDirName":"sql","slug":"/sql/binary","permalink":"/sql/binary","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Array Operations","permalink":"/sql/array"},"next":{"title":"Boolean Operations","permalink":"/sql/boolean"}}');var t=r(74848),i=r(28453);const a={},d="Binary (Byte Array) Operations",c={},o=[{value:"Binary literals",id:"binary-literals",level:2},{value:"Binary value operations",id:"binary-value-operations",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binary-byte-array-operations",children:"Binary (Byte Array) Operations"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"BINARY"})," and ",(0,t.jsx)(n.code,{children:"VARBINARY"})," data types allows storage of binary strings."]}),"\n",(0,t.jsx)(n.p,{children:"A binary string is a sequence of octets (or bytes). Binary strings are\ndistinguished from character strings in two ways. First, binary\nstrings specifically allow storing octets of value zero and other\n\u201cnon-printable\u201d octets (usually, octets outside the decimal range 32\nto 126).  Character strings disallow zero octets, and also disallow\nany other octet values and sequences of octet values that are invalid\naccording to the database's selected character set encoding.  Second,\noperations on binary strings process the actual bytes, whereas the\nprocessing of character strings depends on locale settings. In short,\nbinary strings are appropriate for storing data that the programmer\nthinks of as \u201craw bytes\u201d, whereas character strings are appropriate\nfor storing text."}),"\n",(0,t.jsx)(n.h2,{id:"binary-literals",children:"Binary literals"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"BINARY"})," and ",(0,t.jsx)(n.code,{children:"VARBINARY"})," literals are specified by string literals of\nhexadecimal digits with an ",(0,t.jsx)(n.code,{children:"x"})," prefix: ",(0,t.jsx)(n.code,{children:"x'45F0AB'"}),".  Such a literal\nmust have an even number of characters, and all characters must be\nlegal hexadecimal digits.  A multi-part literal can be specified as\nthe concatenation of multiple literals, e.g.: ",(0,t.jsx)(n.code,{children:"x'AB' 'CD'"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Converting a string to a binary value produces a binary value\ncontaining the bytes of the encoding of the characters of the string."}),"\n",(0,t.jsx)(n.h2,{id:"binary-value-operations",children:"Binary value operations"}),"\n",(0,t.jsxs)(n.p,{children:["Binary values support bitwise operations, although there is no syntax\nyet to express these operations.  They can be aggregated using the\naggregation functions ",(0,t.jsx)(n.code,{children:"BIT_AND"}),", ",(0,t.jsx)(n.code,{children:"BIT_OR"}),", and ",(0,t.jsx)(n.code,{children:"BIT_XOR"}),"."]}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Operation"}),(0,t.jsx)("th",{children:"Description"}),(0,t.jsx)("th",{children:"Examples"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"concat"}),(0,t.jsx)("code",{children:"||"})]}),(0,t.jsx)("td",{children:"Concatenation of binary values"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"x'ab' || x'cd'"})," => ",(0,t.jsx)("code",{children:"x'ABCD'"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"gunzip"}),(0,t.jsx)("code",{children:"GUNZIP"}),"(binary)"]}),(0,t.jsx)("td",{children:(0,t.jsxs)(n.p,{children:["Decompresses a binary string using the GZIP algorithm.\nIf the input data is not in the gzip format this function fails at runtime.\nThe output is the decompressed data as a ",(0,t.jsx)(n.code,{children:"VARCHAR"})," string.\nIf the input is NULL, NULL is returned."]})}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SELECT gunzip(x'1f8b08000000000000ff4b4bcd49492d4a0400218115ac07000000')"})," => ",(0,t.jsx)("code",{children:"feldera"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"left"}),(0,t.jsx)("code",{children:"LEFT ( binary, count )"})]}),(0,t.jsxs)("td",{children:["Returns first ",(0,t.jsx)("code",{children:"count"})," bytes in the byte array.  If any argument is ",(0,t.jsx)("code",{children:"NULL"}),", return ",(0,t.jsx)("code",{children:"NULL"}),"."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"left(x'abcdef', 2)"})," => ",(0,t.jsx)("code",{children:"abcd"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"md5"}),(0,t.jsx)("code",{children:"MD5"}),"(binary)"]}),(0,t.jsx)("td",{children:(0,t.jsxs)(n.p,{children:["Calculates an MD5 128-bit checksum of the argument and returns it as a hex ",(0,t.jsx)("code",{children:"VARCHAR"})," value.\nIf the input is NULL, NULL is returned."]})}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SELECT md5(x'0123456789ABCDEF')"})," => ",(0,t.jsx)("code",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"octet_length"}),(0,t.jsx)("code",{children:"OCTET_LENGTH"}),"(binary)"]}),(0,t.jsx)("td",{children:"Returns the number of bytes in the binary"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"OCTET_LENGTH(x'0abc')"})," => ",(0,t.jsx)("code",{children:"2"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"overlay"}),(0,t.jsx)("code",{children:"OVERLAY"}),"(binary1 PLACING binary2 FROM integer1 [ FOR integer2 ])"]}),(0,t.jsx)("td",{children:(0,t.jsx)(n.p,{children:"Generate a binary string that replaces substring of binary1 with binary2.\nThe substring of binary1 starts at the byte specified by integer1 and extends for integer2 bytes.\nIf integer1 is greater than the byte length of binary1, concatenation is performed.\nIf integer2 is smaller than the byte length of binary2, the substring still gets replaced by the entirety of binary2, producing a binary string with greater byte length than binary1"})}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SELECT overlay(x'1234567890'::bytea placing x'0203' from 2 for 3)"})," => ",(0,t.jsx)("code",{children:"x'12020390'"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"position"}),(0,t.jsx)("code",{children:"POSITION"}),"(binary1 IN binary2)"]}),(0,t.jsx)("td",{children:"Returns the position of the first occurrence of binary1 in binary2. The first offset is 1. If binary1 isn't found in binary2, 0 is returned"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"POSITION(x'20' IN x'102023')"})," => ",(0,t.jsx)("code",{children:"2"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"right"}),(0,t.jsx)("code",{children:"RIGHT ( binary, count )"})]}),(0,t.jsxs)("td",{children:["Returns last ",(0,t.jsx)("code",{children:"count"})," bytes in the byte array.  If any argument is ",(0,t.jsx)("code",{children:"NULL"}),", return ",(0,t.jsx)("code",{children:"NULL"}),"."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"right(x'abcdef', 2)"})," => ",(0,t.jsx)("code",{children:"cdef"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"substring"}),(0,t.jsx)("code",{children:"SUBSTRING"}),"(binary FROM integer)"]}),(0,t.jsx)("td",{children:"Generate a substring of binary starting at the given offset in bytes. The first offset is 1. If the start position integer is less than 1, it is treated as 1"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SUBSTRING(x'123456', 3)"})," => ",(0,t.jsx)("code",{children:"x'56'"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SUBSTRING"}),"(binary FROM integer1 FOR integer2)"]}),(0,t.jsx)("td",{children:"Generate a substring of binary starting at the given offset in bytes with the given length. The first offset is 1. If the start position integer is less than 1, it is treated as 1. Negative lengths or offsets larger than length return an empty result."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SUBSTRING(x'1234567890' FROM 3 FOR 2)"})," => ",(0,t.jsx)("code",{children:"x'5678'"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"to_hex"}),(0,t.jsx)("code",{children:"TO_HEX"}),"(binary)"]}),(0,t.jsxs)("td",{children:["Generate a ",(0,t.jsx)(n.code,{children:"VARCHAR"})," string describing the value in hexadecimal"]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"TO_HEX(x'0abc')"})," => ",(0,t.jsx)("code",{children:"'0ABC'"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"to_int"}),(0,t.jsx)("a",{id:"to_int"}),(0,t.jsx)("code",{children:"TO_INT"}),"(binary)"]}),(0,t.jsxs)("td",{children:["Generate an ",(0,t.jsx)(n.code,{children:"INT"})," value from the first 4 bytes of the ",(0,t.jsx)(n.code,{children:"binary"}),", where the 0-th byte is the MSB"]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"TO_INT(x'0abc')"})," => ",(0,t.jsx)("code",{children:"2748"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);