"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[5439],{11470:(e,n,r)=>{r.d(n,{A:()=>E});var i=r(96540),s=r(34164),a=r(23104),t=r(56347),l=r(205),c=r(57485),o=r(31682),u=r(70679);function d(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:r}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return d(e).map((({props:{value:e,label:n,attributes:r,default:i}})=>({value:e,label:n,attributes:r,default:i})))}(r);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function v({queryString:e=!1,groupId:n}){const r=(0,t.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(s),(0,i.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function f(e){const{defaultValue:n,queryString:r=!1,groupId:s}=e,a=h(e),[t,c]=(0,i.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:a}))),[o,d]=v({queryString:r,groupId:s}),[f,m]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,s]=(0,u.Dv)(n);return[r,(0,i.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:s}),x=(()=>{const e=o??f;return p({value:e,tabValues:a})?e:null})();(0,l.A)((()=>{x&&c(x)}),[x]);return{selectedValue:t,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),m(e)}),[d,m,a]),tabValues:a}}var m=r(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=r(74848);function w({className:e,block:n,selectedValue:r,selectValue:i,tabValues:t}){const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),o=e=>{const n=e.currentTarget,s=l.indexOf(n),a=t[s].value;a!==r&&(c(n),i(a))},u=e=>{let n=null;switch(e.key){case"Enter":o(e);break;case"ArrowRight":{const r=l.indexOf(e.currentTarget)+1;n=l[r]??l[0];break}case"ArrowLeft":{const r=l.indexOf(e.currentTarget)-1;n=l[r]??l[l.length-1];break}}n?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:t.map((({value:e,label:n,attributes:i})=>(0,g.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{l.push(e)},onKeyDown:u,onClick:o,...i,className:(0,s.A)("tabs__item",x.tabItem,i?.className,{"tabs__item--active":r===e}),children:n??e},e)))})}function b({lazy:e,children:n,selectedValue:r}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find((e=>e.props.value===r));return e?(0,i.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function j(e){const n=f(e);return(0,g.jsxs)("div",{className:(0,s.A)("tabs-container",x.tabList),children:[(0,g.jsx)(w,{...n,...e}),(0,g.jsx)(b,{...n,...e})]})}function E(e){const n=(0,m.A)();return(0,g.jsx)(j,{...e,children:d(e.children)},String(n))}},19365:(e,n,r)=>{r.d(n,{A:()=>t});r(96540);var i=r(34164);const s={tabItem:"tabItem_Ymn6"};var a=r(74848);function t({children:e,hidden:n,className:r}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(s.tabItem,r),hidden:n,children:e})}},28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var i=r(96540);const s={},a=i.createContext(s);function t(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(a.Provider,{value:n},e.children)}},97230:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"sql/recursion","title":"Mutually-Recursive Queries","description":"Recursive queries are a new feature in Feldera SQL and are still evolving. Syntax and","source":"@site/docs/sql/recursion.mdx","sourceDirName":"sql","slug":"/sql/recursion","permalink":"/sql/recursion","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Materialized Tables and Views","permalink":"/sql/materialized"},"next":{"title":"Ad-hoc SQL Queries","permalink":"/sql/ad-hoc"}}');var s=r(74848),a=r(28453),t=r(11470),l=r(19365);const c={},o="Mutually-Recursive Queries",u={},d=[{value:"Key Concepts of Recursive Views",id:"key-concepts-of-recursive-views",level:2},{value:"Defining Recursive Views with Forward Declarations",id:"defining-recursive-views-with-forward-declarations",level:3},{value:"Recursive View Definitions",id:"recursive-view-definitions",level:3},{value:"Semantics",id:"semantics",level:2},{value:"Debugging Recursive SQL",id:"debugging-recursive-sql",level:2},{value:"Bounding Recursion Depth",id:"bounding-recursion-depth",level:3},{value:"Supported and Unsupported Features",id:"supported-and-unsupported-features",level:2},{value:"Supported Constructs",id:"supported-constructs",level:3},{value:"Unsupported Constructs",id:"unsupported-constructs",level:3},{value:"Known Limitations",id:"known-limitations",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"mutually-recursive-queries",children:"Mutually-Recursive Queries"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Recursive queries are a new feature in Feldera SQL and are still evolving. Syntax and\nfunctionality may change in future versions."})}),"\n",(0,s.jsx)(n.p,{children:"Recursive computations are notoriously limited in standard SQL due to cumbersome syntax and limited expressivity.\nFeldera SQL introduces an intuitive and powerful syntax for recursive queries that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Removes the need for Common Table Expressions (CTEs) in recursive queries."}),"\n",(0,s.jsx)(n.li,{children:"Supports mutually recursive view definitions involving multiple views."}),"\n",(0,s.jsx)(n.li,{children:"Allows rich, non-monotonic queries in recursive view definitions, with a goal to support arbitrary queries in the future."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These enhancements make Feldera SQL Turing-complete, meaning recursive queries that never terminate can be written\u2014so\ncare must be taken when designing queries."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts-of-recursive-views",children:"Key Concepts of Recursive Views"}),"\n",(0,s.jsx)(n.h3,{id:"defining-recursive-views-with-forward-declarations",children:"Defining Recursive Views with Forward Declarations"}),"\n",(0,s.jsxs)(n.p,{children:["In Feldera SQL, recursive queries require ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Forward_declaration",children:"forward declarations"}),"\nwhen a view references itself or another view before their definition.\nA forward declaration specifies the view's name, column names, and column types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"DECLARE RECURSIVE VIEW CLOSURE(x INT, y INT);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This forward declaration states that ",(0,s.jsx)(n.code,{children:"CLOSURE"})," is a recursive view with two columns, ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"y"}),", both of type ",(0,s.jsx)(n.code,{children:"INT"}),".\nAs we will see next, we can use this view to compute a transitive closure of a graph recursively, where x and y\nare nodes in the graph."]}),"\n",(0,s.jsx)(n.h3,{id:"recursive-view-definitions",children:"Recursive View Definitions"}),"\n",(0,s.jsx)(n.p,{children:"Once declared, recursive views are defined using standard SQL syntax. Feldera SQL allows these views to\nreference each other recursively."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE EDGES(x INT, y INT);\n\n-- Define a local view STEP depending on CLOSURE and EDGES\nCREATE LOCAL VIEW STEP AS\nSELECT E.x, CLOSURE.y\nFROM EDGES E\nJOIN CLOSURE ON E.y = CLOSURE.x;\n\n-- Define the recursive view CLOSURE\nCREATE MATERIALIZED VIEW CLOSURE AS\n(SELECT * FROM EDGES)\nUNION\n(SELECT * FROM STEP);\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example we compute a transitive closure:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EDGES"})," represents the edges of a graph."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"CLOSURE"})," view represents the edges of a graph over the same nodes, such that CLOSURE is the transitive\nclosure of the EDGES graph."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Forward declarations are needed only when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A view is referenced before its definition."}),"\n",(0,s.jsx)(n.li,{children:"The view participates in mutual recursion."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if ",(0,s.jsx)(n.code,{children:"STEP"})," were not a local view, it would also require a forward declaration."]}),"\n",(0,s.jsx)(n.p,{children:"The type inferred by the compiler for the view based on the query must\nmatch the type of the declared view, including the column names."}),"\n",(0,s.jsx)(n.h2,{id:"semantics",children:"Semantics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Mutually recursive views start out empty and are computed iteratively until they reach a stable state\n(i.e., no further changes occur). This is the least fixed point semantics, which is common in programming\nlanguages but differs from recursion in standard SQL."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["All mutually recursive views are automatically treated as ",(0,s.jsx)(n.code,{children:"DISTINCT"})," (e.g., as if they have a ",(0,s.jsx)(n.code,{children:"SELECT DISTINCT"})," in their\ndefinition) to avoid infinite growth due to duplicate rows. Without these restrictions, (and if we replace ",(0,s.jsx)(n.code,{children:"UNION"}),"\nwith ",(0,s.jsx)(n.code,{children:"UNION ALL"})," in the view definition), the program that computes ",(0,s.jsx)(n.code,{children:"CLOSURE"})," above would never terminate and the\n",(0,s.jsx)(n.code,{children:"CLOSURE"})," table would keep growing, accumulating duplicate edges."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We can verify this using our previous program and using the ",(0,s.jsx)(n.a,{href:"/interface/cli",children:"Feldera Shell"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"INSERT INTO EDGES VALUES(0, 1);\nSELECT * FROM CLOSURE;\n x | y\n-------\n 0 | 1\n(1 row)\nINSERT INTO EDGES VALUES(1, 2);\nSELECT * FROM CLOSURE;\n x | y\n-------\n 0 | 1\n 1 | 2\n 0 | 2\n(3 rows)\nDELETE * FROM EDGES WHERE x = 0;\nSELECT * FROM CLOSURE;\n x | y\n-------\n 1 | 2\n(1 row)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"debugging-recursive-sql",children:"Debugging Recursive SQL"}),"\n",(0,s.jsx)(n.p,{children:"SQL with non-terminating or long-running recursion should be avoided. e.g., the following SQL will attempt to\ncreate a view that computes all Fibonacci numbers. However, this program will fail (due to overflow) once\nit reaches values that do not fit into a 32-bit integer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"declare recursive view fibonacci(n int, value int);\n\ncreate view fibonacci as\n(\n    -- Base case: first two Fibonacci numbers\n    select 0 as n, 0 as value\n    union all\n    select 1 as n, 1 as value\n)\nunion all\n(\n    -- Compute F(n)=F(n-1)+F(n-2)\n    select\n        curr.n + 1 as n,\n        (prev.value + curr.value) as value\n    from fibonacci as curr\n    join fibonacci as prev\n    on prev.n = curr.n - 1\n);\n\ncreate view fib_outputs as select * from fibonacci;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Recursive computations are evaluated in a single ",(0,s.jsx)(n.a,{href:"https://www.feldera.com/blog/synchronous-streaming",children:"circuit step"}),",\nso there\u2019s no intermediate output in the change stream. This can make debugging recursive queries challenging."]}),"\n",(0,s.jsxs)(n.p,{children:["To debug, you can use a ",(0,s.jsx)(n.a,{href:"/sql/udf",children:"a UDF"}),". For example, modify the previous example to use a Rust function that\nprints each invocation of the fibonacci view during recursion:"]}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(l.A,{value:"program.sql",label:"program.sql",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create function logger(n int not null, value int not null) returns int not null;\ndeclare recursive view fibonacci(n int not null, value int not null);\n\ncreate view fibonacci as\n(\n    -- Base case: first two Fibonacci numbers\n    select 0 as n, 0 as value\n    union all\n    select 1 as n, 1 as value\n)\nunion all\n(\n    -- Compute F(n)=F(n-1)+F(n-2)\n    select\n        logger(curr.n + 1, prev.value + curr.value) as n,\n        (prev.value + curr.value) as value\n    from fibonacci as curr\n    join fibonacci as prev\n    on prev.n = curr.n - 1\n);\n\ncreate view fib_outputs as select * from fibonacci;\n"})})}),(0,s.jsx)(l.A,{value:"udf.toml",label:"udf.toml",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'log = "0.4"\n'})})}),(0,s.jsx)(l.A,{value:"udf.rs",label:"udf.rs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'pub fn logger(n: i32, v: i32) -> Result<i32, Box<dyn std::error::Error>> {\n    log::info!("n={n} v={v}");\n    Ok(n)\n}\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"If we run the pipeline and inspect the log we now can see the following output before the pipeline crashes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"...\n2024-11-21 00:36:16 INFO [pipeline-01934bea-8b46-71c2-9809-7eacf89f926d] n=44 v=701408733\n2024-11-21 00:36:16 INFO [pipeline-01934bea-8b46-71c2-9809-7eacf89f926d] n=45 v=1134903170\n2024-11-21 00:36:16 INFO [pipeline-01934bea-8b46-71c2-9809-7eacf89f926d] n=46 v=1836311903\n"})}),"\n",(0,s.jsx)(n.p,{children:"The 46-th fibonacci value is the last one that fits in a 32-bit integer."}),"\n",(0,s.jsx)(n.h3,{id:"bounding-recursion-depth",children:"Bounding Recursion Depth"}),"\n",(0,s.jsxs)(n.p,{children:["The fix is to bound the recursion depth, e.g., by adding a ",(0,s.jsx)(n.code,{children:"WHERE"})," clause to the ",(0,s.jsx)(n.code,{children:"fibonacci"})," view:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"declare recursive view fibonacci(n int not null, value int not null);\n\ncreate view fibonacci as\n(\n    -- Base case: first two Fibonacci numbers\n    select 0 as n, 0 as value\n    union all\n    select 1 as n, 1 as value\n)\nunion all\n(\n    -- Compute F(n)=F(n-1)+F(n-2)\n    select\n        curr.n + 1 as n,\n        (prev.value + curr.value) as value\n    from fibonacci as curr\n    join fibonacci as prev\n    on prev.n = curr.n - 1\n    where curr.n <= 45\n);\n\ncreate view fib_outputs as select * from fibonacci;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"supported-and-unsupported-features",children:"Supported and Unsupported Features"}),"\n",(0,s.jsx)(n.h3,{id:"supported-constructs",children:"Supported Constructs"}),"\n",(0,s.jsx)(n.p,{children:"Feldera supports a wide range of operators in recursive queries, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SELECT"}),", ",(0,s.jsx)(n.code,{children:"WHERE"}),", ",(0,s.jsx)(n.code,{children:"GROUP BY"}),", ",(0,s.jsx)(n.code,{children:"HAVING"})]}),"\n",(0,s.jsxs)(n.li,{children:["All types of ",(0,s.jsx)(n.code,{children:"JOINs"})]}),"\n",(0,s.jsxs)(n.li,{children:["Aggregations, ",(0,s.jsx)(n.code,{children:"DISTINCT"}),", ",(0,s.jsx)(n.code,{children:"UNION"}),", ",(0,s.jsx)(n.code,{children:"INTERSECT"}),", ",(0,s.jsx)(n.code,{children:"EXCEPT"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UNNEST"}),", ",(0,s.jsx)(n.code,{children:"VALUES"}),", ",(0,s.jsx)(n.code,{children:"PIVOT"})]}),"\n",(0,s.jsxs)(n.li,{children:["Table functions like ",(0,s.jsx)(n.code,{children:"HOP"})," and ",(0,s.jsx)(n.code,{children:"TUMBLE"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It is also possible to create a recursive ",(0,s.jsxs)(n.a,{href:"/sql/materialized",children:[(0,s.jsx)(n.em,{children:"materialized"})," view"]}),", which stores the result of\nthe recursive computation for ",(0,s.jsx)(n.a,{href:"/sql/ad-hoc",children:"ad-hoc queries"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"unsupported-constructs",children:"Unsupported Constructs"}),"\n",(0,s.jsx)(n.p,{children:"The following are currently not supported in recursive queries:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Window functions (e.g., ",(0,s.jsx)(n.code,{children:"OVER"})," clauses)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"known-limitations",children:"Known Limitations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Recursive queries mixed with ",(0,s.jsx)(n.a,{href:"streaming",children:"streaming annotations"})," currently can not leverage garbage collection."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);