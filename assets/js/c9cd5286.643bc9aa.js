"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[9221],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var t=s(96540);const r={},i=t.createContext(r);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(i.Provider,{value:n},e.children)}},94857:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"sql/udf","title":"User-Defined Functions","description":"The SQL statement CREATE FUNCTION can be used to declare new","source":"@site/docs/sql/udf.md","sourceDirName":"sql","slug":"/sql/udf","permalink":"/sql/udf","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"System Views","permalink":"/sql/system"},"next":{"title":"Connectors: connect to data sources and sinks","permalink":"/connectors/"}}');var r=s(74848),i=s(28453);const d={},l="User-Defined Functions",c={},o=[{value:"User-defined functions written in SQL",id:"user-defined-functions-written-in-sql",level:2},{value:"User-defined functions written in Rust",id:"user-defined-functions-written-in-rust",level:2},{value:"Step 1: Declare a function in the SQL program using <code>CREATE FUNCTION</code>",id:"step-1-declare-a-function-in-the-sql-program-using-create-function",level:3},{value:"Step 2: Locate the auto-generated Rust prototype",id:"step-2-locate-the-auto-generated-rust-prototype",level:3},{value:"Step 3: Implement the UDF in Rust",id:"step-3-implement-the-udf-in-rust",level:3},{value:"Step 4: Deploy the UDF",id:"step-4-deploy-the-udf",level:3},{value:"Using Feldera CLI:",id:"using-feldera-cli",level:4},{value:"Using Feldera Python SDK",id:"using-feldera-python-sdk",level:4},{value:"Using the REST API",id:"using-the-rest-api",level:4},{value:"SQL type representation in Rust",id:"sql-type-representation-in-rust",level:3},{value:"Return types",id:"return-types",level:3},{value:"Developing complex UDFs",id:"developing-complex-udfs",level:3},{value:"Limitations",id:"limitations",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"user-defined-functions",children:"User-Defined Functions"})}),"\n",(0,r.jsxs)(n.p,{children:["The SQL statement ",(0,r.jsx)(n.code,{children:"CREATE FUNCTION"})," can be used to declare new\nfunctions.  Functions can be implemented either in SQL or in Rust."]}),"\n",(0,r.jsx)(n.h2,{id:"user-defined-functions-written-in-sql",children:"User-defined functions written in SQL"}),"\n",(0,r.jsx)(n.p,{children:"The following example shows a user-defined function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION contains_number(str VARCHAR NOT NULL, value INTEGER)\nRETURNS BOOLEAN NOT NULL\nAS (str LIKE ('%' || CAST(value AS VARCHAR) || '%'));\n\nCREATE VIEW V0 AS SELECT contains_number(CAST('YES: 10 NO:5' AS VARCHAR), 5)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"user-defined-functions-written-in-rust",children:"User-defined functions written in Rust"}),"\n",(0,r.jsx)(n.admonition,{title:"Experimental feature",type:"warning",children:(0,r.jsx)(n.p,{children:"Rust UDF support is currently experimental and may undergo significant changes, including\nnon-backward-compatible modifications, in future releases of Feldera."})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Feldera's incremental query engine assumes that all computations are deterministic. Using\na non-deterministic UDF is likely to result in incorrect outputs. The SQL compiler cannot verify\nthat Rust functions meet this requirement. Therefore, it is the responsibility of the UDF\ndeveloper to ensure that their UDFs are deterministic, i.e., the function's return value\nmust depend solely on its arguments and not on clocks, random number generators, external\ndata sources, or other sources of non-determinism."}),"\n",(0,r.jsxs)(n.p,{children:["We are considering adding support for non-deterministic UDFs in the future. If your use case\nrequires a non-deterministic UDF, please share your feedback by commenting on the associated\n",(0,r.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues/2619",children:"GitHub issue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["UDFs are compiled into native binary code and executed directly within the address space of\nthe pipeline. Therefore, only trusted code should be included in UDFs.  UDFs should not contain\npanics or invoke undefined behaviors. These can lead to crashes, memory corruption, or\nunpredictable behavior within the pipeline.  UDFs should handle all runtime errors gracefully,\nby returning a ",(0,r.jsx)(n.code,{children:"Result::Err()"})," (",(0,r.jsx)(n.a,{href:"#return-types",children:"see below"}),"). This ensures that errors are\npropagated in a controlled manner and can be handled by the calling code."]}),"\n"]}),"\n"]})}),"\n",(0,r.jsx)(n.p,{children:"Feldera supports UDFs implemented in Rust. To define a UDF, users declare the function\nin SQL without providing a body. The corresponding Rust implementation is supplied in a separate\nRust file, which contains the logic for all UDFs declared within the SQL program. A complete\nset of files that defines the pipeline in this case is:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"File"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"program.sql"})}),(0,r.jsx)(n.td,{children:"The SQL code, including table, view, and user-defined function declarations."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"stubs.rs"})}),(0,r.jsxs)(n.td,{children:["Auto-generated by the SQL compiler; contains Rust stubs for UDFs (",(0,r.jsx)(n.a,{href:"#step-2-locate-the-auto-generated-rust-prototype",children:"see below"}),")."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"udf.rs"})}),(0,r.jsx)(n.td,{children:"User-provided implementation of UDFs in Rust."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"udf.toml"})}),(0,r.jsxs)(n.td,{children:["User-provided list of external crates required by the code in ",(0,r.jsx)(n.code,{children:"udf.rs"}),". This list is appended to the ",(0,r.jsx)(n.code,{children:"[dependencies]"})," section of the ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," file."]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["We recommend using the Web Console to develop and debug Rust UDFs, as described\nbelow.  The Web Console code editor has a separate tab for each of these files,\nand supports an interactive development workflow.  Once ready, the creation and\ndeployment of the pipeline can be automated with scripts that make use of the\n",(0,r.jsx)(n.a,{href:"#using-feldera-cli",children:"Feldera CLI"}),", the ",(0,r.jsx)(n.a,{href:"#using-feldera-python-sdk",children:"Python API"}),",\nor the ",(0,r.jsx)(n.a,{href:"#using-the-rest-api",children:"REST API"}),".  These scripts and the SQL/Rust code can\nthen be maintained with the usual practices such as version control."]}),"\n",(0,r.jsxs)(n.h3,{id:"step-1-declare-a-function-in-the-sql-program-using-create-function",children:["Step 1: Declare a function in the SQL program using ",(0,r.jsx)(n.code,{children:"CREATE FUNCTION"})]}),"\n",(0,r.jsx)(n.p,{children:"Declare a SQL function without a body:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- UDF which encodes text in base64.\nCREATE FUNCTION base64(s VARBINARY) RETURNS VARCHAR;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-locate-the-auto-generated-rust-prototype",children:"Step 2: Locate the auto-generated Rust prototype"}),"\n",(0,r.jsxs)(n.p,{children:["When the SQL compiler encounters such a function, it generates a Rust stub for it in the ",(0,r.jsx)(n.code,{children:"stubs.rs"}),"\nfile.  The stub is an implementation of the UDF in Rust that simply invokes another function with the\nsame name and signature exported from the ",(0,r.jsx)(n.code,{children:"udf.rs"})," module:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/* stubs.rs */\n...\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    udf::base64(\n        s)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"udf::base64"})," function does not exist yet, so you will see a Rust compiler error similar to this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" error[E0425]: cannot find function `base64` in module `udf`\n  --\x3e project01926e00-f404-7813-b65c-d66ac9959998/src/stubs.rs:11:10\n   |\n11 |     udf::base64(\n   |          ^^^^^^ not found in `udf`\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-implement-the-udf-in-rust",children:"Step 3: Implement the UDF in Rust"}),"\n",(0,r.jsxs)(n.p,{children:["Copy the declaration from ",(0,r.jsx)(n.code,{children:"stubs.rs"})," to ",(0,r.jsx)(n.code,{children:"udf.rs"})," and replace its body with the actual implementation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/* udf.rs */\nuse feldera_sqllib::*;\nuse base64::prelude::*;\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<SqlString>, Box<dyn std::error::Error>> {\n    Ok(s.map(|v| SqlString::from_ref(BASE64_STANDARD.encode(v.as_slice()))))\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"use feldera_sqllib::*"})," directive imports the definitions of the\nRust types that the compiler uses to implement some of the SQL\ndatatypes.  The next section explains what these types are."]}),"\n",(0,r.jsxs)(n.p,{children:["If your UDF uses external crates, list these external dependencies in ",(0,r.jsx)(n.code,{children:"udf.toml"}),".\nThe contents of this file is appended to the ",(0,r.jsx)(n.code,{children:"[dependencies]"})," section in the generated\n",(0,r.jsx)(n.code,{children:"Cargo.toml"})," file."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'base64 = "0.22.1"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-deploy-the-udf",children:"Step 4: Deploy the UDF"}),"\n",(0,r.jsxs)(n.h4,{id:"using-feldera-cli",children:["Using ",(0,r.jsx)(n.a,{href:"/interface/cli",children:"Feldera CLI"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fda create udf_fda_test --udf-rs udf.rs --udf-toml udf.toml program.sql\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"using-feldera-python-sdk",children:["Using ",(0,r.jsx)(n.a,{href:"pathname:///python/",children:"Feldera Python SDK"})]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Click to see how to create a pipeline with a Rust UDF using the Feldera Python SDK"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from feldera import FelderaClient, PipelineBuilder\n\n# SQL program.\nsql = """\n-- UDF which encodes text in base64.\nCREATE FUNCTION base64(s VARBINARY) RETURNS VARCHAR;\n\nCREATE TABLE binary_t(\n    b VARBINARY\n);\n\nCREATE MATERIALIZED VIEW base64_v AS\nSELECT\n    base64(b) as text\nFROM\n    binary_t;\n"""\n\n# UDF implementation in Rust.\nudf_rust = """\nuse feldera_sqllib::*;\nuse base64::prelude::*;\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    Ok(s.map(|v| BASE64_STANDARD.encode(v.as_slice())))\n}"""\n\n# External Rust dependencies.\nudf_toml = """\nbase64 = "0.22.1"\n"""\n\n# Create a pipeline using the above SQL, Rust, and TOML code.\nfeldera = FelderaClient("http://127.0.0.1:8080")\npipeline = PipelineBuilder(\n    feldera, name="udf_test", sql=sql, udf_rust=udf_rust, udf_toml = udf_toml).create_or_replace()\n\npipeline.start()\n\nnext(pipeline.query("insert into binary_t values(X\'0123456789ABCDEF\')"))\noutput = pipeline.query("select * from base64_v")\n\nassert list(output) == [{\'text\': \'ASNFZ4mrze8=\'}]\n\npipeline.shutdown()\npipeline.delete()\n'})})]}),"\n",(0,r.jsxs)(n.h4,{id:"using-the-rest-api",children:["Using the ",(0,r.jsx)(n.a,{href:"/api",children:"REST API"})]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Click to see how to create a pipeline with a Rust UDF using the Feldera REST API"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n\necho "\n-- UDF which encodes text in base64.\nCREATE FUNCTION base64(s VARBINARY) RETURNS VARCHAR;\n\nCREATE TABLE binary_t(\n    b VARBINARY\n);\n\nCREATE MATERIALIZED VIEW base64_v AS\nSELECT\n    base64(b) as text\nFROM\n    binary_t;\n" > program.sql\n\necho "\nuse feldera_sqllib::*;\nuse base64::prelude::*;\n\npub fn base64(s: Option<ByteArray>) -> Result<Option<String>, Box<dyn std::error::Error>> {\n    Ok(s.map(|v| BASE64_STANDARD.encode(v.as_slice())))\n}" > udf.rs\n\necho "\nbase64 = \\"0.22.1\\"\n" > udf.toml\n\n\ncurl -i -X PUT http://127.0.0.1:8080/v0/pipelines/udf_api_test \\\n-H \'Content-Type: application/json\' \\\n-d "$(jq -Rsn \\\n  --rawfile sql program.sql \\\n  --rawfile udf_rust udf.rs \\\n  --rawfile udf_toml udf.toml \\\n  \'{\n    name: "udf_api_test",\n    description: "Create a UDF using REST API",\n    program_code: $sql,\n    runtime_config: {},\n    program_config: {},\n    udf_rust: $udf_rust,\n    udf_toml: $udf_toml\n  }\')"\n'})})]}),"\n",(0,r.jsx)(n.h3,{id:"sql-type-representation-in-rust",children:"SQL type representation in Rust"}),"\n",(0,r.jsx)(n.admonition,{title:"Experimental feature",type:"caution"}),"\n",(0,r.jsxs)(n.p,{children:["The following table shows the Rust representation of standard SQL data\ntypes.  A nullable SQL type is represented by the corresponding rust\n",(0,r.jsx)(n.code,{children:"Option<>"})," type.  Notice that some of these types are not standard\nRust types, but are defined in the\n",(0,r.jsx)(n.a,{href:"https://docs.rs/feldera-sqllib/0.27.0/feldera_sqllib/",children:"feldera-sqllib"}),"\ncrate, which is part of the Feldera SQL runtime."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"SQL"}),(0,r.jsx)(n.th,{children:"Rust"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BOOLEAN"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TINYINT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i8"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SMALLINT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i16"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i32"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BIGINT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i64"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TINYINT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u8"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SMALLINT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u16"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u32"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BIGINT UNSIGNED"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"u64"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DECIMAL(p, s)"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::SqlDecimal<P, S>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"REAL"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::F32"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DOUBLE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::F64"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"CHAR"}),", ",(0,r.jsx)(n.code,{children:"CHAR(n)"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::SqlString"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"VARCHAR"}),", ",(0,r.jsx)(n.code,{children:"VARCHAR(n)"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::SqlString"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"BINARY"}),", ",(0,r.jsx)(n.code,{children:"BINARY(n)"}),", ",(0,r.jsx)(n.code,{children:"VARBINARY"}),", ",(0,r.jsx)(n.code,{children:"VARBINARY(n)"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::ByteArray"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NULL"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"()"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INTERVAL"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"feldera_sqllib::ShortInterval"}),", ",(0,r.jsx)(n.code,{children:"feldera_sqllib::LongInterval"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TIME"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Time"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TIMESTAMP"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Timestamp"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DATE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Date"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"T ARRAY"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Array<T>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"MAP<K, V>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Map<K, V>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"UUID"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Uuid"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"VARIANT"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feldera_sqllib::Variant"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ROW"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Tup"}),"N"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"User-defined struct type"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Tup"}),"N"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Multiple SQL types may be represented by the same Rust type.  For\nexample, ",(0,r.jsx)(n.code,{children:"CHAR"}),", ",(0,r.jsx)(n.code,{children:"CHAR(n)"}),", ",(0,r.jsx)(n.code,{children:"VARCHAR(n)"}),", and ",(0,r.jsx)(n.code,{children:"VARCHAR"})," are all\nrepresented by the ",(0,r.jsx)(n.code,{children:"SqlString"})," type."]}),"\n",(0,r.jsxs)(n.p,{children:["The SQL family of ",(0,r.jsx)(n.code,{children:"INTERVAL"})," types translates to one of two Rust\ntypes: ",(0,r.jsx)(n.code,{children:"ShortInterval"})," (representing intervals from days to seconds),\nand ",(0,r.jsx)(n.code,{children:"LongInterval"})," (representing intervals from years to months).\n(Our dialect of SQL does not allow mixing the two kinds of intervals\nin a single expression.)"]}),"\n",(0,r.jsxs)(n.p,{children:["Currently ",(0,r.jsx)(n.code,{children:"feldera_sqlllib::Map"})," is defined as ",(0,r.jsx)(n.code,{children:"type Map = Arc<BTreeMap>"}),", and ",(0,r.jsx)(n.code,{children:"feldera_sqlllib::Array"})," is defined as ",(0,r.jsx)(n.code,{children:"type Array = Arc<Vec>"}),".  Currently ",(0,r.jsx)(n.code,{children:"feldera_sqlllib::SqlString"})," is a thin wrapper\ntype around the ",(0,r.jsx)(n.code,{children:"ArcStr"})," type from the ",(0,r.jsx)(n.code,{children:"arcstr"})," crate."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"ROW"})," type with N fields represented by a Rust ",(0,r.jsx)(n.code,{children:"Tup"}),"N datatype.  A\nuser-defined structure type is also represented by a tuple ",(0,r.jsx)(n.code,{children:"Tup"}),"N\ntype.  These tuple types can be imported from the current crate."]}),"\n",(0,r.jsxs)(n.p,{children:["Here are some examples using ",(0,r.jsx)(n.code,{children:"ROW"})," and user-defined types:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE X AS (x int);\nCREATE FUNCTION f(arg X) RETURNS X;\nCREATE FUNCTION g(x int NOT NULL) RETURNS ROW(a INT, b INT) NOT NULL;\nCREATE VIEW V AS SELECT f(X(1)), g(2).a;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And here is a possible implementation of the used-defined functions\n",(0,r.jsx)(n.code,{children:"f"})," and ",(0,r.jsx)(n.code,{children:"g"})," in Rust:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use crate::{Tup1, Tup2};\nuse feldera_sqllib::*;\npub fn f(x: Option<Tup1<Option<i32>>>) ->\n   Result<Option<Tup1<Option<i32>>>, Box<dyn std::error::Error>> {\n   match x {\n      None => Ok(None),\n      Some(x) => match x.0 {\n         None => Ok(Some(Tup1::new(None))),\n         Some(x) => Ok(Some(Tup1::new(Some(x + 1)))),\n      }\n   }\n}\n\npub fn g(x: i32) -> Result<Tup2<i32, i32>, Box<dyn std::error::Error>> {\n   Ok(Tup2::new(x-1, x+1))\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"return-types",children:"Return types"}),"\n",(0,r.jsxs)(n.p,{children:["In the Rust implementation the function always has to return the type\n",(0,r.jsx)(n.code,{children:"Result<T, Box<dyn std::error::Error>>"}),", where ",(0,r.jsx)(n.code,{children:"T"})," is the Rust\nequivalent of the expected return type of the SQL function.  The Rust\nfunction should return an ",(0,r.jsx)(n.code,{children:"Err"})," only when the function fails at\nruntime with a fatal condition, e.g., array index out of\nbounds, arithmetic overflows, etc."]}),"\n",(0,r.jsx)(n.h3,{id:"developing-complex-udfs",children:"Developing complex UDFs"}),"\n",(0,r.jsxs)(n.p,{children:["While many useful UDFs can be implemented with just a few lines of Rust,\nsome may require more complex code that is easier to develop\nusing a full-featured Rust IDE.  To support the development of such\nUDFs, we made the ",(0,r.jsx)(n.code,{children:"feldera-sqllib"})," crate available on\n",(0,r.jsx)(n.a,{href:"https://crates.io/crates/feldera-sqllib",children:"crates.io"}),".\nIn order to implement a complex Rust UDF (or a library of UDFs) using\na Rust IDE:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create a new Rust crate to serve as the container for your UDFs."}),"\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.code,{children:"feldera-sqllib"})," as a dependency to ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," (use the crate\nversion that matches the version of Feldera you are working with)."]}),"\n",(0,r.jsx)(n.li,{children:"Implement and test your UDFs within this crate."}),"\n",(0,r.jsx)(n.li,{children:"Copy the final Rust code and dependencies to the Feldera Web Console."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If your UDFs require a larger Rust project with multiple modules, we\nrecommend encapsulating the majority of the UDF logic in a crate.\nThis crate can be hosted on ",(0,r.jsx)(n.a,{href:"https://crates.io/",children:"crates.io"})," or GitHub.\nImport this crate to your Feldera pipeline via the ",(0,r.jsx)(n.code,{children:"udf.toml"})," file,\nincluding only wrapper functions that call the API of this crate in\n",(0,r.jsx)(n.code,{children:"udf.rs"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Currently only limited implicit casts are inserted by the compiler for the\nfunction arguments and function result in the SQL program.  For\nexample, a call such as ",(0,r.jsx)(n.code,{children:"CONTAINS_NUMBER('2010-10-20', '5')"})," will\nfail at SQL compilation time because the first argument has type\n",(0,r.jsx)(n.code,{children:"CHAR(8)"})," instead of ",(0,r.jsx)(n.code,{children:"VARCHAR"}),", and the second argument has type\n",(0,r.jsx)(n.code,{children:"CHAR(1)"})," instead of ",(0,r.jsx)(n.code,{children:"INTEGER"}),".  This can be avoided by calling the\nfunction using an explicit cast: ",(0,r.jsx)(n.code,{children:"CONTAINS_NUMBER(CAST('2010-10-20' AS VARCHAR), CAST('5' AS INTEGER))"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"User-defined functions cannot have names identical to standard SQL\nlibrary function names."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Polymorphic functions are not supported.  For example, in SQL the\naddition operation operates on any numeric types; such an operation\ncannot be implemented as a single user-defined function."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);