"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[1689],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(96540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},65841:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"connectors/orchestration","title":"Input connector orchestration","description":"Connector Orchestration enables users to activate or deactivate input connectors","source":"@site/docs/connectors/orchestration.md","sourceDirName":"connectors","slug":"/connectors/orchestration","permalink":"/connectors/orchestration","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Uniqueness Constraints","permalink":"/connectors/unique_keys"},"next":{"title":"Synchronous Processing with Completion Tokens","permalink":"/connectors/completion-tokens"}}');var s=t(74848),o=t(28453);const i={},c="Input connector orchestration",a={},d=[{value:"Orchestration example",id:"orchestration-example",level:2},{value:"Detecting when a connector has finished ingesting data",id:"detecting-when-a-connector-has-finished-ingesting-data",level:2},{value:"Automatic connector orchestration",id:"automatic-connector-orchestration",level:2},{value:"Labels",id:"labels",level:3},{value:"Configuring the order of connector activation using <code>start_after</code>",id:"configuring-the-order-of-connector-activation-using-start_after",level:3},{value:"Example",id:"example",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"input-connector-orchestration",children:"Input connector orchestration"})}),"\n",(0,s.jsx)(n.p,{children:"Connector Orchestration enables users to activate or deactivate input connectors\non demand, giving them control over the timing and order of data ingestion from\nmultiple sources. It can, for example, be used to backfill a pipeline with\nhistorical data from a database or data lake before switching over to real-time\ningestion from a streaming source like Kafka."}),"\n",(0,s.jsxs)(n.p,{children:["Input connectors can be in either the ",(0,s.jsx)(n.code,{children:"Running"})," or ",(0,s.jsx)(n.code,{children:"Paused"})," state. By default,\nconnectors are initialized in the ",(0,s.jsx)(n.code,{children:"Running"})," state when a pipeline is deployed.\nIn this state, the connector actively fetches data from its configured data\nsource and forwards it to the pipeline. If needed, a connector can be created\nin the ",(0,s.jsx)(n.code,{children:"Paused"})," state by setting its\n",(0,s.jsx)(n.a,{href:"/connectors/#generic-attributes",children:(0,s.jsx)(n.code,{children:"paused"})})," property\nto ",(0,s.jsx)(n.code,{children:"true"}),".\nThe current connector state can be retrieved via the\n",(0,s.jsx)(n.a,{href:"/api/retrieve-circuit-metrics-of-a-running-or-paused-pipeline",children:"pipeline statistics endpoint"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When paused, the connector remains idle until it is reactivated.\nConversely, a connector in the ",(0,s.jsx)(n.code,{children:"Running"})," state can be paused at any time.\nThis can be done by calling its\n",(0,s.jsx)(n.a,{href:"/api/start-resume-or-pause-the-input-connector",children:"start/pause endpoint"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that only if both the pipeline ",(0,s.jsx)(n.em,{children:"and"})," the connector state is ",(0,s.jsx)(n.code,{children:"Running"}),",\nis the input connector active. The following table illustrates this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Pipeline state    Connector state    Connector is active?\n--------------    ---------------    --------------------\nPaused            Paused             No\nPaused            Running            No\nRunning           Paused             No\nRunning           Running            Yes\n"})}),"\n",(0,s.jsx)(n.h2,{id:"orchestration-example",children:"Orchestration example"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Create and start a pipeline named ",(0,s.jsx)(n.code,{children:"example"})," with the following SQL:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE numbers (\n  num INT\n) WITH (\n    \'connectors\' = \'[\n        {\n            "name": "c1",\n            "paused": true,\n            "transport": {\n                "name": "datagen",\n                "config": {"plan": [{ "rate": 1, "fields": { "num": { "range": [0, 10], "strategy": "uniform" } } }]}\n            }\n        },\n        {\n            "name": "c2",\n            "paused": false,\n            "transport": {\n                "name": "datagen",\n                "config": {"plan": [{ "rate": 1, "fields": { "num": { "range": [10, 20], "strategy": "uniform" } } }]}\n            }\n        }\n    ]\'\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.code,{children:"numbers"})," table has two input connectors, one of which has ",(0,s.jsx)(n.code,{children:"paused"})," property set to ",(0,s.jsx)(n.code,{children:"true"}),".\nThis connector will be created in the ",(0,s.jsx)(n.code,{children:"Paused"})," state."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Check the ",(0,s.jsx)(n.code,{children:"numbers"})," table checkbox in the Change Stream tab. Observe that although the pipeline is ",(0,s.jsx)(n.code,{children:"Running"}),",\nthe change stream only shows input records from connector ",(0,s.jsx)(n.code,{children:"c2"})," (i.e., ",(0,s.jsx)(n.code,{children:"[10, 20)"}),") but not of connector\n",(0,s.jsx)(n.code,{children:"c1"})," (i.e., ",(0,s.jsx)(n.code,{children:"[0, 10)"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Start connector ",(0,s.jsx)(n.code,{children:"c1"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fda connector example numbers c1 start\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now the Changes Stream tab will show new input records from both connectors."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Pause connector ",(0,s.jsx)(n.code,{children:"c2"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fda connector example numbers c2 pause\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now the Changes Stream tab no longer will show new input records from connector ",(0,s.jsx)(n.code,{children:"c2"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"detecting-when-a-connector-has-finished-ingesting-data",children:"Detecting when a connector has finished ingesting data"}),"\n",(0,s.jsxs)(n.p,{children:["A common use case for connector orchestration is loading historical data from a database before switching over to a real-time data source such as Kafka. To implement this scenario, we need to determine when the first connector has exhausted all its inputs. This can be achieved by polling the ",(0,s.jsx)(n.a,{href:"/api/retrieve-the-status-of-an-input-connector",children:"connector status endpoint"}),", which provides information about the connector's configuration and current state, including the following fields:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "endpoint_name": "project_memberships.datagen",\n  "config": {...},\n  "metrics": {\n    "buffered_records": 0,\n    "end_of_input": false,\n    ...\n  },\n  ...\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"end_of_input"}),": Indicates that the connector has received all available inputs from its data source and will not produce any more."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"buffered_records"}),": Tracks the number of input records received by the connector that have not been ingested by the pipeline yet."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Once ",(0,s.jsx)(n.code,{children:"end_of_input"})," is true and ",(0,s.jsx)(n.code,{children:"buffered_records"})," is 0, the pipeline will no longer receive any new inputs from the connector:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"fda connector my_pipeline my_table my_connector stats | jq '.metrics.end_of_input == true and .metrics.buffered_records == 0'\n"})}),"\n",(0,s.jsx)(n.p,{children:"Not all connectors reach the end of input. Some, like Pub/Sub, continuously wait for new data. Others signal the end of input depending on their configuration. The following table summarizes the end-of-input behavior for different input connectors:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Connector"}),(0,s.jsx)(n.th,{children:"Signals end-of-input"}),(0,s.jsx)(n.th,{children:"Comment"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/http-get",children:"HTTP GET"})}),(0,s.jsx)(n.td,{children:"yes"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/datagen",children:"Datagen"})}),(0,s.jsxs)(n.td,{children:["when ",(0,s.jsx)(n.code,{children:"limit"})," is set"]}),(0,s.jsx)(n.td,{children:"The Datagen connector stops producing inputs after reaching the specified record limit."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/debezium",children:"Debezium"})}),(0,s.jsx)(n.td,{children:"no"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/delta",children:"Delta Lake"})}),(0,s.jsxs)(n.td,{children:["when ",(0,s.jsx)(n.code,{children:"mode=snapshot"})]}),(0,s.jsxs)(n.td,{children:["When configured with ",(0,s.jsx)(n.code,{children:"mode=snapshot"}),", the DeltaLake connector signals the end of input after ingesting the specified snapshot of the table."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"File"}),(0,s.jsxs)(n.td,{children:["when ",(0,s.jsx)(n.code,{children:"follow=false"})]}),(0,s.jsxs)(n.td,{children:["When configured with ",(0,s.jsx)(n.code,{children:"follow=false"})," (the default), the file input connector signals the end of input after reading the current contents of the file; otherwise (",(0,s.jsx)(n.code,{children:"follow=true"}),"), the connector continues polling for new changes."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/iceberg",children:"Iceberg"})}),(0,s.jsx)(n.td,{children:"yes"}),(0,s.jsx)(n.td,{children:"Stops after reading a complete table snapshot."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/kafka",children:"Kafka"})}),(0,s.jsxs)(n.td,{children:["when ",(0,s.jsx)(n.code,{children:"enable.partition.eof"})]}),(0,s.jsx)(n.td,{children:"Otherwise, waits for new messages from the Kafka topic."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/pubsub",children:"Pub/Sub"})}),(0,s.jsx)(n.td,{children:"no"}),(0,s.jsx)(n.td,{children:"Waits for new messages from the Pub/Sub subscription."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/postgresql",children:"Postgres"})}),(0,s.jsx)(n.td,{children:"yes"}),(0,s.jsxs)(n.td,{children:["Stops after reading a complete table snapshot (use the ",(0,s.jsx)(n.a,{href:"/connectors/sources/debezium",children:"Debezium connector"})," for Change Data Capture)."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/connectors/sources/s3",children:"S3"})}),(0,s.jsx)(n.td,{children:"yes"}),(0,s.jsx)(n.td,{children:"Stops after reading all objects that match the specified prefix."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"automatic-connector-orchestration",children:"Automatic connector orchestration"}),"\n",(0,s.jsx)(n.p,{children:'Feldera allows encoding the order of connector activation directly in the SQL program.\nThis mechanism can express ordering constraints of the form "start connector\nC1 after connectors C1, C2, ... have finished ingesting all inputs".\nWhile less general than the mechanism described above, it covers most\npractical situations, while eliminating the need to write\nscripts to monitor and manage connector status via the API.'}),"\n",(0,s.jsx)(n.p,{children:"To configure automatic connector orchestration:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Assign labels to connectors based on their role."}),"\n",(0,s.jsxs)(n.li,{children:["Set the ",(0,s.jsx)(n.code,{children:"start_after"})," attribute to configure the order of connector activation."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"labels",children:"Labels"}),"\n",(0,s.jsx)(n.p,{children:"A connector can be assigned one or more text labels that reflect its role in the pipeline.\nFor example, the following label indicates that the connector is used\nto backfill the pipeline with historical data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'"labels": ["backfill"]\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"configuring-the-order-of-connector-activation-using-start_after",children:["Configuring the order of connector activation using ",(0,s.jsx)(n.code,{children:"start_after"})]}),"\n",(0,s.jsxs)(n.p,{children:["A connector can be configured with a ",(0,s.jsx)(n.code,{children:"start_after"})," attribute, which specifies\none or more labels, e.g.:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'"start_after": "backfill"\n'})}),"\n",(0,s.jsx)(n.p,{children:"or"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'"start_after": ["label1",  "label2"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Such a connector is created in the Paused state and is automatically activated once\nall connectors tagged with at least one of the specified labels have reached the end of input."}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(n.p,{children:["The Feldera Basics tutorial gives an example of a\n",(0,s.jsx)(n.a,{href:"/tutorials/basics/part3#configure-connectors",children:"table with two input connectors"}),".\nThe following snippet shows a modified version of this example where the\nsecond connector is configured to start after the first connector completes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'create table PRICE (\n    part bigint not null,\n    vendor bigint not null,\n    price integer\n) WITH (\'connectors\' = \'[{\n    "labels": ["price.backfill"],\n    "transport": {\n        "name": "url_input", "config": {"path": "https://feldera-basics-tutorial.s3.amazonaws.com/price.json"  }\n    },\n    "format": { "name": "json" }\n},\n{\n    "start_after": ["price.backfill"],\n    "format": {"name": "json"},\n    "transport": {\n        "name": "kafka_input",\n        "config": {\n            "topic": "price",\n            "start_from": "earliest",\n            "bootstrap.servers": "redpanda:9092"\n        }\n    }\n}]\');\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);