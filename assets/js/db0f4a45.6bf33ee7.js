"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[355],{17884:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"formats/raw","title":"Raw Format","description":"This page describes configuration options specific to the raw data format.","source":"@site/docs/formats/raw.md","sourceDirName":"formats","slug":"/formats/raw","permalink":"/formats/raw","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"CSV Format","permalink":"/formats/csv"},"next":{"title":"Lifecycle","permalink":"/pipelines/lifecycle"}}');var a=r(74848),s=r(28453);const o={},i="Raw Format",c={},l=[{value:"Configuring raw input connector",id:"configuring-raw-input-connector",level:2},{value:"Example",id:"example",level:3},{value:"Ingesting raw data via HTTP",id:"ingesting-raw-data-via-http",level:2},{value:"Example",id:"example-1",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"raw-format",children:"Raw Format"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This page describes configuration options specific to the raw data format.\nSee ",(0,a.jsx)(n.a,{href:"/connectors/",children:"top-level connector documentation"})," for general information\nabout configuring input and output connectors."]})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"raw"})," data format can be used to configure an input connector to pass\nraw, unparsed, data buffers from the ",(0,a.jsx)(n.a,{href:"/connectors/sources",children:"transport connector"})," to the SQL program.\nNormally the byte stream received from the transport connector is parsed using the specified data ",(0,a.jsx)(n.a,{href:"/formats",children:"format"}),",\ne.g., ",(0,a.jsx)(n.a,{href:"/formats/json",children:"JSON"})," or ",(0,a.jsx)(n.a,{href:"/formats/avro",children:"Avro"}),". The parser converts the raw byte stream into a stream\nof SQL table records.  In some cases it is preferable to pass the raw bytes to the SQL program unmodified and\nperform all parsing in SQL. In particular this is useful for:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Custom data formats:"})," If the required data format is not supported by built-in parsers, raw data can be\ningested into a SQL table and decoded using a ",(0,a.jsx)(n.a,{href:"/sql/udf",children:"UDF"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Parallelized parsing"}),": Parsing large volumes of incoming data can become a performance bottleneck.\nNormally parsing is performed by the input connector outside of the SQL runtime.\nMoving parsing into the SQL program enables it to leverage the parallelism in the Feldera\nSQL runtime."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The raw format is currently only supported for input connectors."}),"\n",(0,a.jsx)(n.p,{children:"Note that the raw format supports only inserting records into the table and does not support deletions.\nThis limitation exists because the raw data stream lacks the metadata to differentiate between inserts and deletes."}),"\n",(0,a.jsx)(n.h2,{id:"configuring-raw-input-connector",children:"Configuring raw input connector"}),"\n",(0,a.jsx)(n.p,{children:"In order to ingest raw data:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Declare a table with a single column of type ",(0,a.jsx)(n.code,{children:"VARBINARY [NOT NUL]"})," or ",(0,a.jsx)(n.code,{children:"VARCHAR [NOT NULL]"}),".  In the latter case, the connector\nwill parse input data as a UTF-8 string and will fail to parse chunks that are not valid UTF-8."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Configure an input connector with the format name ",(0,a.jsx)(n.code,{children:"raw"}),".  The connector currently supports a single configuration\noption, ",(0,a.jsx)(n.code,{children:"mode"}),", which can be set to:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"blob"})," (default) - ingest the entire data chunk received from the transport connector as a single SQL row.\nFor message-oriented transports, such as Kafka or Pub/Sub, an input chunk corresponds to a message.\nFor file-based transports, e.g., the ",(0,a.jsx)(n.a,{href:"/connectors/sources/http-get",children:"URL"})," connector or\nthe ",(0,a.jsx)(n.a,{href:"/connectors/sources/s3",children:"S3"})," connector, a chunk represents an entire file or object."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"lines"})," - split the input byte stream on the new line character (",(0,a.jsx)(n.code,{children:"\\n"}),") and ingest each line as a separate SQL row."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["When using the ",(0,a.jsx)(n.code,{children:"blob"})," mode with a file-oriented transport connector such as S3, the entire file or object is ingested\nas a single record.  This can require a lot of memory when reading large files."]})}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:"The following example shows a table with an input connector configured to ingest raw data from a URL line-by-line."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'create table raw_table(\n    data varchar\n) with (\n    \'connectors\' = \'[{\n        "format": {\n            "name": "raw",\n            "config": {\n                "mode": "lines"\n            }\n        },\n        "transport": {\n            "name": "url_input",\n            "config": {\n                "path": "https://feldera-basics-tutorial.s3.amazonaws.com/part.json"\n            }\n        }\n    }]\'\n);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"ingesting-raw-data-via-http",children:"Ingesting raw data via HTTP"}),"\n",(0,a.jsxs)(n.p,{children:["You can also push raw data to a pipeline via ",(0,a.jsx)(n.a,{href:"/connectors/sources/http",children:"HTTP"})," by specifying\n",(0,a.jsx)(n.code,{children:"format=json"})," and, optionally, ",(0,a.jsx)(n.code,{children:"mode=lines"})," in the request URL:"]}),"\n",(0,a.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["Create a pipeline called ",(0,a.jsx)(n.code,{children:"my_pipeline"})," with the following table declaration:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"create table raw_table(\n    data varchar\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Insert two records with values ",(0,a.jsx)(n.code,{children:"hello"})," and ",(0,a.jsx)(n.code,{children:"world"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"curl -i -X 'POST' \\\n  http://127.0.0.1:8080/v0/pipelines/my_pipeline/ingress/raw_table?format=raw&mode=lines \\\n  -d 'hello\n  world'\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(96540);const a={},s=t.createContext(a);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);