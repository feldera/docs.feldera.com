"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8209],{10655:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"tutorials/basics/part1","title":"Part 1: Writing and testing your first SQL pipeline","description":"In this section of the tutorial we will write and test our first SQL pipeline using Feldera.","source":"@site/docs/tutorials/basics/part1.md","sourceDirName":"tutorials/basics","slug":"/tutorials/basics/part1","permalink":"/tutorials/basics/part1","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Feldera Basics","permalink":"/tutorials/basics/"},"next":{"title":"Part 2: HTTP-based Input and Output","permalink":"/tutorials/basics/part2"}}');var s=t(74848),i=t(28453);const r={},l="Part 1: Writing and testing your first SQL pipeline",d={},c=[{value:"The use case",id:"the-use-case",level:2},{value:"Step 0. Launch Feldera",id:"step-0-launch-feldera",level:2},{value:"Step 1. Create a pipeline",id:"step-1-create-a-pipeline",level:2},{value:"Step 2. Insert data",id:"step-2-insert-data",level:2},{value:"Step 3. Observe pipeline outputs",id:"step-3-observe-pipeline-outputs",level:2},{value:"Step 4. Observe incremental changes",id:"step-4-observe-incremental-changes",level:2},{value:"Takeaways",id:"takeaways",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"part-1-writing-and-testing-your-first-sql-pipeline",children:"Part 1: Writing and testing your first SQL pipeline"})}),"\n",(0,s.jsx)(n.p,{children:"In this section of the tutorial we will write and test our first SQL pipeline using Feldera."}),"\n",(0,s.jsx)(n.h2,{id:"the-use-case",children:"The use case"}),"\n",(0,s.jsx)(n.p,{children:"We will build a pipeline that ingests data about\nvendors, parts, and prices, and continuously tracks the lowest available\nprice for each part across all vendors."}),"\n",(0,s.jsx)(n.h2,{id:"step-0-launch-feldera",children:"Step 0. Launch Feldera"}),"\n",(0,s.jsxs)(n.p,{children:["Make sure that you have Feldera up and running by following the ",(0,s.jsx)(n.a,{href:"/get-started/docker",children:"Getting\nStarted"})," guide.  Open the Feldera Web Console on\n",(0,s.jsx)(n.a,{href:"http://127.0.0.1:8080",children:"http://127.0.0.1:8080"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"step-1-create-a-pipeline",children:"Step 1. Create a pipeline"}),"\n",(0,s.jsx)(n.p,{children:'In the Feldera Web Console,\ncreate a new pipeline, called named "supply_chain", and paste the following code\nin the SQL editor:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"create table VENDOR (\n    id bigint not null primary key,\n    name varchar,\n    address varchar\n) with ('materialized' = 'true');\n\ncreate table PART (\n    id bigint not null primary key,\n    name varchar\n) with ('materialized' = 'true');\n\ncreate table PRICE (\n    part bigint not null,\n    vendor bigint not null,\n    price integer\n) with ('materialized' = 'true');\n\n-- Lowest available price for each part across all vendors.\ncreate view LOW_PRICE (\n    part,\n    price\n) as\n    select part, MIN(price) as price from PRICE group by part;\n\n-- Lowest available price for each part along with part and vendor details.\ncreate materialized view PREFERRED_VENDOR (\n    part_id,\n    part_name,\n    vendor_id,\n    vendor_name,\n    price\n) as\n    select\n        PART.id as part_id,\n        PART.name as part_name,\n        VENDOR.id as vendor_id,\n        VENDOR.name as vendor_name,\n        PRICE.price\n    from\n        PRICE,\n        PART,\n        VENDOR,\n        LOW_PRICE\n    where\n        PRICE.price = LOW_PRICE.price AND\n        PRICE.part = LOW_PRICE.part AND\n        PART.id = PRICE.part AND\n        VENDOR.id = PRICE.vendor;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The first part of this listing declares inputs to the pipeline\nusing SQL ",(0,s.jsx)(n.code,{children:"CREATE TABLE"})," statements.\nIndeed, SQL's data modeling language works for streaming\ndata just as well as for tables stored on the disk.  No need to learn a new\nlanguage: if you know SQL, you already know streaming SQL!"]}),"\n",(0,s.jsx)(n.p,{children:"Note that these declarations do not say anything\nabout the sources of data.  We will add that in Part 3 of the tutorial."}),"\n",(0,s.jsxs)(n.p,{children:["Finally, note the ",(0,s.jsx)(n.code,{children:"'materialized' = 'true'"})," attribute on the\ntables.  This annotation instructs Feldera to store the entire contents of the table,\nso that the user can browse it at any time."]}),"\n",(0,s.jsxs)(n.p,{children:["The second part of the listing defines queries on top of the input tables.\nIn Feldera we write queries as SQL views.\nViews can be defined in terms of\ntables and other views, making it possible to express deeply nested queries\nin a modular way.\nIn this example we compute the lowest price for each part\nacross all vendors as the ",(0,s.jsx)(n.code,{children:"LOW_PRICE"})," view. We then define the ",(0,s.jsx)(n.code,{children:"PREFERRED_VENDOR"}),"\nview on top of ",(0,s.jsx)(n.code,{children:"LOW_PRICE"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We declare ",(0,s.jsx)(n.code,{children:"PREFERRED_VENDOR"})," as a ",(0,s.jsx)(n.strong,{children:"materialized"})," view, instructing Feldera to\nstore the entire contents of the view, so that the user can browse it at any time.\nThis is in contrast to regular views, for which the user can only observe a stream\nof ",(0,s.jsx)(n.strong,{children:"changes"})," to the view, but cannot inspect its current contents."]}),"\n",(0,s.jsxs)(n.p,{children:["Click the Play ",(0,s.jsx)("icon",{icon:"bx:play"})," button to run the pipeline."]}),"\n",(0,s.jsx)(n.h2,{id:"step-2-insert-data",children:"Step 2. Insert data"}),"\n",(0,s.jsxs)(n.p,{children:["When the pipeline is running it can process incoming changes. The changes can be submitted to the pipeline in three ways: automatically via ",(0,s.jsx)(n.a,{href:"/connectors/",children:"input connectors"})," attached to the pipeline tables, by sending HTTP ingress requests and by issuing ",(0,s.jsx)(n.code,{children:"INSERT INTO ..."})," ad-hoc queries. You can use one of our tools - the ",(0,s.jsx)(n.a,{href:"pathname:///python/feldera.html#feldera.pipeline.Pipeline.input_json",children:"Python SDK"}),", the ",(0,s.jsx)(n.a,{href:"/interface/cli",children:"Feldera CLI tool"}),", the Web Console or the ",(0,s.jsx)(n.a,{href:"/api/push-data-to-a-sql-table",children:"REST API"})," directly to leverage any of these methods. For simplicity, let us use the Web Console to run an ",(0,s.jsx)(n.code,{children:"INSERT INTO ..."})," query."]}),"\n",(0,s.jsx)(n.p,{children:'Open the "Ad-hoc query" tab and paste the following statement in the input field:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"INSERT INTO VENDOR (id, name, address) VALUES\n(1, 'Gravitech Dynamics', '222 Graviton Lane'),\n(2, 'HyperDrive Innovations', '456 Warp Way'),\n(3, 'DarkMatter Devices', '333 Singularity Street');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Press ",(0,s.jsx)(n.code,{children:"Enter"})," or click the Play ",(0,s.jsx)("icon",{icon:"bx:play"})," button to submit the query. You will see the result containing the number of inserted rows - 3:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Query to insert vendor data",src:t(43528).A+"",width:"1976",height:"614"})}),"\n",(0,s.jsxs)(n.p,{children:["Ad-hoc queries can also be used to inspect current state of tables and views.\nNow let us check the state of the ",(0,s.jsx)(n.code,{children:"VENDOR"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM VENDOR;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Inserted vendor data",src:t(21859).A+"",width:"1523",height:"407"})}),"\n",(0,s.jsx)(n.p,{children:"Yep, everything is in order. Let us fill the other tables:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"INSERT INTO PART (id, name) VALUES\n(1, 'Flux Capacitor'),\n(2, 'Warp Core'),\n(3, 'Kyber Crystal');\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"INSERT INTO PRICE (part, vendor, price) VALUES\n(1, 2, 10000),\n(2, 1, 15000),\n(3, 3, 9000);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Keep in mind that ad-hoc queries are evaluated for a single pipeline and not the entire system."}),"\n",(0,s.jsx)(n.h2,{id:"step-3-observe-pipeline-outputs",children:"Step 3. Observe pipeline outputs"}),"\n",(0,s.jsx)(n.p,{children:"Feldera is an incremental view maintenance (IVM) engine. This means that when new changes arrive in SQL tables, the SQL views are automatically updated. Rather than evaluating the views from scratch, Feldera only performs computation related to new changes with resource consumption proportional to the size of these changes."}),"\n",(0,s.jsxs)(n.p,{children:["When we inserted the new data into ",(0,s.jsx)(n.code,{children:"VENDOR"}),", ",(0,s.jsx)(n.code,{children:"PART"})," and ",(0,s.jsx)(n.code,{children:"PRICE"})," tables, Feldera already computed the results for ",(0,s.jsx)(n.code,{children:"LOW_PRICE"})," and ",(0,s.jsx)(n.code,{children:"PREFERRED_VENDOR"})," views. We can inspect ",(0,s.jsx)(n.code,{children:"PREFERRED_VENDOR"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT part_name, vendor_name FROM PREFERRED_VENDOR;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Initial preferred vendors",src:t(32026).A+"",width:"1508",height:"378"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that you can only use ad hoc ",(0,s.jsx)(n.code,{children:"SELECT"})," queries to inspect ",(0,s.jsx)(n.a,{href:"/sql/materialized",children:"materialized"})," tables and views. In this example, the ",(0,s.jsx)(n.code,{children:"LOW_PRICE"})," view is not declared as ",(0,s.jsx)(n.code,{children:"MATERIALIZED"}),"; therefore we cannot query it."]}),"\n",(0,s.jsx)(n.p,{children:"This limitation only concerns ad-hoc queries - SQL views declared in the main SQL program can contain arbitrary queries over both materialized and non-materialized tables and views."}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"SELECT"})," ad-hoc queries do not play part in advancing pipeline's incremental computation, they only reveal the state that was already automatically and incrementally computed."]}),"\n",(0,s.jsx)(n.p,{children:"Ad-hoc queries can also be evaluated when the pipeline is paused."}),"\n",(0,s.jsx)(n.h2,{id:"step-4-observe-incremental-changes",children:"Step 4. Observe incremental changes"}),"\n",(0,s.jsx)(n.p,{children:"Let us see Feldera's incremental computation in action!"}),"\n",(0,s.jsxs)(n.p,{children:['Instead of inspecting views with queries, let\'s capture changes as they happen.\nOpen the "Change Stream" tab and tick the checkboxes next to the ',(0,s.jsx)(n.code,{children:"PRICE"})," table, ",(0,s.jsx)(n.code,{children:"LOW_PRICE"})," and ",(0,s.jsx)(n.code,{children:"PREFERRED_VENDOR"})," views."]}),"\n",(0,s.jsx)(n.p,{children:"Switch back and execute one more ad-hoc query:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"INSERT INTO PRICE (part, vendor, price) VALUES\n(2, 3, 12000);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here we are introducing a new, lower, price for a part from a different vendor, so we expect an updated lowest price."}),"\n",(0,s.jsxs)(n.p,{children:['Navigate to the "Change stream" tab and observe an insert in the ',(0,s.jsx)(n.code,{children:"PRICE"})," table and inserts and deletes for the views:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Change stream updates for a new cheaper part",src:t(72460).A+"",width:"2078",height:"362"})}),"\n",(0,s.jsx)(n.p,{children:"As was the case here, Feldera incrementally updates the views by deleting old records that are no longer part of the view and inserting newly added records."}),"\n",(0,s.jsxs)(n.p,{children:["If we inspect the ",(0,s.jsx)(n.code,{children:"PREFERRED_VENDOR"}),' again we will see that the entry for the "Warp Core" has indeed been replaced as a result of an incremental update:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT part_name, vendor_name FROM PREFERRED_VENDOR;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Shut down the pipeline by clicking the stop icon ",(0,s.jsx)("icon",{icon:"bx:stop"})," to forget all its ingested data, computed view results and any accumulated internal state."]}),"\n",(0,s.jsx)(n.h2,{id:"takeaways",children:"Takeaways"}),"\n",(0,s.jsx)(n.p,{children:"Let us recap what we have learned so far:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Feldera executes ",(0,s.jsx)(n.strong,{children:"programs"})," written in standard SQL, using ",(0,s.jsx)(n.code,{children:"CREATE TABLE"})," and ",(0,s.jsx)(n.code,{children:"CREATE VIEW"})," statements."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CREATE TABLE"})," statements define a schema for input data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CREATE VIEW"})," statements define queries over input tables and other views."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["An SQL program is instantiated as a part of a ",(0,s.jsx)(n.strong,{children:"pipeline"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Feldera evaluates SQL programs ",(0,s.jsx)(n.strong,{children:"incrementally"}),", continuously updating their results as input data changes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You can observe input and output changes as they happen, or query a snapshot of data in input tables and output views."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When the pipeline is stopped, all its processed inputs and computed results are lost."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},21859:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/basics-part1-2-821449fab3b6a7801b6e3f9ba34edd31.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},32026:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/basics-part1-3-a0eb5423fe002e2a68e435dedfbbf055.png"},43528:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/basics-part1-1-74355f36b04aead5de1cefc0d932e4f8.png"},72460:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/basics-part1-5-9ccb1324ed84ef4a01686de8d34e1363.png"}}]);