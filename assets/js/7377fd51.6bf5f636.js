"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[2839],{12139:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>h,contentTitle:()=>d,default:()=>o,frontMatter:()=>i,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"sql/string","title":"String Operations","description":"SQL defines two primary character types: character varying(n) and","source":"@site/docs/sql/string.md","sourceDirName":"sql","slug":"/sql/string","permalink":"/sql/string","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Operators","permalink":"/sql/operators"},"next":{"title":"Table Functions","permalink":"/sql/table"}}');var t=r(74848),c=r(28453);const i={},d="String Operations",h={},a=[{value:"String constants (literals)",id:"string-constants-literals",level:2},{value:"Escaped characters",id:"escaped-characters",level:2},{value:"Operations on string values",id:"operations-on-string-values",level:2},{value:"<code>LIKE</code>",id:"like",level:2},{value:"<code>ILIKE</code>",id:"ilike",level:2},{value:"POSIX regular expressions",id:"posix-regular-expressions",level:2},{value:"Bracket Expressions",id:"bracket-expressions",level:3},{value:"Regular Expression Escapes",id:"regular-expression-escapes",level:3},{value:"Capture groups",id:"capture-groups",level:3},{value:"Regular expression functions",id:"regular-expression-functions",level:3},{value:"Replacement string syntax",id:"replacement-string-syntax",level:4}];function l(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"string-operations",children:"String Operations"})}),"\n",(0,t.jsxs)(s.p,{children:["SQL defines two primary character types: ",(0,t.jsx)(s.code,{children:"character varying(n)"})," and\n",(0,t.jsx)(s.code,{children:"character(n)"}),", where n is a positive integer.  Both of these types\ncan store strings up to n characters (not bytes) in length. An attempt\nto store a longer string into a column of these types will result in\nan error, unless the excess characters are all spaces, in which case\nthe string will be truncated to the maximum length. (This somewhat\nbizarre exception is required by the SQL standard.)  If the string to\nbe stored is shorter than the declared length, values of type\ncharacter will be space-padded; values of type character varying will\nsimply store the shorter string."]}),"\n",(0,t.jsxs)(s.p,{children:["In addition, we provide the ",(0,t.jsx)(s.code,{children:"text"}),", or ",(0,t.jsx)(s.code,{children:"varchar"})," type, which stores\nstrings of any length."]}),"\n",(0,t.jsx)(s.p,{children:"Trailing spaces are removed when converting a character value to one\nof the other string types.  Note that trailing spaces are semantically\nsignificant in character varying and text values, and when using\npattern matching (e.g., LIKE  and regular expressions)."}),"\n",(0,t.jsx)(s.h2,{id:"string-constants-literals",children:"String constants (literals)"}),"\n",(0,t.jsxs)(s.p,{children:["A string constant in SQL is an arbitrary sequence of characters\nbounded by single quotes (",(0,t.jsx)(s.code,{children:"'"}),"), for example ",(0,t.jsx)(s.code,{children:"'This is a string'"}),". To\ninclude a single-quote character within a string constant, write two\nadjacent single quotes, e.g., ",(0,t.jsx)(s.code,{children:"'Dianne''s horse'"}),". Note that this is\nnot the same as a double-quote character (",(0,t.jsx)(s.code,{children:'"'}),")."]}),"\n",(0,t.jsx)(s.p,{children:"Two string constants that are only separated by whitespace with at\nleast one newline are concatenated and effectively treated as if the\nstring had been written as one constant. For example:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT 'foo'\n'bar'\n"})}),"\n",(0,t.jsx)(s.p,{children:"is equivalent to:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT 'foobar'\n"})}),"\n",(0,t.jsx)(s.p,{children:"but:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT 'foo'      'bar'\n"})}),"\n",(0,t.jsx)(s.p,{children:"is not valid syntax."}),"\n",(0,t.jsx)(s.h2,{id:"escaped-characters",children:"Escaped characters"}),"\n",(0,t.jsxs)(s.p,{children:["We also accepts escaped characters withing string constants, which are\nan extension to the SQL standard.  Within an escape string, a\nbackslash character (",(0,t.jsx)(s.code,{children:"\\"}),") begins a C-like backslash escape sequence, in\nwhich the combination of backslash and following character(s)\nrepresent a special byte value:"]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Backslash Escape Sequence"}),(0,t.jsx)(s.th,{children:"Interpretation"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\b"})}),(0,t.jsx)(s.td,{children:"backspace"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\f"})}),(0,t.jsx)(s.td,{children:"form feed"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\n"})}),(0,t.jsx)(s.td,{children:"newline"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\r"})}),(0,t.jsx)(s.td,{children:"carriage return"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\t"})}),(0,t.jsx)(s.td,{children:"tab"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\o, \\oo, \\ooo"})}),(0,t.jsx)(s.td,{children:"(o = 0\u20137) octal byte value"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\xh, \\xhh (h = 0\u20139, A\u2013F)"})}),(0,t.jsx)(s.td,{children:"hexadecimal byte value"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)("code",{children:"\\uxxxx, \\Uxxxxxxxx (x = 0\u20139, A\u2013F)"})}),(0,t.jsx)(s.td,{children:"16 or 32-bit hexadecimal Unicode character value"})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["Any other character following a backslash is taken literally. Thus, to\ninclude a backslash character, write two backslashes ",(0,t.jsx)(s.code,{children:"\\\\"}),". Also, a\nsingle quote can be included in an escape string by writing ",(0,t.jsx)(s.code,{children:"\\'"}),", in\naddition to the normal way of ",(0,t.jsx)(s.code,{children:"''"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"operations-on-string-values",children:"Operations on string values"}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Operation"}),(0,t.jsx)("th",{children:"Description"}),(0,t.jsx)("th",{children:"Examples"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"concat"}),(0,t.jsx)("code",{children:"||"})]}),(0,t.jsxs)("td",{children:["String concatenation (infix).  Note that concatenation does ",(0,t.jsx)(s.em,{children:"not"})," strip trailing spaces\nfrom CHAR(N) values, unlike other SQL dialects.  If such behavior is desired, an explicit\ncast to ",(0,t.jsx)(s.code,{children:"varchar"})," can be added."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"'Post' || 'greSQL'"})," => ",(0,t.jsx)("code",{children:"PostgreSQL"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"like"}),(0,t.jsx)("code",{children:"string LIKE pattern [ESCAPE escape-character]"})," and\n",(0,t.jsx)("code",{children:"string NOT LIKE pattern [ESCAPE escape-character]"})]}),(0,t.jsxs)("td",{children:["The LIKE expression returns true if the string matches the supplied pattern.\n(As expected, the ",(0,t.jsx)("code",{children:"NOT LIKE"})," expression returns false if LIKE returns true."]}),(0,t.jsx)("td",{children:"See below for details."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"ilike"}),(0,t.jsxs)(s.p,{children:[(0,t.jsx)("code",{children:"string ILIKE pattern "})," and\n",(0,t.jsx)("code",{children:"string NOT ILIKE pattern"})]})]}),(0,t.jsx)("td",{children:(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)("code",{children:"ILIKE"})," expression returns true if the string matches the supplied pattern,\nperforming a case-insensitive comparison. This means that differences in character case\nbetween the string and the pattern are ignored.\n(Similarly, the ",(0,t.jsx)("code",{children:"NOT ILIKE"})," expression returns false if ",(0,t.jsx)("code",{children:"ILIKE"})," returns true.)"]})}),(0,t.jsx)("td",{children:(0,t.jsx)(s.p,{children:"See below for details."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"rlike"}),(0,t.jsx)("code",{children:"string RLIKE pattern"})," and\n",(0,t.jsx)("code",{children:"string NOT RLIKE pattern"})]}),(0,t.jsx)("td",{children:"The RLIKE expression returns true if the string matches the supplied pattern.\nThe pattern is a standard Java regular expression."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"'string' RLIKE 's..i.*'"})," => ",(0,t.jsx)("code",{children:"TRUE"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"ascii"}),(0,t.jsx)("code",{children:"ASCII ( string )"})]}),(0,t.jsx)("td",{children:"Returns the numeric code of the first character of the argument. In UTF8 encoding, returns the Unicode code point of the character. In other multibyte encodings, the argument must be an ASCII character.  Returns 0 if the string is empty."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"ascii('x')"})," => ",(0,t.jsx)("code",{children:"120"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"char_length"}),(0,t.jsx)("code",{children:"CHAR_LENGTH(string)"})," or ",(0,t.jsx)("code",{children:"CHARACTER_LENGTH(string)"})," or ",(0,t.jsx)("code",{children:"LENGTH(string)"})," or ",(0,t.jsx)("code",{children:"LEN(string)"})]}),(0,t.jsx)("td",{children:"Returns number of characters in the string."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"char_length('jos\xe9')"})," => ",(0,t.jsx)("code",{children:"4"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"chr"}),(0,t.jsx)("code",{children:"CHR ( integer )"})]}),(0,t.jsx)("td",{children:"Returns a string containing the character with the given code. If the code is incorrect (e.g., negative), the result is an empty string."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"chr(65)"})," => ",(0,t.jsx)("code",{children:"A"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"concat"}),(0,t.jsx)("code",{children:"CONCAT("}),"string1, ..., stringN",(0,t.jsx)("code",{children:")"})]}),(0,t.jsx)("td",{children:"String concatenation.  Can have any number of arguments."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"CONCAT('Post', 'greSQL', 1)"})," => ",(0,t.jsx)("code",{children:"PostgreSQL1"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"concat_ws"}),(0,t.jsx)("code",{children:"CONCAT_WS("}),"sep, string1, ..., stringN",(0,t.jsx)("code",{children:")"})]}),(0,t.jsxs)("td",{children:["String concatenation with separator ",(0,t.jsx)("code",{children:"sep"}),".  Can have any number of arguments.  ",(0,t.jsx)("code",{children:"sep"})," is intercalated between all strings.  If ",(0,t.jsx)("code",{children:"sep"})," is ",(0,t.jsx)("code",{children:"NULL"})," result is ",(0,t.jsx)("code",{children:"NULL"}),".  Other ",(0,t.jsx)("code",{children:"NULL"})," arguments are ignored."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"CONCAT_WS(',', 'Post', 'greSQL', NULL, '1')"})," => ",(0,t.jsx)("code",{children:"Post,greSQL,1"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"initcap"}),(0,t.jsx)("code",{children:"INITCAP ( string )"})]}),(0,t.jsx)("td",{children:"Converts the first letter of each word to upper case and the rest to lower case. Words are sequences of alphanumeric characters separated by non-alphanumeric characters."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"initcap('hi THOMAS')"})," => ",(0,t.jsx)("code",{children:"Hi Thomas"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"initcap_spaces"}),(0,t.jsx)("code",{children:"INITCAP_SPACES ( string )"})]}),(0,t.jsx)("td",{children:"Converts the first letter of each word to upper case and the rest to lower case. Words are sequences of characters separated by spaces."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"initcap('hi THOMAS-SON')"})," => ",(0,t.jsx)("code",{children:"Hi Thomas-son"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"left"}),(0,t.jsx)("code",{children:"LEFT ( string, count )"})]}),(0,t.jsxs)("td",{children:["Returns first ",(0,t.jsx)("code",{children:"count"})," characters in the string.  If any argument is ",(0,t.jsx)("code",{children:"NULL"}),", return ",(0,t.jsx)("code",{children:"NULL"}),"."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"left('abcde', 2)"})," => ",(0,t.jsx)("code",{children:"ab"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"lower"}),(0,t.jsx)("code",{children:"LOWER ( string )"})]}),(0,t.jsx)("td",{children:"Converts the string to all lower case."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"lower('TOM')"})," => ",(0,t.jsx)("code",{children:"tom"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"md5"}),(0,t.jsx)("code",{children:"MD5"}),"(string)"]}),(0,t.jsx)("td",{children:(0,t.jsxs)(s.p,{children:["Calculates an MD5 128-bit checksum of string and returns it as a hex ",(0,t.jsx)("code",{children:"VARCHAR"})," value.\nIf the input is NULL, NULL is returned."]})}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SELECT md5('Feldera')"})," => ",(0,t.jsx)("code",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"overlay"}),(0,t.jsx)("code",{children:"OVERLAY ( string PLACING newsubstring FROM start [ FOR remove ] )"})]}),(0,t.jsx)("td",{children:"Replaces the substring of string that starts at the start'th character and extends for remove characters with newsubstring. If count is omitted, it defaults to the length of newsubstring.  If 'start' is nott positive, the original string is unchanged.  If 'start' is bigger than the length of 'string', the result is the concatenation of the two strings.  If 'remove' is negative it is considered 0."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"overlay('Txxxxas' placing 'hom' from 2 for 4)"})," => ",(0,t.jsx)("code",{children:"Thomas"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"position"}),(0,t.jsx)("code",{children:"POSITION(substring IN string)"})]}),(0,t.jsx)("td",{children:"Returns first starting index of the specified substring within string, or zero if it's not present.  First character has index 1."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"position('om' in 'Thomas')"})," => ",(0,t.jsx)("code",{children:"3"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"regexp_replace"}),(0,t.jsx)("code",{children:"REGEXP_REPLACE(expr, pat[, repl])"})]}),(0,t.jsxs)("td",{children:["Replaces occurrences in the string ",(0,t.jsx)(s.code,{children:"expr"})," that match the regular expression\nspecified by the pattern ",(0,t.jsx)(s.code,{children:"pat"})," with the replacement string ",(0,t.jsx)(s.code,{children:"repl"}),", and returns\nthe resulting string. If any one of ",(0,t.jsx)(s.code,{children:"expr"}),", ",(0,t.jsx)(s.code,{children:"pat"}),", or ",(0,t.jsx)(s.code,{children:"repl"})," is ",(0,t.jsx)(s.code,{children:"NULL"}),", the return value is ",(0,t.jsx)(s.code,{children:"NULL"}),".\nIf ",(0,t.jsx)(s.code,{children:"repl"})," is missing, it is assumed to be the empty string.  If the regular\nexpression is invalid, the original string is returned."]}),(0,t.jsx)("td",{})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"repeat"}),(0,t.jsx)("code",{children:"REPEAT ( string, count )"})]}),(0,t.jsx)("td",{children:"Repeats string the specified number of times.  The result is an empty string for a negative or 0 count."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"repeat('Pg', 4)"})," => ",(0,t.jsx)("code",{children:"PgPgPgPg"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"replace"}),(0,t.jsx)("code",{children:"REPLACE ( haystack, needle, replacement )"})]}),(0,t.jsxs)("td",{children:["Replaces all occurrences of ",(0,t.jsx)(s.code,{children:"needle"})," in ",(0,t.jsx)(s.code,{children:"haystack"})," with ",(0,t.jsx)(s.code,{children:"replacement"}),"."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"replace('abcdefabcdef', 'cd', 'XX')"})," => ",(0,t.jsx)("code",{children:"abXXefabXXef"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"right"}),(0,t.jsx)("code",{children:"RIGHT ( string, count )"})]}),(0,t.jsxs)("td",{children:["Returns last ",(0,t.jsx)("code",{children:"count"})," characters in the string.  If any argument is ",(0,t.jsx)("code",{children:"NULL"}),", return ",(0,t.jsx)("code",{children:"NULL"}),"."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"right('abcde', 2)"})," => ",(0,t.jsx)("code",{children:"de"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"RLIKE(string, pattern)"})}),(0,t.jsxs)("td",{children:["A function equivalent to the ",(0,t.jsx)("code",{children:"RLIKE"})," operator above."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"RLIKE('string', 's..i.*')"})," => ",(0,t.jsx)("code",{children:"TRUE"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"split"}),(0,t.jsx)("code",{children:"SPLIT(string [, delimiter])"})]}),(0,t.jsxs)("td",{children:["Produce an array of strings, by splitting the first argument at each delimiter occurrence.\nIf the delimiter is empty, return an array with the original string.  If the original\nstring is empty, return an empty array.  If either argument is ",(0,t.jsx)(s.code,{children:"NULL"}),", return ",(0,t.jsx)(s.code,{children:"NULL"}),".\nIf delimiter is absent assume it is the string ",(0,t.jsx)("code",{children:"','"}),"."]}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SPLIT('a|b|c|', '|')"})," => ",(0,t.jsx)("code",{children:"['a', 'b', 'c', '']"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"split_part"}),(0,t.jsx)("code",{children:"SPLIT_PART(string, delimiter, n)"})]}),(0,t.jsxs)("td",{children:[(0,t.jsxs)(s.p,{children:["This function uses 1-based indexing. It extracts the ",(0,t.jsx)("code",{children:"n"}),"'th part of the string by splitting it at each occurrence of the delimiter."]}),(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("code",{children:"n = 1"})," refers to the first part of the string after splitting."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("code",{children:"n = 2"})," refers to the second part, and so on."]}),(0,t.jsxs)("li",{children:["If ",(0,t.jsx)("code",{children:"n"})," is negative, it returns the ",(0,t.jsx)("code",{children:"abs(n)"}),"'th part from the end of the string."]}),(0,t.jsxs)("li",{children:["If ",(0,t.jsx)("code",{children:"n"})," is out of bounds, it returns an empty string."]})]})]}),(0,t.jsx)("td",{children:(0,t.jsxs)(s.p,{children:[(0,t.jsx)("code",{children:"SPLIT_PART('a|b|c|', '|', 2)"})," => ",(0,t.jsx)("code",{children:"b"}),(0,t.jsx)("br",{}),"\n",(0,t.jsx)("code",{children:"SPLIT_PART('a|b|c|', '|', -2)"})," => ",(0,t.jsx)("code",{children:"c"}),(0,t.jsx)("br",{}),"\n",(0,t.jsx)("code",{children:"SPLIT_PART('a|b|c|', '|', 5)"})," => ",(0,t.jsx)("code",{children:"''"})]})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"substr"}),(0,t.jsx)("code",{children:"SUBSTR ("})," string, start, ",(0,t.jsx)("code",{children:" [ ,"})," length ",(0,t.jsx)("code",{children:"]"})]}),(0,t.jsx)("td",{children:'Extracts the substring of string starting at the "start"\'th character if that is specified, and stopping after "length" characters if the value is specified. If "start" is negative, it is replaced with 1.  If "count" is negative the empty string is returned.  The index of the first character is 1.'}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SUBSTR('Thomas', 2, 3)"})," => ",(0,t.jsx)("code",{children:"hom"}),(0,t.jsx)("br",{}),"\n",(0,t.jsx)("code",{children:"SUBSTR('Thomas', 3)"})," => ",(0,t.jsx)("code",{children:"omas"}),(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"substring"}),(0,t.jsx)("code",{children:"SUBSTRING ("})," string ",(0,t.jsx)("code",{children:"FROM"})," position ",(0,t.jsx)("code",{children:" [ FOR"})," count",(0,t.jsx)("code",{children:" ] )"})]}),(0,t.jsx)("td",{children:'Extracts the substring of string starting at the "start"\'th character if that is specified, and stopping after "count" characters if the value is specified. At least one of "start" or "count" must be provided.  If "start" is negative, it is replaced with 1.  If "count" is negative the empty string is returned.  The index of the first character is 1.'}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"SUBSTRING('Thomas' from 2 for 3)"})," => ",(0,t.jsx)("code",{children:"hom"}),(0,t.jsx)("br",{}),"\n",(0,t.jsx)("code",{children:"SUBSTRING('Thomas' from 3)"})," => ",(0,t.jsx)("code",{children:"omas"}),(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"trim"}),(0,t.jsx)("code",{children:"TRIM ( [ LEADING | TRAILING | BOTH ]"})," characters ",(0,t.jsx)("code",{children:"FROM"})," string ",(0,t.jsx)("code",{children:")"})]}),(0,t.jsx)("td",{children:"Remove the specified characters from the specified ends of the string argument"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"TRIM(both 'xyz' from 'yxTomxx')"})," => ",(0,t.jsx)("code",{children:"Tom"}),(0,t.jsx)("br",{}),(0,t.jsx)("code",{children:"TRIM(leading 'xyz' from 'yxTomxx')"})," => ",(0,t.jsx)("code",{children:"Tomxx"})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("a",{id:"upper"}),(0,t.jsx)("code",{children:"UPPER ( string )"})]}),(0,t.jsx)("td",{children:"Converts the string to all upper case."}),(0,t.jsxs)("td",{children:[(0,t.jsx)("code",{children:"upper('tom')"})," => ",(0,t.jsx)("code",{children:"TOM"})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"like",children:(0,t.jsx)(s.code,{children:"LIKE"})}),"\n",(0,t.jsxs)(s.p,{children:["string ",(0,t.jsx)(s.code,{children:"LIKE"})," pattern [",(0,t.jsx)(s.code,{children:"ESCAPE"})," escape-character]"]}),"\n",(0,t.jsxs)(s.p,{children:["string ",(0,t.jsx)(s.code,{children:"NOT LIKE"})," pattern [",(0,t.jsx)(s.code,{children:"ESCAPE"})," escape-character]"]}),"\n",(0,t.jsxs)(s.p,{children:["If pattern does not contain percent signs or underscores, then the\npattern only represents the string itself; in that case ",(0,t.jsx)(s.code,{children:"LIKE"})," acts\nlike the equals operator. An underscore (",(0,t.jsx)(s.code,{children:"_"}),") in pattern stands for\n(matches) any single character; a percent sign (",(0,t.jsx)(s.code,{children:"%"}),") matches any\nsequence of zero or more characters."]}),"\n",(0,t.jsx)(s.p,{children:"Some examples:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"'abc' LIKE 'abc'    true\n'abc' LIKE 'a%'     true\n'abc' LIKE '_b_'    true\n'abc' LIKE 'c'      false\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"LIKE"})," pattern matching always covers the entire string. Therefore, if\nit's desired to match a sequence anywhere within a string, the pattern\nmust start and end with a percent sign."]}),"\n",(0,t.jsxs)(s.p,{children:["To match a literal underscore or percent sign without matching other\ncharacters, the respective character in pattern must be preceded by\nthe escape character. The default escape character is the backslash\nbut a different one can be selected by using the ESCAPE clause. To\nmatch the escape character itself, write two escape characters.  The\nescape character cannot be one of the special pattern characters ",(0,t.jsx)(s.code,{children:"_"}),"\nor ",(0,t.jsx)(s.code,{children:"%"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Some examples where the escape character is changed to ",(0,t.jsx)(s.code,{children:"#"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT 'hawkeye' LIKE 'h%' ESCAPE '#'          true\nSELECT 'hawkeye' NOT LIKE 'h%' ESCAPE '#'      false\nSELECT 'h%' LIKE 'h#%' ESCAPE '#'              true\nSELECT 'h%' NOT LIKE 'h#%' ESCAPE '#'          false\nSELECT 'h%wkeye' LIKE 'h#%' ESCAPE '#'         false\nSELECT 'h%wkeye' NOT LIKE 'h#%' ESCAPE '#'     true\nSELECT 'h%wkeye' LIKE 'h#%%' ESCAPE '#'        true\nSELECT 'h%wkeye' NOT LIKE 'h#%%' ESCAPE '#'    false\nSELECT 'h%awkeye' LIKE 'h#%a%k%e' ESCAPE '#'   true\n"})}),"\n",(0,t.jsxs)(s.p,{children:["When either argument or ",(0,t.jsx)(s.code,{children:"LIKE"}),", ",(0,t.jsx)(s.code,{children:"NOT LIKE"})," is ",(0,t.jsx)(s.code,{children:"NULL"}),", the result is ",(0,t.jsx)(s.code,{children:"NULL"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"ilike",children:(0,t.jsx)(s.code,{children:"ILIKE"})}),"\n",(0,t.jsxs)(s.p,{children:["string ",(0,t.jsx)(s.code,{children:"ILIKE"})," pattern"]}),"\n",(0,t.jsxs)(s.p,{children:["string ",(0,t.jsx)(s.code,{children:"NOT ILIKE"})," pattern"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"ILIKE"})," expression performs a case-insensitive pattern match. If the pattern does not contain percent signs or underscores, then the pattern represents the string itself, and ",(0,t.jsx)(s.code,{children:"ILIKE"})," acts like the equals operator, ignoring character case. An underscore (",(0,t.jsx)(s.code,{children:"_"}),") in the pattern matches any single character, while a percent sign (",(0,t.jsx)(s.code,{children:"%"}),") matches any sequence of zero or more characters."]}),"\n",(0,t.jsx)(s.p,{children:"Some examples:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT 'hawkeye' ILIKE 'h%'        true\nSELECT 'hawkeye' NOT ILIKE 'h%'    false\nSELECT 'hawkeye' ILIKE 'H%'        true\nSELECT 'hawkeye' NOT ILIKE 'H%'    false\nSELECT 'hawkeye' ILIKE 'H%Eye'     true\nSELECT 'hawkeye' NOT ILIKE 'H%Eye' false\nSELECT 'Hawkeye' ILIKE 'h%'        true\nSELECT 'Hawkeye' NOT ILIKE 'h%'    false\nSELECT 'ABC'     ILIKE '_b_'       true\nSELECT 'ABC'     NOT ILIKE '_b_'   false\n"})}),"\n",(0,t.jsxs)(s.p,{children:["When either argument or ",(0,t.jsx)(s.code,{children:"ILIKE"}),", ",(0,t.jsx)(s.code,{children:"NOT ILIKE"})," is ",(0,t.jsx)(s.code,{children:"NULL"}),", the result is ",(0,t.jsx)(s.code,{children:"NULL"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"posix-regular-expressions",children:"POSIX regular expressions"}),"\n",(0,t.jsxs)(s.p,{children:["Regular expressions are matched using the ",(0,t.jsx)(s.code,{children:"RLIKE"})," function.  If either\nargument of ",(0,t.jsx)(s.code,{children:"RLIKE"})," is ",(0,t.jsx)(s.code,{children:"NULL"}),", the result is also ",(0,t.jsx)(s.code,{children:"NULL"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The description below is from the ",(0,t.jsx)(s.a,{href:"https://www.postgresql.org/docs/15/functions-matching.html#FUNCTIONS-POSIX-REGEXP",children:"Postgres\ndocumentation"}),",\nwhere credit is given to Henry Spencer."]}),"\n",(0,t.jsxs)(s.p,{children:["POSIX regular expressions provide a more powerful means for pattern\nmatching than the ",(0,t.jsx)(s.code,{children:"LIKE"})," and ",(0,t.jsx)(s.code,{children:"SIMILAR TO"})," operators.  Many Unix tools\nsuch as ",(0,t.jsx)(s.code,{children:"egrep"}),", ",(0,t.jsx)(s.code,{children:"sed"}),", or ",(0,t.jsx)(s.code,{children:"awk"})," use a pattern matching language that\nis similar to the one described here."]}),"\n",(0,t.jsxs)(s.p,{children:["Currently our compiler does ",(0,t.jsx)(s.em,{children:"not"})," support ",(0,t.jsx)(s.code,{children:"SIMILAR TO"})," regular\nexpressions."]}),"\n",(0,t.jsxs)(s.p,{children:["A regular expression is a character sequence that is an abbreviated\ndefinition of a set of strings (a regular set). A string is said to\nmatch a regular expression if it is a member of the regular set\ndescribed by the regular expression. As with ",(0,t.jsx)(s.code,{children:"LIKE"}),", pattern\ncharacters match string characters exactly unless they are special\ncharacters in the regular expression language \u2014 but regular\nexpressions use different special characters than ",(0,t.jsx)(s.code,{children:"LIKE"})," does. Unlike\n",(0,t.jsx)(s.code,{children:"LIKE"})," patterns, a regular expression is allowed to match anywhere\nwithin a string, unless the regular expression is explicitly anchored\nto the beginning or end of the string."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.em,{children:"regular expression"})," is defined as one or more ",(0,t.jsx)(s.em,{children:"branches"}),", separated\nby ",(0,t.jsx)(s.code,{children:"|"}),". It matches anything that matches one of the branches."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.em,{children:"branch"})," is zero or more ",(0,t.jsx)(s.em,{children:"quantified atoms"})," or ",(0,t.jsx)(s.em,{children:"constraints"}),",\nconcatenated. It matches a match for the first, followed by a match\nfor the second, etc.; an empty branch matches the empty string."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.em,{children:"quantified atom"})," is an ",(0,t.jsx)(s.em,{children:"atom"})," possibly followed by a single\n",(0,t.jsx)(s.em,{children:"quantifier"}),". Without a quantifier, it matches a match for the\natom. With a quantifier, it can match some number of matches of the\natom. An atom can be any of the possibilities shown in the Table\nbelow."]}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Atom"}),(0,t.jsx)("th",{children:"Description"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"(re)"})}),(0,t.jsxs)("td",{children:["where ",(0,t.jsx)("code",{children:"re"})," is any regular expression: matches a match for ",(0,t.jsx)("code",{children:"re"}),", with the match noted for possible reporting"]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsxs)("code",{children:["(?",":re",")"]})}),(0,t.jsx)("td",{children:"as above, but the match is not noted for reporting (a \u201cnon-capturing\u201d set of parentheses)"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"."})}),(0,t.jsx)("td",{children:"matches any single character"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"[chars]"})}),(0,t.jsx)("td",{children:"a bracket expression, matching any one of the chars (see below for more details)"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"\\k"})}),(0,t.jsxs)("td",{children:["where ",(0,t.jsx)("code",{children:"k"})," is a non-alphanumeric character): matches that character taken as an ordinary character, e.g.,\n",(0,t.jsx)("code",{children:"\\"})," matches a backslash character"]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"\\c"})}),(0,t.jsxs)("td",{children:["where ",(0,t.jsx)("code",{children:"c"})," is alphanumeric (possibly followed by other characters): is an escape, see below"]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{children:"{"})}),(0,t.jsxs)("td",{children:["when followed by a character other than a digit, matches the left-brace character ",(0,t.jsx)("code",{children:"{"}),";\nwhen followed by a digit, it is the beginning of a bound (see below)"]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"x"}),(0,t.jsxs)("td",{children:["where ",(0,t.jsx)("code",{children:"x"})," is a single character with no other significance, matches that character"]})]})]}),"\n",(0,t.jsx)(s.p,{children:"The possible quantifiers and their meanings are shown the Table below."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Quantifier"}),(0,t.jsx)(s.th,{children:"Matches"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"*"})}),(0,t.jsx)(s.td,{children:"a sequence of 0 or more matches of the atom"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"+"})}),(0,t.jsx)(s.td,{children:"a sequence of 1 or more matches of the atom"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"?"})}),(0,t.jsx)(s.td,{children:"a sequence of 0 or 1 matches of the atom"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"{"}),"m",(0,t.jsx)(s.code,{children:"}"})]}),(0,t.jsx)(s.td,{children:"a sequence of exactly m matches of the atom"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"{"}),"m",(0,t.jsx)(s.code,{children:",}"})]}),(0,t.jsx)(s.td,{children:"a sequence of m or more matches of the atom"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"{"}),"m",(0,t.jsx)(s.code,{children:","}),"n",(0,t.jsx)(s.code,{children:"}"})]}),(0,t.jsx)(s.td,{children:"a sequence of m through n (inclusive) matches of the atom; m cannot exceed n"})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"A constraint matches an empty string, but matches only when specific\nconditions are met. A constraint can be used where an atom could be\nused, except it cannot be followed by a quantifier. The simple\nconstraints are shown in the Table below; some more constraints are\ndescribed later."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Constraint"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"^"})}),(0,t.jsx)(s.td,{children:"matches at the beginning of the string"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"$"})}),(0,t.jsx)(s.td,{children:"matches at the end of the string"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"bracket-expressions",children:"Bracket Expressions"}),"\n",(0,t.jsxs)(s.p,{children:["A bracket expression is a list of characters enclosed in ",(0,t.jsx)(s.code,{children:"[]"}),". It\nnormally matches any single character from the list (but see\nbelow). If the list begins with ",(0,t.jsx)(s.code,{children:"^"}),", it matches any single character\nnot from the rest of the list. If two characters in the list are\nseparated by ",(0,t.jsx)(s.code,{children:"-"}),", this is shorthand for the full range of characters\nbetween those two (inclusive) in the collating sequence, e.g., ",(0,t.jsx)(s.code,{children:"[0-9]"}),"\nin ASCII matches any decimal digit. It is illegal for two ranges to\nshare an endpoint, e.g., ",(0,t.jsx)(s.code,{children:"a-c-e"}),".  Ranges are very\ncollating-sequence-dependent, so portable programs should avoid\nrelying on them."]}),"\n",(0,t.jsxs)(s.p,{children:["To include a literal ",(0,t.jsx)(s.code,{children:"]"})," in the list, make it the first character\n(after ",(0,t.jsx)(s.code,{children:"^"}),", if that is used). To include a literal ",(0,t.jsx)(s.code,{children:"-"}),", make it the\nfirst or last character, or the second endpoint of a range. To use a\nliteral ",(0,t.jsx)(s.code,{children:"-"})," as the first endpoint of a range, enclose it in ",(0,t.jsx)(s.code,{children:"[."})," and\n",(0,t.jsx)(s.code,{children:".]"}),".  With the exception of these characters, some combinations using\n",(0,t.jsx)(s.code,{children:"["}),", all other special characters lose their special significance\nwithin a bracket expression. In particular, ",(0,t.jsx)(s.code,{children:"\\"})," is not special."]}),"\n",(0,t.jsxs)(s.p,{children:["Within a bracket expression, the name of a character class enclosed in\n",(0,t.jsx)(s.code,{children:"[:"})," and ",(0,t.jsx)(s.code,{children:":]"})," stands for the list of all characters belonging to that\nclass. A character class cannot be used as an endpoint of a range. The\nPOSIX standard defines these character class names:"]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Class"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"alnum"})}),(0,t.jsx)(s.td,{children:"letters and numeric digits"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"alpha"})}),(0,t.jsx)(s.td,{children:"letters"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"blank"})}),(0,t.jsx)(s.td,{children:"space and tab"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"cntrl"})}),(0,t.jsx)(s.td,{children:"control characters"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"digit"})}),(0,t.jsx)(s.td,{children:"numeric digits"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"graph"})}),(0,t.jsx)(s.td,{children:"printable characters except space"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"lower"})}),(0,t.jsx)(s.td,{children:"lower-case letters"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"print"})}),(0,t.jsx)(s.td,{children:"printable characters including space"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"punct"})}),(0,t.jsx)(s.td,{children:"punctuation"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"space"})}),(0,t.jsx)(s.td,{children:"any white space"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"upper"})}),(0,t.jsx)(s.td,{children:"upper-case letters"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"xdigit"})}),(0,t.jsx)(s.td,{children:"hexadecimal digits"})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"Class-shorthand escapes provide shorthands for certain commonly-used\ncharacter classes. They are shown in the table below."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Escape"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\d"})}),(0,t.jsx)(s.td,{children:"matches any digit, like [[:digit:]]"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\s"})}),(0,t.jsx)(s.td,{children:"matches any whitespace character, like [[:space:]]"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\w"})}),(0,t.jsx)(s.td,{children:"matches any word character, like [[:word:]]"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\D"})}),(0,t.jsx)(s.td,{children:"matches any non-digit, like [^[:digit:]]"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\S"})}),(0,t.jsx)(s.td,{children:"matches any non-whitespace character, like [^[:space:]]"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\W"})}),(0,t.jsx)(s.td,{children:"matches any non-word character, like [^[:word:]]"})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"The behavior of these standard character classes is generally\nconsistent across platforms for characters in the 7-bit ASCII set.\nWhether a given non-ASCII character is considered to belong to one of\nthese classes depends on the collation that is used for the\nregular-expression function or operator."}),"\n",(0,t.jsx)(s.h3,{id:"regular-expression-escapes",children:"Regular Expression Escapes"}),"\n",(0,t.jsxs)(s.p,{children:["Escapes are special sequences beginning with ",(0,t.jsx)(s.code,{children:"\\"})," followed by an\nalphanumeric character.  Escapes come in several varieties: character\nentry, class shorthands, constraint escapes, and back references. A\n",(0,t.jsx)(s.code,{children:"\\"})," followed by an alphanumeric character but not constituting a valid\nescape is illegal."]}),"\n",(0,t.jsx)(s.p,{children:"Character-entry escapes exist to make it easier to specify\nnon-printing and other inconvenient characters in REs. They are shown\nin the Table below."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Escape"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\a"})}),(0,t.jsx)(s.td,{children:"alert (bell) character, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\b"})}),(0,t.jsx)(s.td,{children:"backspace, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\B"})}),(0,t.jsx)(s.td,{children:"synonym for backslash () to help reduce the need for backslash doubling"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\c"}),"X"]}),(0,t.jsx)(s.td,{children:"(where X is any character) the character whose low-order 5 bits are the same as those of X, and whose other bits are all zero"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\e"})}),(0,t.jsx)(s.td,{children:"the character whose collating-sequence name is ESC, or failing that, the character with octal value 033"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\f"})}),(0,t.jsx)(s.td,{children:"form feed, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\n"})}),(0,t.jsx)(s.td,{children:"newline, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\r"})}),(0,t.jsx)(s.td,{children:"carriage return, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\t"})}),(0,t.jsx)(s.td,{children:"horizontal tab, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\u"}),"wxyz"]}),(0,t.jsx)(s.td,{children:"(where wxyz is exactly four hexadecimal digits) the character whose hexadecimal value is 0xwxyz"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\v"})}),(0,t.jsx)(s.td,{children:"vertical tab, as in C"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\x"}),"hhh"]}),(0,t.jsx)(s.td,{children:"(where hhh is any sequence of hexadecimal digits) the character whose hexadecimal value is 0xhhh (a single character no matter how many hexadecimal digits are used)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\0"})}),(0,t.jsx)(s.td,{children:"the character whose value is 0 (the null byte)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\"}),"xy"]}),(0,t.jsx)(s.td,{children:"(where xy is exactly two octal digits, and is not a back reference) the character whose octal value is 0xy"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\"}),"xyz"]}),(0,t.jsx)(s.td,{children:"(where xyz is exactly three octal digits, and is not a back reference) the character whose octal value is 0xyz"})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"Hexadecimal digits are 0-9, a-f, and A-F. Octal digits are 0-7."}),"\n",(0,t.jsx)(s.p,{children:"A constraint escape is a constraint, matching the empty string if\nspecific conditions are met, written as an escape. They are shown in\nthe Table below."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Escape"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\A"})}),(0,t.jsx)(s.td,{children:"matches only at the beginning of the string (see Section 9.7.3.5 for how this differs from ^)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\m"})}),(0,t.jsx)(s.td,{children:"matches only at the beginning of a word"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\M"})}),(0,t.jsx)(s.td,{children:"matches only at the end of a word"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\y"})}),(0,t.jsx)(s.td,{children:"matches only at the beginning or end of a word"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\Y"})}),(0,t.jsx)(s.td,{children:"matches only at a point that is not the beginning or end of a word"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"\\Z"})}),(0,t.jsx)(s.td,{children:"matches only at the end of the string"})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["A back reference ",(0,t.jsx)(s.code,{children:"(\\"}),"n",(0,t.jsx)(s.code,{children:")"})," matches the same string matched by the\nprevious parenthesized subexpression specified by the number n (see\nthe Table below). For example, ",(0,t.jsx)(s.code,{children:"([bc])\\1"})," matches ",(0,t.jsx)(s.code,{children:"bb"})," or ",(0,t.jsx)(s.code,{children:"cc"})," but not\n",(0,t.jsx)(s.code,{children:"bc"})," or ",(0,t.jsx)(s.code,{children:"cb"}),". The subexpression must entirely precede the back\nreference in the RE. Subexpressions are numbered in the order of their\nleading parentheses. Non-capturing parentheses do not define\nsubexpressions. The back reference considers only the string\ncharacters matched by the referenced subexpression, not any\nconstraints contained in it. For example, ",(0,t.jsx)(s.code,{children:"(^\\d)\\1"})," will match ",(0,t.jsx)(s.code,{children:"22"}),"."]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Escape"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\"}),"m"]}),(0,t.jsx)(s.td,{children:"(where m is a nonzero digit) a back reference to the m'th subexpression"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"\\"}),"mnn"]}),(0,t.jsx)(s.td,{children:"(where m is a nonzero digit, and nn is some more digits, and the decimal value mnn is not greater than the number of closing capturing parentheses seen so far) a back reference to the mnn'th subexpression"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"capture-groups",children:"Capture groups"}),"\n",(0,t.jsxs)(s.p,{children:["A common way to use regexes is with ",(0,t.jsx)(s.em,{children:"capture groups"}),". That is, instead\nof just looking for matches of an entire regex, parentheses are used\nto create groups that represent part of the match."]}),"\n",(0,t.jsxs)(s.p,{children:["For example, consider a string with multiple lines, and each line has\nthree whitespace delimited fields where the second field is expected\nto be a number and the third field a boolean.  This can be expressed\nwith the following regular expression, where the capture groups have\nbeen labeled ",(0,t.jsx)(s.code,{children:"$0"})," to ",(0,t.jsx)(s.code,{children:"$4"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"(?m)^\\s*(\\S+)\\s+([0-9]+)\\s+(true|false)\\s*$\n^^^^    ^^^^^   ^^^^^^^^   ^^^^^^^^^^^^\n $1      $2       $3           $4\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n               $0\n"})}),"\n",(0,t.jsx)(s.p,{children:"Capture group 0 always corresponds to an implicit unnamed group that\nincludes the entire match.  If a match is found, this group is always\npresent."}),"\n",(0,t.jsxs)(s.p,{children:["Subsequent groups may be named and are numbered, starting at 1, by the\norder in which the opening parenthesis appears in the pattern.  For\nexample, in the pattern ",(0,t.jsx)(s.code,{children:"(?<a>.(?<b>.))(?<c>.)"}),", ",(0,t.jsx)(s.code,{children:"a"}),", ",(0,t.jsx)(s.code,{children:"b"})," and ",(0,t.jsx)(s.code,{children:"c"}),"\ncorrespond to capture groups ",(0,t.jsx)(s.code,{children:"$1"}),", ",(0,t.jsx)(s.code,{children:"$2"})," and ",(0,t.jsx)(s.code,{children:"$3"}),", respectively."]}),"\n",(0,t.jsx)(s.h3,{id:"regular-expression-functions",children:"Regular expression functions"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"REGEXP_REPLACE(expr, pat[, repl])\n"})}),"\n",(0,t.jsxs)(s.p,{children:["If ",(0,t.jsx)(s.code,{children:"repl"})," is missing, it is assumed to be the empty string."]}),"\n",(0,t.jsxs)(s.p,{children:["Replaces occurrences in the string ",(0,t.jsx)(s.code,{children:"expr"})," that match the regular\nexpression specified by the pattern ",(0,t.jsx)(s.code,{children:"pat"})," with the replacement string\n",(0,t.jsx)(s.code,{children:"repl"}),", and returns the resulting string.  If any of ",(0,t.jsx)(s.code,{children:"expr"}),", ",(0,t.jsx)(s.code,{children:"pat"}),", or\n",(0,t.jsx)(s.code,{children:"repl"})," is ",(0,t.jsx)(s.code,{children:"NULL"}),", the return value is ",(0,t.jsx)(s.code,{children:"NULL"}),"."]}),"\n",(0,t.jsx)(s.h4,{id:"replacement-string-syntax",children:"Replacement string syntax"}),"\n",(0,t.jsxs)(s.p,{children:["All instances of ",(0,t.jsx)(s.code,{children:"$N"})," in the replacement string are replaced with the\nsubstring corresponding to the capture group identified by ",(0,t.jsx)(s.code,{children:"N"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"N"})," may be an integer corresponding to the index of the capture group\n(counted by order of opening parenthesis where 0 is the entire match)\nor it can be a name (consisting of letters, digits or underscores)\ncorresponding to a named capture group."]}),"\n",(0,t.jsxs)(s.p,{children:["If ",(0,t.jsx)(s.code,{children:"N"})," isn\u2019t a valid capture group (whether the name doesn\u2019t exist or\nisn\u2019t a valid index), then it is replaced with the empty string."]}),"\n",(0,t.jsxs)(s.p,{children:["The longest possible name is used. For example, ",(0,t.jsx)(s.code,{children:"$1a"})," looks up the\ncapture group named ",(0,t.jsx)(s.code,{children:"1a"})," and not the capture group at index ",(0,t.jsx)(s.code,{children:"1"}),". To\nexert more precise control over the name, use braces, e.g., ",(0,t.jsx)(s.code,{children:"${1}a"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["To write a literal ",(0,t.jsx)(s.code,{children:"$"})," use ",(0,t.jsx)(s.code,{children:"$$"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"Examples:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"select regexp_replace('1078910', '[^01]');\n1010\n\nselect regexp_replace('deep fried', '(?<first>\\w+)\\s+(?<second>\\w+)', '${first}_$second');\ndeep_fried\n\nselect regexp_replace('Springsteen, Bruce', '([^,\\s]+),\\s+(\\S+)', '$2 $1');\nBruce Springsteen\n\nselect regexp_replace('Springsteen, Bruce', '(?<last>[^,\\s]+),\\s+(?<first>\\S+)', '$first $last');\nBruce Springsteen\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Note that using ",(0,t.jsx)(s.code,{children:"$2"})," instead of ",(0,t.jsx)(s.code,{children:"$first"})," or ",(0,t.jsx)(s.code,{children:"$1"})," instead of ",(0,t.jsx)(s.code,{children:"$last"}),"\nwould produce the same result."]})]})}function o(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>i,x:()=>d});var n=r(96540);const t={},c=n.createContext(t);function i(e){const s=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(c.Provider,{value:s},e.children)}}}]);