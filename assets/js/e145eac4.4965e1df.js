"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[4119],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(96540);const d={},t=i.createContext(d);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},75939:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"sql/types","title":"Data Types","description":"The compiler supports the following SQL data types:","source":"@site/docs/sql/types.md","sourceDirName":"sql","slug":"/sql/types","permalink":"/sql/types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Identifiers","permalink":"/sql/identifiers"},"next":{"title":"Aggregate Operations","permalink":"/sql/aggregates"}}');var d=s(74848),t=s(28453);const r={},c="Data Types",l={},o=[{value:"Computations on nullable types",id:"computations-on-nullable-types",level:2},{value:"User-defined types",id:"user-defined-types",level:2},{value:"New type names for existing types",id:"new-type-names-for-existing-types",level:3},{value:"New structure types",id:"new-structure-types",level:3},{value:"Grammar for specifying types",id:"grammar-for-specifying-types",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"data-types",children:"Data Types"})}),"\n",(0,d.jsx)(n.p,{children:"The compiler supports the following SQL data types:"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Name"}),(0,d.jsx)(n.th,{children:"Description"}),(0,d.jsx)(n.th,{children:"Aliases"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"BOOLEAN"})}),(0,d.jsx)(n.td,{children:"A boolean value"}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"BOOL"})})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"TINYINT"})}),(0,d.jsx)(n.td,{children:"8-bit signed integer using two's complement."}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"SMALLINT"})}),(0,d.jsx)(n.td,{children:"16-bit signed integer using two's complement."}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"INT2"})})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"INTEGER"})}),(0,d.jsx)(n.td,{children:"32-bit signed integer using two's complement."}),(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"INT"}),", ",(0,d.jsx)(n.code,{children:"SIGNED"}),", ",(0,d.jsx)(n.code,{children:"INT4"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"BIGINT"})}),(0,d.jsx)(n.td,{children:"64-bit signed integer using two's complement."}),(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"INT8"}),", ",(0,d.jsx)(n.code,{children:"INT64"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"DECIMAL(precision, scale)"})}),(0,d.jsx)(n.td,{children:"A high precision fixed-point type, with a precision (total number of decimal digits) and a scale (number of decimal digits after period)."}),(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"DEC"}),", ",(0,d.jsx)(n.code,{children:"NUMERIC"}),", ",(0,d.jsx)(n.code,{children:"NUMBER"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"REAL"})}),(0,d.jsx)(n.td,{children:"IEEE 32-bit floating point number"}),(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"FLOAT4"}),", ",(0,d.jsx)(n.code,{children:"FLOAT32"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"DOUBLE"})}),(0,d.jsx)(n.td,{children:"IEEE 64-bit floating point number"}),(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"FLOAT8"}),", ",(0,d.jsx)(n.code,{children:"FLOAT64"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"VARCHAR(n)"})}),(0,d.jsx)(n.td,{children:"A string value with maximum fixed width. Trailing spaces are removed when converting a value to this type."}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"CHARACTER VARYING(n)"})})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"CHAR(n)"})}),(0,d.jsx)(n.td,{children:"A string value with a fixed width. Values are truncated if longer, or padded with spaces if shorter, to be brought to the specified size."}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"CHARACTER(n)"})})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"VARCHAR"})}),(0,d.jsxs)(n.td,{children:["A string of unlimited length. Trailing spaces are removed when converting a ",(0,d.jsx)(n.code,{children:"CHAR(n)"})," value to this type."]}),(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"STRING"}),", ",(0,d.jsx)(n.code,{children:"TEXT"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"BINARY(n)"})}),(0,d.jsx)(n.td,{children:"A byte string with a fixed width; n is the number of bytes."}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"VARBINARY"})}),(0,d.jsx)(n.td,{children:"A byte string with an unlimited width."}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"BYTEA"})})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"NULL"})}),(0,d.jsxs)(n.td,{children:["A type comprising only the ",(0,d.jsx)(n.code,{children:"NULL"})," value."]}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"INTERVAL"})}),(0,d.jsx)(n.td,{children:"A SQL interval. Two types of intervals are supported: long intervals (comprising years and months), and short intervals, comprising days, hours, minutes, seconds."}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"TIME"})}),(0,d.jsx)(n.td,{children:"A time of the day."}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"TIMESTAMP"})}),(0,d.jsx)(n.td,{children:"A value containing a date and a time without a timezone."}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"DATETIME"})})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"DATE"})}),(0,d.jsx)(n.td,{children:"A date value."}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"GEOMETRY"})}),(0,d.jsx)(n.td,{children:"A geographic data type (only rudimentary support at this point)."}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"ROW"})}),(0,d.jsxs)(n.td,{children:["A tuple (anonymous struct with named fields) with 1 or more elements.  Example ",(0,d.jsx)(n.code,{children:"ROW(left int null, right varchar)"})]}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"ARRAY"})}),(0,d.jsxs)(n.td,{children:["An array with element of the specified type. Used as a suffix for another type (e.g., ",(0,d.jsx)(n.code,{children:"INT ARRAY"}),")"]}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"MAP"})}),(0,d.jsxs)(n.td,{children:["A map with keys and values of specified types. The syntax is ",(0,d.jsx)(n.code,{children:"MAP<KEYTYPE, VALUETYPE>"})]}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"UUID"})}),(0,d.jsx)(n.td,{children:"An 128 bit unique identifier"}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"VARIANT"})}),(0,d.jsx)(n.td,{children:"A dynamically-typed value that can wrap any other SQL type"}),(0,d.jsx)(n.td,{})]})]})]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["For ",(0,d.jsx)(n.code,{children:"DECIMAL"})," types: 23.456 has a precision of 5 and a scale of 3.\nIf scale is missing it is assumed to be 0."]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["A suffix of ",(0,d.jsx)(n.code,{children:"NULL"})," or ",(0,d.jsx)(n.code,{children:"NOT NULL"})," can be appended to a type name to\nindicate the nullability. A type with no suffix is not nullable by\ndefault.  These suffixes do not work for types of elements of ARRAYs\nor MAPs.  ARRAY elements and MAP values are always nullable, while\nMAP keys are never nullable."]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"FLOAT"})," type is not supported. Please use ",(0,d.jsx)(n.code,{children:"REAL"})," or\n",(0,d.jsx)(n.code,{children:"DOUBLE"})," instead. Various SQL dialects do not agree on the size of\nthe ",(0,d.jsx)(n.code,{children:"FLOAT"})," type, so we have decided to prohibit its use to avoid\nsubtle bugs."]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"INTERVAL"}),", ",(0,d.jsx)(n.code,{children:"NULL"})," and types are currently not supported in table\nschemas or as types for the columns of output views (non-",(0,d.jsx)(n.code,{children:"LOCAL"}),"\nviews)."]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"VARIANT"})," is used to implement JSON.  See ",(0,d.jsx)(n.a,{href:"/sql/json",children:"JSON support"})]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)("a",{id:"row_constructor"}),"Values of type ",(0,d.jsx)(n.code,{children:"ROW"})," can be constructed\nusing the ",(0,d.jsx)(n.code,{children:"ROW(x, y, z)"})," syntax, or, when not ambiguous, using the\ntuple syntax ",(0,d.jsx)(n.code,{children:"(x, y, z)"}),", where ",(0,d.jsx)(n.code,{children:"x"}),", ",(0,d.jsx)(n.code,{children:"y"}),", and ",(0,d.jsx)(n.code,{children:"z"})," are expressions.\nE.g. ",(0,d.jsx)(n.code,{children:"SELECT x, (y, z+2) FROM T"}),", is equivalent to ",(0,d.jsx)(n.code,{children:"SELECT x, ROW(y, z+2) FROM T"}),"."]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"computations-on-nullable-types",children:"Computations on nullable types"}),"\n",(0,d.jsxs)(n.p,{children:["A type is nullable if it can represent the ",(0,d.jsx)(n.code,{children:"NULL"})," value. For input\ntables the nullability of a column is declared explicitly. For\nintermediate results and output views the compiler infers the\nnullability of each column using type inference rules."]}),"\n",(0,d.jsxs)(n.p,{children:["Most SQL operations are defined for nullable types. Our compiler\nfollows the SQL standard in this respect. Most operations (e.g.,\n",(0,d.jsx)(n.code,{children:"+"}),"), when applied a ",(0,d.jsx)(n.code,{children:"NULL"})," operand will produce a ",(0,d.jsx)(n.code,{children:"NULL"}),"\nvalue."]}),"\n",(0,d.jsx)(n.h2,{id:"user-defined-types",children:"User-defined types"}),"\n",(0,d.jsx)(n.p,{children:"Users can declare new types.  Such types can be used for columns,\nrecord fields, user-defined function parameters or results."}),"\n",(0,d.jsx)(n.p,{children:"We distinguish two kinds of user-defined types:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Users can define new type names for existing types"}),"\n",(0,d.jsx)(n.li,{children:"Users can define new record types"}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"new-type-names-for-existing-types",children:"New type names for existing types"}),"\n",(0,d.jsx)(n.p,{children:"The following example shows a table using two user-defined types:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE INT32 AS INTEGER;\nCREATE TYPE IA AS INT ARRAY;\nCREATE TABLE T(x INT32, a IA);\n"})}),"\n",(0,d.jsx)(n.h3,{id:"new-structure-types",children:"New structure types"}),"\n",(0,d.jsxs)(n.p,{children:["The syntax for defining new structures resembles the syntax for\ndefining tables.  For example, we can declare types ",(0,d.jsx)(n.code,{children:"address_typ"})," and\n",(0,d.jsx)(n.code,{children:"employee_typ"}),":"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE address_typ AS (\n   street          VARCHAR(30),\n   city            VARCHAR(20),\n   state           CHAR(2),\n   postal_code     VARCHAR(6));\n\nCREATE TYPE employee_typ AS (\n  employee_id       DECIMAL(6),\n  first_name        VARCHAR(20),\n  last_name         VARCHAR(25),\n  email             VARCHAR(25),\n  phone_number      VARCHAR(20),\n  hire_date         DATE,\n  job_id            VARCHAR(10),\n  salary            DECIMAL(8,2),\n  commission_pct    DECIMAL(2,2),\n  manager_id        DECIMAL(6),\n  department_id     DECIMAL(4),\n  address           address_typ);\n"})}),"\n",(0,d.jsx)(n.p,{children:"Recursive or mutually-recursive user-defined types are currently not\nsupported (i.e.  a user-defined type cannot have a field that refers\nto the type itself)."}),"\n",(0,d.jsx)(n.p,{children:"An expression that constructs a structure uses the type name, e.g.:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-sql",children:"employee_typ(315, 'Francis', 'Logan', 'FLOGAN',\n    '555.777.2222', DATE '2004-05-01', 'SA_MAN', 11000, .15, 101, 110,\n     address_typ('376 Mission', 'San Francisco', 'CA', '94222'))\n"})}),"\n",(0,d.jsx)(n.p,{children:"Tables can have structure-valued columns, but these have to be fully\nqualified using both the table name and the column name in programs:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE PERS(p0 employee_typ, p1 employee_typ);\nCREATE VIEW V AS SELECT PERS.p0.address FROM PERS\nWHERE PERS.p0.first_name = 'Mike'\n"})}),"\n",(0,d.jsx)(n.h2,{id:"grammar-for-specifying-types",children:"Grammar for specifying types"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"type:\n      typeName\n      [ collectionsTypeName ]*\n\ntypeName:\n      sqlTypeName\n  |   compoundIdentifier\n  |   MAP < type , type >\n  |   ROW ( columnDecl [, columnDecl ]* )\n\nsqlTypeName:\n      char [ precision ] [ charSet ]\n  |   varchar [ precision ] [ charSet ]\n  |   DATE\n  |   time\n  |   timestamp\n  |   GEOMETRY\n  |   decimal [ precision [, scale] ]\n  |   BOOLEAN\n  |   integer\n  |   BINARY [ precision ]\n  |   varbinary [ precision ]\n  |   TINYINT\n  |   SMALLINT\n  |   BIGINT\n  |   REAL\n  |   double\n  |   VARIANT\n\ncollectionsTypeName:\n      ARRAY\n\nchar:\n      CHARACTER | CHAR\n\nvarchar:\n      char VARYING | VARCHAR\n\ndecimal:\n      DECIMAL | DEC | NUMERIC | NUMBER\n\ninteger:\n      INTEGER | INT\n\nvarbinary:\n      BINARY VARYING | VARBINARY\n\ndouble:\n      DOUBLE [ PRECISION ]\n\ntime:\n      TIME [ precision ] [ timeZone ]\n\ntimestamp:\n      TIMESTAMP [ precision ] [ timeZone ]\n\ncharSet:\n      CHARACTER SET charSetName\n\ntimeZone:\n      WITHOUT TIME ZONE\n"})}),"\n",(0,d.jsxs)(n.p,{children:["A ",(0,d.jsx)(n.code,{children:"compoundIdentifier"})," is a sequence of identifiers separated by dots."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}}}]);