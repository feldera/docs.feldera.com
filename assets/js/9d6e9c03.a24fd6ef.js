"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[8332],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},47203:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/files/vldb23-1bfe30b29f95168c8e1f427fccfc6da2.pdf"},75617:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorials/basics/part2","title":"Part 2: HTTP-based Input and Output","description":"In Part 1 of this tutorial we created our first Feldera pipeline.","source":"@site/docs/tutorials/basics/part2.md","sourceDirName":"tutorials/basics","slug":"/tutorials/basics/part2","permalink":"/tutorials/basics/part2","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Part 1: Writing and testing your first SQL pipeline","permalink":"/tutorials/basics/part1"},"next":{"title":"Part 3: Input and Output Connectors","permalink":"/tutorials/basics/part3"}}');var r=t(74848),i=t(28453);const a={},o="Part 2: HTTP-based Input and Output",c={},d=[{value:"Step 1. Restart the pipeline",id:"step-1-restart-the-pipeline",level:2},{value:"Step 2. Subscribe to output changes",id:"step-2-subscribe-to-output-changes",level:2},{value:"Step 3. Populate inputs",id:"step-3-populate-inputs",level:2},{value:"Step 4. Modify inputs",id:"step-4-modify-inputs",level:2},{value:"Takeaways",id:"takeaways",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"part-2-http-based-input-and-output",children:"Part 2: HTTP-based Input and Output"})}),"\n",(0,r.jsx)(n.p,{children:"In Part 1 of this tutorial we created our first Feldera pipeline.\nThe next step is to ingest data into SQL tables from external sources and to\nsend query outputs to external sinks.  Feldera supports two methods to\naccomplish this: (1) HTTP-based and (2) connector-based input/output.  We cover\nthese two methods in this and the next sections of the tutorial respectively."}),"\n",(0,r.jsx)(n.p,{children:"In Part 2 of the tutorial we will"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Learn to send inputs to and consume outputs from a Feldera pipeline via HTTP."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Introduce another key concept behind Feldera: ",(0,r.jsx)(n.em,{children:"incremental query\nevaluation"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"step-1-restart-the-pipeline",children:"Step 1. Restart the pipeline"}),"\n",(0,r.jsx)(n.p,{children:"Start the pipeline you created in Part 1 of the tutorial from a clean state:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If the pipeline is still running, click ",(0,r.jsx)("icon",{icon:"bx:stop"})," to shut it down."]}),"\n",(0,r.jsxs)(n.li,{children:["Click ",(0,r.jsx)("icon",{icon:"bx:play"})," to restart the pipeline."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"step-2-subscribe-to-output-changes",children:"Step 2. Subscribe to output changes"}),"\n",(0,r.jsxs)(n.p,{children:["Subscribe to changes to the ",(0,r.jsx)(n.code,{children:"PREFERRED_VENDOR"})," view:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"curl -s -N -X 'POST' http://127.0.0.1:8080/v0/pipelines/supply_chain/egress/PREFERRED_VENDOR?format=json | jq\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should see periodic heartbeat messages:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "sequence_number": 0\n}\n{\n  "sequence_number": 1\n}\n{\n  "sequence_number": 2\n}\n{\n  "sequence_number": 3\n}\n...\n'})}),"\n",(0,r.jsx)(n.h2,{id:"step-3-populate-inputs",children:"Step 3. Populate inputs"}),"\n",(0,r.jsxs)(n.p,{children:["In another terminal, use the following command to populate the ",(0,r.jsx)(n.code,{children:"PART"})," table\nwith the same data we entered manually in part 1 of the tutorial:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X \'POST\' http://127.0.0.1:8080/v0/pipelines/supply_chain/ingress/PART?format=json -d \'\n{"insert": {"id": 1, "name": "Flux Capacitor"}}\n{"insert": {"id": 2, "name": "Warp Core"}}\n{"insert": {"id": 3, "name": "Kyber Crystal"}}\'\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The request URL includes the table name (",(0,r.jsx)(n.code,{children:"PART"}),") and the input data format\n(",(0,r.jsx)(n.code,{children:"json"}),').  The request payload consists of newline-delimited JSON objects, where\neach object specifies a command (in this case, "insert") and a record to insert.\nRecords are encoded as JSON objects with one key per table column.']}),"\n",(0,r.jsx)(n.p,{children:"Next, we populate the other two tables:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X \'POST\' http://127.0.0.1:8080/v0/pipelines/supply_chain/ingress/VENDOR?format=json -d \'\n{"insert": {"id": 1, "name": "Gravitech Dynamics", "address": "222 Graviton Lane"}}\n{"insert": {"id": 2, "name": "HyperDrive Innovations", "address": "456 Warp Way"}}\n{"insert": {"id": 3, "name": "DarkMatter Devices", "address": "333 Singularity Street"}}\'\n\ncurl -X \'POST\' http://127.0.0.1:8080/v0/pipelines/supply_chain/ingress/PRICE?format=json -d \'\n{"insert": {"part": 1, "vendor": 2, "price": 10000}}\n{"insert": {"part": 2, "vendor": 1, "price": 15000}}\n{"insert": {"part": 3, "vendor": 3, "price": 9000}}\'\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You should now see the following output in the terminal that is\nlistening to changes to the ",(0,r.jsx)(n.code,{children:"PREFERRED_VENDOR"})," view (the ",(0,r.jsx)(n.code,{children:"insert"}),"s\nmight appear in a different order):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "sequence_number": 9,\n  "json_data": [\n    {\n      "insert": {\n        "part_id": 1,\n        "part_name": "Flux Capacitor",\n        "vendor_id": 2,\n        "vendor_name": "HyperDrive Innovations",\n        "price": "10000"\n      }\n    }\n  ]\n}\n{\n  "sequence_number": 10,\n  "json_data": [\n    {\n      "insert": {\n        "part_id": 2,\n        "part_name": "Warp Core",\n        "vendor_id": 1,\n        "vendor_name": "Gravitech Dynamics",\n        "price": "15000"\n      }\n    },\n    {\n      "insert": {\n        "part_id": 3,\n        "part_name": "Kyber Crystal",\n        "vendor_id": 3,\n        "vendor_name": "DarkMatter Devices",\n        "price": "9000"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"We will learn to decipher this in a moment."}),"\n",(0,r.jsx)(n.h2,{id:"step-4-modify-inputs",children:"Step 4. Modify inputs"}),"\n",(0,r.jsx)(n.p,{children:"We already know that Feldera continuously updates output views in response to\ninput changes.  But what does this mean exactly?  Is it simply a matter of\nre-running the queries whenever a change occurs?  Thankfully, Feldera does\nsomething much more efficient."}),"\n",(0,r.jsxs)(n.p,{children:["Let us push some changes to the ",(0,r.jsx)(n.code,{children:"PRICE"})," table, causing query results to change\n(make sure that you are still monitoring the ",(0,r.jsx)(n.code,{children:"PREFERRED_VENDOR"})," view in a\nseparate terminal).  We use ",(0,r.jsx)(n.code,{children:"delete"})," commands to remove existing records.  Note\nthat there is no ",(0,r.jsx)(n.code,{children:"update"})," command.  Modifying a record amounts to deleting the\nold version and inserting the new one."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X \'POST\' http://127.0.0.1:8080/v0/pipelines/supply_chain/ingress/PRICE?format=json -d \'\n{"delete": {"part": 1, "vendor": 2, "price": 10000}}\n{"insert": {"part": 1, "vendor": 2, "price": 30000}}\n{"delete": {"part": 2, "vendor": 1, "price": 15000}}\n{"insert": {"part": 2, "vendor": 1, "price": 50000}}\n{"insert": {"part": 1, "vendor": 3, "price": 20000}}\n{"insert": {"part": 2, "vendor": 3, "price": 11000}}\'\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Vendors 1 and 2 have increased their prices, while vendor 3 has added\nmore parts to its price list, becoming the cheapest supplier of parts\n1, 2, and 3.  This yields the following output in the\n",(0,r.jsx)(n.code,{children:"PREFERRED_VENDOR"})," view (the order of the operations might appear\ndifferent):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n   "sequence_number": 84,\n   "json_data": [\n      {\n         "delete": {\n            "PART_ID": 1,\n            "PART_NAME": "Flux Capacitor",\n            "PRICE": "10000",\n            "VENDOR_ID": 2,\n            "VENDOR_NAME": "HyperDrive Innovations"\n         }\n      },\n      {\n         "insert": {\n            "PART_ID": 1,\n            "PART_NAME": "Flux Capacitor",\n            "PRICE": "20000",\n            "VENDOR_ID": 3,\n            "VENDOR_NAME": "DarkMatter Devices"\n         }\n      },\n      {\n         "delete": {\n            "PART_ID": 2,\n            "PART_NAME": "Warp Core",\n            "PRICE": "15000",\n            "VENDOR_ID": 1,\n            "VENDOR_NAME": "Gravitech Dynamics"\n         }\n      },\n      {\n         "insert": {\n            "PART_ID": 2,\n            "PART_NAME": "Warp Core",\n            "PRICE": "11000",\n            "VENDOR_ID": 3,\n            "VENDOR_NAME": "DarkMatter Devices"\n         }\n      },\n   ]\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This output contains an array of ",(0,r.jsx)(n.code,{children:"insert"})," and ",(0,r.jsx)(n.code,{children:"delete"})," commands that describe an update\nto the view in terms of records that are no longer present and must be deleted\nand new records to be added to the view.  The new version of the view can be\nconstructed by applying these changes to its previous snapshot."]}),"\n",(0,r.jsx)(n.p,{children:"Thus, Feldera does not output the complete view, but only the set of changes to\nthe previous version of the view.  As more input changes arrive, Feldera\ncomputes additional output updates on top of all previous updates (give it a\ntry!)."}),"\n",(0,r.jsxs)(n.p,{children:["This reflects the internal workings of Feldera: instead of reevaluating the\nquery from scratch on every new input, it only updates affected outputs by\npropagating input changes through the query execution plan.  We refer to this as\n",(0,r.jsx)(n.strong,{children:"incremental query evaluation"}),".  See our ",(0,r.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(47203).A+"",children:"paper"})," for a rigorous\ndescription of this technique."]}),"\n",(0,r.jsx)(n.h2,{id:"takeaways",children:"Takeaways"}),"\n",(0,r.jsx)(n.p,{children:"Let us review:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Feldera operates on ",(0,r.jsx)(n.strong,{children:"changes"}),": a Feldera pipeline transforms a stream of\ninput changes to SQL tables into a stream of output changes to SQL views."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"One way to send input changes to a pipeline and consume output changes from it\nis using HTTP."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Internally, Feldera also works with changes: the Feldera query engine employs\nincremental algorithms to compute only what has changed in each view without\nrequiring a full re-computation."}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);