"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[9359],{1715:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"connectors/unique_keys","title":"Uniqueness Constraints","description":"Feldera does not require tables or views to have unique keys. However, specifying","source":"@site/docs/connectors/unique_keys.md","sourceDirName":"connectors","slug":"/connectors/unique_keys","permalink":"/connectors/unique_keys","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Connectors: connect to data sources and sinks","permalink":"/connectors/"},"next":{"title":"Input connector orchestration","permalink":"/connectors/orchestration"}}');var i=s(74848),r=s(28453);const o={},a="Uniqueness Constraints",d={},l=[{value:"Ingesting Data into Tables with Primary Keys",id:"ingesting-data-into-tables-with-primary-keys",level:2},{value:"Views with Unique Keys",id:"views-with-unique-keys",level:2},{value:"Example",id:"example",level:3},{value:"Postgres",id:"postgres",level:4},{value:"Avro Format",id:"avro-format",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"uniqueness-constraints",children:"Uniqueness Constraints"})}),"\n",(0,i.jsx)(n.p,{children:"Feldera does not require tables or views to have unique keys. However, specifying\nthem where applicable can improve the reliability of data ingestion from external\nsources and data delivery to external sinks in two key ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Idempotent updates."})," Unique keys enable idempotent updates by ensuring that\neach record in a table or view has a unique and stable identifier. This allows systems\nto deterministically overwrite existing records, avoiding duplication when processing\nrepeated updates."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Atomic updates."})," Unique keys allow updates to be applied as single atomic\noperations, rather than as separate delete and insert events."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Below, we describe how unique keys are defined and used for tables and views in Feldera."}),"\n",(0,i.jsx)(n.h2,{id:"ingesting-data-into-tables-with-primary-keys",children:"Ingesting Data into Tables with Primary Keys"}),"\n",(0,i.jsxs)(n.p,{children:["Feldera supports ",(0,i.jsx)(n.code,{children:"PRIMARY KEY"})," constraints on tables using standard SQL\n",(0,i.jsx)(n.a,{href:"/sql/grammar/#creating-tables",children:"syntax"}),". These constraints are enforced at runtime by\nmaintaining an internal index on the specified key columns:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["On ",(0,i.jsx)(n.strong,{children:"insert events"}),", Feldera atomically overwrites any existing record with the same primary key."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["On ",(0,i.jsx)(n.strong,{children:"delete events"}),", Feldera verifies that the specified key exists before applying the deletion.\nIf no matching record is found, the delete is ignored."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"views-with-unique-keys",children:"Views with Unique Keys"}),"\n",(0,i.jsx)(n.p,{children:"As Feldera processes changes to input tables, it emits incremental updates to output views as a stream of inserts and deletes. An update to an existing record is represented as a delete of the old value followed by an insert of the new value. In many cases, it is preferable to combine these two events into a single atomic update, which requires identifying them as pertaining to the same key."}),"\n",(0,i.jsxs)(n.p,{children:["The SQL language does not support primary or unique key constraints on views. Instead we use the ",(0,i.jsxs)(n.a,{href:"/sql/grammar/",children:[(0,i.jsx)(n.code,{children:"CREATE INDEX"})," statement"]})," to define the key\nas follows:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"CREATE INDEX ON <view_name>(<column1>, ..., <columnN>)"})," statement to create an index that groups updates by the specified key columns."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Associate the index with an output connector by setting the connector\u2019s ",(0,i.jsx)(n.code,{children:"index"})," property to the name of the index. This allows the connector to merge insert and delete events for the same key into a single update event."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The specific behavior of this transformation depends on the data format and transport protocol used. Currently, the ",(0,i.jsx)(n.code,{children:"index"})," property is supported only for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Kafka output connectors configured with the ",(0,i.jsx)(n.a,{href:"/formats/avro/",children:"Avro format"})]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/connectors/sinks/postgresql",children:"Postgres output connector"})}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Do you need unique key support for other transports and data formats?\nLet us know by ",(0,i.jsx)(n.a,{href:"https://github.com/feldera/feldera/issues",children:"filing an\nissue"})," on GitHub."]})}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.h4,{id:"postgres",children:"Postgres"}),"\n",(0,i.jsxs)(n.p,{children:["See the ",(0,i.jsx)(n.a,{href:"/connectors/sinks/postgresql",children:"Postgres Output Connector documentation"}),"\nfor more examples."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'create table t0 (id int, s varchar);\n\ncreate materialized view v1 with (\n    \'connectors\' = \'[{\n        "index": "v1_idx",\n        "transport": {\n            "name": "postgres_output",\n            "config": {\n                "uri": "postgres://postgres:password@localhost:5432/postgres",\n                "table": "feldera_out"\n            }\n        }\n    }]\'\n) as select * from t0;\ncreate index v1_idx on v1(id);\n'})}),"\n",(0,i.jsx)(n.h4,{id:"avro-format",children:"Avro Format"}),"\n",(0,i.jsxs)(n.p,{children:["See the ",(0,i.jsx)(n.a,{href:"/formats/avro#examples-1",children:"Avro format documentation"})," for more examples."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'create table my_table (\n   id bigint,\n   name string\n);\n\ncreate view my_view\nwith (\n  -- Associate `my_index` (see below) with an output connector via the connector\u2019s `index` property.\n  \'connectors\' = \'[{\n    "index": "my_index",\n    "transport": {\n      "name": "kafka_output",\n      "config": {\n        "bootstrap.servers": "127.0.0.1:19092",\n        "topic": "my_topic",\n        "auto.offset.reset": "earliest"\n      }\n    },\n    "format": {\n      "name": "avro",\n      "config": {\n        "update_format": "raw",\n        "registry_urls": ["http://127.0.0.1:18081"]\n      }\n    }\n  }]\'\n)\nas\n   select * from my_view;\n\n-- Create an index over `my_view`.\ncreate index my_index on my_view(id);\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Unlike primary key constraints on tables, uniqueness of indexes on views is ",(0,i.jsx)(n.strong,{children:"not enforced"})," by the Feldera query engine. If an index is defined on columns that do not guarantee uniqueness, this may lead to incorrect behavior or data loss."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);