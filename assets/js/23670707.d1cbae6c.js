"use strict";(self.webpackChunkfeldera_docs=self.webpackChunkfeldera_docs||[]).push([[1339],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var i=s(96540);const a={},t=i.createContext(a);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},38046:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"sql/json","title":"JSON and Dynamically-Typed Value Support","description":"Direct conversion of JSON strings to User-Defined data types","source":"@site/docs/sql/json.md","sourceDirName":"sql","slug":"/sql/json","permalink":"/sql/json","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Integer Operations","permalink":"/sql/integer"},"next":{"title":"Map Operations","permalink":"/sql/map"}}');var a=s(74848),t=s(28453);const r={},d="JSON and Dynamically-Typed Value Support",c={},o=[{value:"Direct conversion of JSON strings to User-Defined data types",id:"direct-conversion-of-json-strings-to-user-defined-data-types",level:2},{value:"The <code>VARIANT</code> type",id:"the-variant-type",level:2},{value:"Functions that operate on <code>VARIANT</code> values",id:"functions-that-operate-on-variant-values",level:2},{value:"<code>PARSE_JSON</code>",id:"parse_json",level:3},{value:"<code>TO_JSON</code>",id:"to_json",level:3},{value:"Processing JSON data using <code>VARIANT</code>",id:"processing-json-data-using-variant",level:2},{value:"Examples",id:"examples",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"json-and-dynamically-typed-value-support",children:"JSON and Dynamically-Typed Value Support"})}),"\n",(0,a.jsx)(n.h2,{id:"direct-conversion-of-json-strings-to-user-defined-data-types",children:"Direct conversion of JSON strings to User-Defined data types"}),"\n",(0,a.jsx)(n.p,{children:"Consider the following example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE address AS (\n   city VARCHAR,\n   street VARCHAR,\n   number INT\n);\n\nCREATE TABLE data(addr VARCHAR);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Let us assume that the table ",(0,a.jsx)(n.code,{children:"data"})," contains JSON strings that encode\naddresses, e.g.,"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'{ "city": "Boston", "street": "Main", "number": 10 }\n'})}),"\n",(0,a.jsx)(n.p,{children:"One way to convert JSON strings to values of a user-defined data type\nis to perform the conversion in two steps:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["parse the JSON string using the ",(0,a.jsx)(n.code,{children:"PARSE_JSON"})," function, described\nbelow.  This function returns a value of type ",(0,a.jsx)(n.code,{children:"VARIANT"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["cast the ",(0,a.jsx)(n.code,{children:"VARIANT"})," value to a value of a user-defined data type."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This can be achieved with the following code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW decoded AS\nSELECT CAST(PARSE_JSON(data.addr) AS address) FROM data;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The conversion to ",(0,a.jsx)(n.code,{children:"VARIANT"})," is wasteful, since often the JSON string\ncan be directly parsed into a user-defined data type.  Since SQL\nprovides no convenient syntax for writing generic functions, the\nFeldera compiler following mechanism:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["The user can declare a function with a name of the form\n",(0,a.jsx)(n.code,{children:"jsonstring_as_<udt>"}),", where ",(0,a.jsx)(n.code,{children:"<udt>"})," is the name of a user-defined\ndata type.  The function's argument is a nullable string type, while\nthe function's result type is a nullable value of the user-defined\ntype."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The compiler will automatically synthesize the body of this function."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The user can directly invoke the function in expressions."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With these changes, the previous program can be rewritten as:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION jsonstring_as_address(addr VARCHAR) RETURNS address;\nCREATE VIEW decoded AS\nSELECT jsonstring_as_address(data.addr) FROM data;\n"})}),"\n",(0,a.jsx)(n.p,{children:"This program is more efficient than the previous one, but achieves the\nalmost the same effect."}),"\n",(0,a.jsxs)(n.p,{children:["There is a subtle difference between the two programs: the former\nprogram, using ",(0,a.jsx)(n.code,{children:"VARIANT"})," requires the case fields in the JSON to match\nthe case of the ",(0,a.jsx)(n.em,{children:"normalized"})," fields in the user-defined type, whereas\nthe automatic function using ",(0,a.jsx)(n.code,{children:"jsonstring"})," is case-insensitive.  With\nthe default settings, the following record:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'{ "city": "Boston", "street": "Main", "NUMBER": 10 }\n'})}),"\n",(0,a.jsxs)(n.p,{children:["returns a structure with a ",(0,a.jsx)(n.code,{children:"NULL"})," value for the ",(0,a.jsx)(n.code,{children:"NUMBER"})," field using\nthe first method.  Using the second method all three fields are\ndeserialized."]}),"\n",(0,a.jsxs)(n.h2,{id:"the-variant-type",children:["The ",(0,a.jsx)(n.code,{children:"VARIANT"})," type"]}),"\n",(0,a.jsxs)(n.p,{children:["Values of ",(0,a.jsx)(n.code,{children:"VARIANT"})," type are dynamically-typed.\nAny such value holds at runtime two pieces of information:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the data type"}),"\n",(0,a.jsx)(n.li,{children:"the data value"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Values of ",(0,a.jsx)(n.code,{children:"VARIANT"})," type can be created by casting any other value to\na ",(0,a.jsx)(n.code,{children:"VARIANT"}),", e.g., ",(0,a.jsx)(n.code,{children:"SELECT CAST(x AS VARIANT)"}),".  Conversely, values of\ntype ",(0,a.jsx)(n.code,{children:"VARIANT"})," can be cast to any other data type, e.g., ",(0,a.jsx)(n.code,{children:"SELECT CAST(v AS INT)"}),".\nA cast of a value of type ",(0,a.jsx)(n.code,{children:"VARIANT"})," to target type ",(0,a.jsx)(n.code,{children:"T"})," will\ncompare the runtime type with ",(0,a.jsx)(n.code,{children:"T"}),".  If the types are identical or there\nis a natural conversion from the runtime type to ",(0,a.jsx)(n.code,{children:"T"}),", the original value\nis returned.  Otherwise the ",(0,a.jsx)(n.code,{children:"CAST"})," returns ",(0,a.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["A value of type ",(0,a.jsx)(n.code,{children:"VARIANT"})," that stores a ",(0,a.jsx)(n.code,{children:"MAP"})," can be converted to a\nuser-defined type.  Each name of a field of the user-defined type is\nused as an index into the map.  If a field is missing in the map and\nthe corresponding field of the struct gets the ",(0,a.jsx)(n.code,{children:"NULL"})," value.  Fields\nin the map that do not correspond to the struct field names are\nignored."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["Remember that the ",(0,a.jsx)(n.code,{children:"DECIMAL"})," type specified without precision is the\nsame as ",(0,a.jsx)(n.code,{children:"DECIMAL(0)"}),", with no digits after the decimal point.  When\nyou cast a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value to ",(0,a.jsx)(n.code,{children:"DECIMAL"})," you should specify a precision\nand scale large enough for the values that you expect in the data."]})}),"\n",(0,a.jsxs)(n.p,{children:["Values of type ",(0,a.jsx)(n.code,{children:"ARRAY"}),", ",(0,a.jsx)(n.code,{children:"MAP"})," and user-defined types can be cast to\n",(0,a.jsx)(n.code,{children:"VARIANT"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["There exists a special value of ",(0,a.jsx)(n.code,{children:"VARIANT"})," type called ",(0,a.jsx)(n.code,{children:"null"}),".  This\nvalue is different from the SQL ",(0,a.jsx)(n.code,{children:"NULL"})," value.  It is used to implement\nthe JSON ",(0,a.jsx)(n.code,{children:"null"})," value.  An important difference is that two ",(0,a.jsx)(n.code,{children:"VARIANT"}),"\n",(0,a.jsx)(n.code,{children:"null"})," values are equal, whereas ",(0,a.jsx)(n.code,{children:"NULL"})," in SQL is not equal to anything."]}),"\n",(0,a.jsxs)(n.p,{children:["Converting a user-defined type to a ",(0,a.jsx)(n.code,{children:"VARIANT"})," produces a ",(0,a.jsx)(n.code,{children:"VARIANT"}),"\nstoring a value of type ",(0,a.jsx)(n.code,{children:"MAP<VARCHAR, VARIANT>"}),", where each field of\nthe map corresponds to a field of the user-defined structure."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"VARIANT"})," values also offer the following operations:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["indexing using array indexing notation ",(0,a.jsx)(n.code,{children:"variant[index]"}),".  If the ",(0,a.jsx)(n.code,{children:"VARIANT"})," is\nobtained from an ",(0,a.jsx)(n.code,{children:"ARRAY"})," value, the indexing operation returns a ",(0,a.jsx)(n.code,{children:"VARIANT"})," whose value\nis the element at the specified index.  Otherwise, this operation returns ",(0,a.jsx)(n.code,{children:"NULL"})]}),"\n",(0,a.jsxs)(n.li,{children:["indexing using map element access notation ",(0,a.jsx)(n.code,{children:"variant[key]"}),", where ",(0,a.jsx)(n.code,{children:"key"})," can have\nany legal ",(0,a.jsx)(n.code,{children:"MAP"})," key type.  If the ",(0,a.jsx)(n.code,{children:"VARIANT"})," is obtained from a ",(0,a.jsx)(n.code,{children:"MAP"})," value\nthat has en element with this key, a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value holding the associated value in\nthe ",(0,a.jsx)(n.code,{children:"MAP"})," is returned.  Otherwise ",(0,a.jsx)(n.code,{children:"NULL"})," is returned.  If the ",(0,a.jsx)(n.code,{children:"VARIANT"})," is obtained from\nuser-defined structure which has a field with the name ",(0,a.jsx)(n.code,{children:"key"}),", this operation returns a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value holding\nthe corresponding field value.  Otherwise ",(0,a.jsx)(n.code,{children:"NULL"})," is returned."]}),"\n",(0,a.jsxs)(n.li,{children:["field access using the dot notation: ",(0,a.jsx)(n.code,{children:"variant.field"}),".  This operation is interpreted\nas equivalent to ",(0,a.jsx)(n.code,{children:"variant['field']"}),".  Note, however, that the field notation\nis subject to the capitalization rules of the SQL dialect, so for correct\noperation the field may need to be quoted: ",(0,a.jsx)(n.code,{children:'variant."field"'})]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"functions-that-operate-on-variant-values",children:["Functions that operate on ",(0,a.jsx)(n.code,{children:"VARIANT"})," values"]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Function"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"VARIANTNULL()"})}),(0,a.jsxs)(n.td,{children:["Can be used to create an instance of the ",(0,a.jsx)(n.code,{children:"VARIANT"})," ",(0,a.jsx)(n.code,{children:"null"})," value."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"TYPEOF(variant)"})}),(0,a.jsxs)(n.td,{children:["Argument must be a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value.  Returns a string describing the runtime type of the value"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"PARSE_JSON(string)"})}),(0,a.jsxs)(n.td,{children:["Parses a string that represents a JSON value, returns a ",(0,a.jsx)(n.code,{children:"VARIANT"})," object, or ",(0,a.jsx)(n.code,{children:"NULL"})," if parsing fails (more details ",(0,a.jsx)(n.a,{href:"#parse_json",children:"below"}),")"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"TO_JSON(variant)"})}),(0,a.jsxs)(n.td,{children:["Argument must be a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value.  Returns a string that represents the serialization of a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value. If the value cannot be represented as JSON, the result is ",(0,a.jsx)(n.code,{children:"NULL"})," (more details ",(0,a.jsx)(n.a,{href:"#to_json",children:"below"}),")"]})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"parse_json",children:(0,a.jsx)(n.code,{children:"PARSE_JSON"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"PARSE_JSON"})," converts a JSON value as follows:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["JSON ",(0,a.jsx)(n.code,{children:"null"})," is converted to a ",(0,a.jsx)(n.code,{children:"VARIANT"})," ",(0,a.jsx)(n.code,{children:"null"})," value (not a SQL ",(0,a.jsx)(n.code,{children:"NULL"}),"!); see above the description of ",(0,a.jsx)(n.code,{children:"VARIANT"})," ",(0,a.jsx)(n.code,{children:"null"})]}),"\n",(0,a.jsxs)(n.li,{children:["JSON Booleans are converted to ",(0,a.jsx)(n.code,{children:"BOOLEAN"})," values (wrapped in ",(0,a.jsx)(n.code,{children:"VARIANT"})," values)"]}),"\n",(0,a.jsxs)(n.li,{children:["JSON numbers are converted to ",(0,a.jsx)(n.code,{children:"DECIMAL"})," values (wrapped in ",(0,a.jsx)(n.code,{children:"VARIANT"})," values)"]}),"\n",(0,a.jsxs)(n.li,{children:["JSON strings are converted to ",(0,a.jsx)(n.code,{children:"VARCHAR"})," values (wrapped in ",(0,a.jsx)(n.code,{children:"VARIANT"})," values)"]}),"\n",(0,a.jsxs)(n.li,{children:["JSON arrays are converted to ",(0,a.jsx)(n.code,{children:"VARIANT ARRAY"})," values (wrapped in ",(0,a.jsx)(n.code,{children:"VARIANT"})," values).  Each array element is a ",(0,a.jsx)(n.code,{children:"VARIANT"})]}),"\n",(0,a.jsxs)(n.li,{children:["JSON objects are converted to ",(0,a.jsx)(n.code,{children:"MAP<VARIANT, VARIANT>"})," values (wrapped in ",(0,a.jsx)(n.code,{children:"VARIANT"})," values).  Each key and each value is a ",(0,a.jsx)(n.code,{children:"VARIANT"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For example, ",(0,a.jsx)(n.code,{children:'PARSE_JSON("{"a": 1, "b": [2, 3.3, null]}")'})," generates the same SQL value that would be generated by the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT CAST(\n   MAP[\n      CAST('a' AS VARIANT), CAST(1.0 AS VARIANT),\n      CAST('b' AS VARIANT), CAST(ARRAY[\n          CAST(2.0 AS VARIANT),\n          CAST(3.3 AS VARIANT),\n          VARIANTNULL()\n                                      ] AS VARIANT)\n      ] AS VARIANT)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"to_json",children:(0,a.jsx)(n.code,{children:"TO_JSON"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"TO_JSON"})," converts a ",(0,a.jsx)(n.code,{children:"VARIANT"})," value to a ",(0,a.jsx)(n.code,{children:"VARCHAR"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["the ",(0,a.jsx)(n.code,{children:"VARIANT"})," ",(0,a.jsx)(n.code,{children:"null"})," value is converted to the string ",(0,a.jsx)(n.code,{children:"null"})]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"VARIANT"})," wrapping a Boolean value is converted to the respective Boolean string ",(0,a.jsx)(n.code,{children:"true"})," or ",(0,a.jsx)(n.code,{children:"false"})]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"VARIANT"})," wrapping any numeric value (",(0,a.jsx)(n.code,{children:"DECIMAL"}),", ",(0,a.jsx)(n.code,{children:"TINYINT"}),", ",(0,a.jsx)(n.code,{children:"SMALLINT"}),", ",(0,a.jsx)(n.code,{children:"INTEGER"}),", ",(0,a.jsx)(n.code,{children:"BIGINT"}),", ",(0,a.jsx)(n.code,{children:"TINYINT UNSIGNED"}),",\n",(0,a.jsx)(n.code,{children:"SMALLINT UNSIGNED"}),", ",(0,a.jsx)(n.code,{children:"INT UNSIGNED"}),", ",(0,a.jsx)(n.code,{children:"BIGINT UNSIGNED"}),", ",(0,a.jsx)(n.code,{children:"REAL"}),", ",(0,a.jsx)(n.code,{children:"DOUBLE"}),", ",(0,a.jsx)(n.code,{children:"DECIMAL"}),") is converted\nto the string representation of the value as produced using a ",(0,a.jsx)(n.code,{children:"CAST(value AS VARCHAR)"})]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"VARIANT"})," wrapping a ",(0,a.jsx)(n.code,{children:"VARCHAR"})," value is converted to a string with double quotes, and with escape sequences for special characters (e.g., quotes), as mandated by the JSON grammar"]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"VARIANT"})," wrapping an ",(0,a.jsx)(n.code,{children:"ARRAY"})," with elements of any type is converted to a JSON array, and the elements are recursively converted"]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"VARIANT"})," wrapping a ",(0,a.jsx)(n.code,{children:"MAP"})," whose keys have any SQL ",(0,a.jsx)(n.code,{children:"CHAR"})," type, or ",(0,a.jsx)(n.code,{children:"VARIANT"})," values wrapping ",(0,a.jsx)(n.code,{children:"CHAR"})," values will generate a JSON object, by recursively converting each key-value pair."]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"VARIANT"})," wrapping a ",(0,a.jsx)(n.code,{children:"DATE"}),", ",(0,a.jsx)(n.code,{children:"TIME"}),", or ",(0,a.jsx)(n.code,{children:"DATETIME"})," value will be serialized as a JSON string"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"processing-json-data-using-variant",children:["Processing JSON data using ",(0,a.jsx)(n.code,{children:"VARIANT"})]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"VARIANT"})," type enables efficient JSON processing in SQL.  In this sense it is similar to\nthe ",(0,a.jsx)(n.code,{children:"JSONB"})," type in Postgres and other databases.  There are two ways to convert\nJSON data to and from ",(0,a.jsx)(n.code,{children:"VARIANT"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"PARSE_JSON"})," and ",(0,a.jsx)(n.code,{children:"TO_JSON"})," functions to convert strings to ",(0,a.jsx)(n.code,{children:"VARIANT"})," and back."]}),"\n",(0,a.jsxs)(n.li,{children:["Automatically, when ingesting data to or outputting data from columns of type ",(0,a.jsx)(n.code,{children:"VARIANT"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The following example demonstrates the first approach. Here, input events\ncontain a field called ",(0,a.jsx)(n.code,{children:"json"})," of type string, which carries JSON-encoded data.\nWe ingest this field as a string and use ",(0,a.jsx)(n.code,{children:"PARSE_JSON"})," to convert it to a\n",(0,a.jsx)(n.code,{children:"VARIANT"})," and store the result in an intermediate view."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE json (id INT, json VARCHAR);\nCREATE VIEW parsed_json AS SELECT id, PARSE_JSON(json) AS json FROM json;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Input events can use any ",(0,a.jsx)(n.a,{href:"/formats/",children:"supported data format"}),".  For instance, when\ningesting a ",(0,a.jsx)(n.a,{href:"/formats/json",children:"JSON stream"}),", a valid input record could look like this\n(note the use of escaping in the ",(0,a.jsx)(n.code,{children:"json"})," field):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{"id": 123, "json": "{\\"foo\\": \\"bar\\"}"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The second approach parses JSON into ",(0,a.jsx)(n.code,{children:"VARIANT"})," directly during ingestion, eliminating\nthe need for calling ",(0,a.jsx)(n.code,{children:"PARSE_JSON"})," explicitly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE json (id INT, json VARIANT);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note"})," that this program has a subtly different semantics from the previous one\ndepending on the input ",(0,a.jsx)(n.a,{href:"/formats/",children:"format"})," used.  For most input formats, e.g.,\n",(0,a.jsx)(n.a,{href:"/formats/avro",children:"Avro"}),", ",(0,a.jsx)(n.a,{href:"/formats/parquet",children:"Parquet"}),", or ",(0,a.jsx)(n.a,{href:"/formats/csv",children:"CSV"}),",\nit is equivalent, i.e., it converts an input field of type string into a ",(0,a.jsx)(n.code,{children:"VARIANT"}),".\nHowever, when the input stream carries JSON data using ",(0,a.jsx)(n.a,{href:"/formats/json#the-raw-format",children:"raw"}),"\nor ",(0,a.jsx)(n.a,{href:"/formats/json#the-insertdelete-format",children:"insert/delete"})," encoding, the ",(0,a.jsx)(n.code,{children:"json"})," field can contain\nan arbitrary JSON value, which gets parsed into ",(0,a.jsx)(n.code,{children:"VARIANT"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{"id": 123, "json": {"name": "John Doe", "scores": [8, 10]}}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This is useful for processing  ",(0,a.jsx)(n.strong,{children:"semi-structured"})," data, i.e., data whose schema is only\npartially fixed or is too complex to represent in SQL.\nIn this case, the schema contains an integer field ",(0,a.jsx)(n.code,{children:"id"})," and a field called ",(0,a.jsx)(n.code,{children:"json"}),", whose\nschema is not specified. The ",(0,a.jsx)(n.code,{children:"VARIANT"})," type allows us to parse this field and\nmanipulate its contents.  For instance, the following query\nextracts ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"scores"})," fields, interpets the latter as an array of numbers\nand computes the average of the first two entries in the array:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE json (id INT, json VARIANT);\n\nCREATE VIEW average AS SELECT\nCAST(json['name'] AS VARCHAR) as name,\n((CAST(json['scores'][1] AS DECIMAL(8, 2)) + CAST(json['scores'][2] AS DECIMAL(8, 2))) / 2) as average\nFROM json;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note how object fields are accessed using\nmap indexing operators ",(0,a.jsx)(n.code,{children:"['scores']"}),", ",(0,a.jsx)(n.code,{children:"['name']"}),", and how array\nelements are accessed using indexing with numeric values ",(0,a.jsx)(n.code,{children:"[1]"}),".\nRecall that array indexes in SQL start from 1!"]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, notice how the ",(0,a.jsx)(n.code,{children:"DECIMAL"})," values that are retrieved need to\nspecify the precision and scale: ",(0,a.jsx)(n.code,{children:"CAST(... AS DECIMAL(8, 2))"}),".  Using\n",(0,a.jsx)(n.code,{children:"CAST(... AS DECIMAL)"})," would lose all digits after the decimal point."]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["Here are some simple SQL query examples using ",(0,a.jsx)(n.code,{children:"VARIANT"})," and JSON\nvalues and the expected output values.  (Note that these examples\ncannot be executed directly, since they involve no views.)"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT CAST(1 AS VARIANT)\n1\n\nSELECT TYPEOF(CAST(1 AS VARIANT))\nINTEGER\n\nSELECT CAST(CAST(1 AS TINYINT) AS VARIANT)\n1\n\n-- The runtime knows that this is a TINYINT\nSELECT TYPEOF(CAST(CAST(1 AS TINYINT) AS VARIANT))\nTINYINT\n\n-- Converting something to VARIANT and back works\nSELECT CAST(CAST(1 AS VARIANT) AS INT)\n1\n\n-- Conversions between numeric types are allowed\nSELECT CAST(CAST(1 AS VARIANT) AS TINYINT)\n1\n\n-- Some VARIANT objects when output receive double quotes\nselect CAST('string' as VARIANT)\n\"string\"\n\n-- CHAR(3) values are represented as VARCHAR in variants\nSELECT CAST(CAST('abc' AS VARIANT) AS VARCHAR)\nabc\n\n-- VARCHAR and CHAR(N) have the same underlying runtime type\nSELECT CAST(CAST('abc' AS VARIANT) AS CHAR(3))\nabc\n\n-- The value representing a VARIANT null value (think of a JSON null)\nSELECT VARIANTNULL()\nnull\n\n-- VARIANT null is not the same as SQL NULL\nSELECT VARIANTNULL() IS NULL\nfalse\n\n-- Two VARIANT nulls are equal, unlike SQL NULL\nSELECT VARIANTNULL() = VARIANTNULL()\ntrue\n\nSELECT TYPEOF(VARIANTNULL())\nVARIANT\n\n-- Variants delegate equality to the underlying values\nSELECT CAST(1 AS VARIANT) = CAST(1 AS VARIANT)\ntrue\n\n-- To be equal two variants must have the same value and the same runtime type\nSELECT CAST(1 AS VARIANT) = CAST(CAST(1 AS TINYINT) AS VARIANT)\nfalse\n\n-- An array of variant values can have values with any underlying type\nSELECT ARRAY[CAST(1 AS VARIANT), CAST('abc' AS VARIANT)]\n[1, \"abc\"]\n\n-- A map with VARCHAR keys and VARIANT values\nSELECT MAP['a', CAST(1 AS VARIANT), 'b', CAST('abc' AS VARIANT), 'c', CAST(ARRAY[1,2,3] AS VARIANT)]\n{a=1, b=\"abc\", c=[1, 2, 3]}\n\n-- Variant values allow access by index, but return null if they are not arrays\nSELECT (CAST(1 AS VARIANT))[1]\nnull\n\nSELECT CAST(ARRAY[1,2,3] AS VARIANT)[1]\n1\n\n-- Accessing items in a VARIANT array returns VARIANT values,\n-- even if the array itself does not contain VARIANT values\n-- (Otherwise TYPEOF would not compile)\nSELECT TYPEOF(CAST(ARRAY[1,2,3] AS VARIANT)[1])\nINTEGER\n\nSELECT CAST(x'0102' AS VARIANT)\nx'0102;\n\nSELECT CAST(CAST(x'0102' AS VARBINARY) AS VARIANT)\nx'0102;\n\nSELECT CAST(TIME '10:01:01' AS VARIANT)\n10:01:01\n\n-- One can access fields by name in a VARIANT, even if the\n-- variant does not have named fields\nSELECT CAST(ARRAY[1,2,3] AS VARIANT)['name']\nnull\n\n-- One can access fields by name in a VARIANT, even if the\n-- variant does not have named fields\nSELECT CAST(ARRAY[1,2,3] AS VARIANT).\"name\"\nnull\n\n-- One can access fields by index in a VARIANT\nSELECT CAST(Map[1,'a',2,'b',3,'c'] AS VARIANT)[1]\n\"a\"\n\nSELECT TYPEOF(CAST(Map[1,'a',2,'b',3,'c'] AS VARIANT)[1])\nVARCHAR\n\n-- Note that field name is quoted to match the case of the key\nSELECT CAST(Map['a',1,'b',2,'c',3] AS VARIANT).\"a\"\n1\n\n-- Unquoted uppercase field name does match\nSELECT CAST(Map['A',1,'b',2,'c',3] AS VARIANT).A\nNULL\n\n-- The safest way is to index with a string\nSELECT CAST(Map['a',1,'b',2,'c',3] AS VARIANT)['a']\n1\n\n-- Maps can have variant keys too\n-- (but you have to index with a variant).\nSELECT (Map[CAST('a' AS VARIANT), 1, CAST(1 AS VARIANT), 2])[CAST(1 AS VARIANT)]\n2\n\n-- Navigating a JSON-like object\nSELECT CAST(MAP['a', CAST(1 AS VARIANT), 'b', CAST('abc' AS VARIANT), 'c', CAST(ARRAY[1,2,3] AS VARIANT)]\n               ['c'][1] AS INTEGER)\n1\n\nSELECT PARSE_JSON(1)\n1\n\nSELECT PARSE_JSON('1')\n1\n\n-- Numeric values in JSON are stored as DECIMAL values\nSELECT TYPEOF(PARSE_JSON('1'))\nDECIMAL\n\nSELECT PARSE_JSON('\\\"a\\\"')\n\"a\"\n\nSELECT PARSE_JSON('false')\nfalse\n\n-- A VARIANT null\nSELECT PARSE_JSON('null')\nnull\n\nSELECT TYPEOF(PARSE_JSON('null'))\nVARIANT\n\n-- a SQL null\nSELECT PARSE_JSON(null)\nNULL\n\n\nSELECT PARSE_JSON('[1,2,3]')\n[1, 2, 3]\n\nSELECT PARSE_JSON('{\\\"a\\\": 1, \\\"b\\\": 2}')\n{\"a\"=1,\"b\"=2}\n\n-- all the following are strings\nSELECT TO_JSON(PARSE_JSON(1))\n1\n\nSELECT TO_JSON(null)\nNULL\n\nSELECT TO_JSON(PARSE_JSON('1'))\n1\n\nSELECT TO_JSON(PARSE_JSON('\\\"a\\\"'))\na\n\nSELECT TO_JSON(PARSE_JSON('false'))\nfalse\n\nSELECT TO_JSON(PARSE_JSON('null'))\nNULL\n\nSELECT TO_JSON(PARSE_JSON(null))\nnull\n\nSELECT TO_JSON(PARSE_JSON('[1,2,3]'))\n[1,2,3]\n\nSELECT TO_JSON(PARSE_JSON('{ \\\"a\\\": 1, \\\"b\\\": 2 }'))\n{\\\"a\\\":1,\\\"b\\\":2}\n\nSELECT PARSE_JSON('{ \\\"a\\\": 1, \\\"b\\\": 2 }') = PARSE_JSON('{\\\"b\\\":2,\\\"a\\\":1}')\ntrue\n\n-- dates are emitted as strings\nSELECT TO_JSON(CAST(DATE '2020-01-01' AS VARIANT))\n\"2020-01-01\"\n\n-- timestamps are emitted as strings\nSELECT TO_JSON(CAST(TIMESTAMP '2020-01-01 10:00:00' AS VARIANT))\n\"2020-01-01 10:00:00\"\n\n-- values with user-defined types can be converted to JSON\nCREATE TYPE S AS (i INT, s VARCHAR, a INT ARRAY);\nSELECT TO_JSON(CAST(s(2, 'a', ARRAY[1, 2, 3]) AS VARIANT));\n{\"a\":[1,2,3],\"i\":2,\"s\":\"a\"}\n\n-- The result of JSON parsing can be converted to user-defined types\nSELECT CAST(PARSE_JSON('{\"i\": 2, \"s\": \"a\", \"a\": [1, 2, 3]}') AS S);\n{a=[1,2,3], i=2, s=\"a\"}\n\n-- This works even for nested types, such as user-defined types that\n-- contain arrays of user-defined types\nCREATE TYPE t AS (sa S ARRAY);\nSELECT TO_JSON(CAST(t(ARRAY[s(2, 'a', ARRAY[1, NULL, 3]), s(3, 'b', array())]) AS VARIANT));\n{\"SA\":[{\"a\":[1,null,3],\"i\":2,\"s\":\"a\"},{\"a\":[],\"i\":3,\"s\":\"b\"}]}\n\nSELECT CAST(CAST(MAP['i', 0] AS VARIANT) AS S)\n-- produces a structure S(I=0, A=NULL, S=NULL); missing fields are set to 'NULL'\n\nSELECT CAST(CAST(MAP['i', 's'] AS VARIANT) AS S)\n-- produces a structure S(I=NULL, A=NULL, S=NULL), since the field 'I' has the wrong type\n\nSELECT CAST(CAST(MAP['I', 's'] AS VARIANT) AS S)\n-- produces a structure S(I=NULL, A=NULL, S=NULL), since the field 'i' is uppercase\n-- yet unquoted field names are converted to lowercase\n\nSELECT CAST(CAST(MAP['i', 0, 'X', 2] AS VARIANT) AS S)\n-- produces a structure S(I=NULL, A=NULL, S=NULL), since the extra field 'X' in the map is ignored\n\nSELECT CAST(PARSE_JSON('{\"sa\": [{\"i\": 2, \"s\": \"a\", \"a\": [1, 2, 3]}]}') AS T)\n-- produces a structure T(sa=[i=2, s=\"a\", \"a\"={1,2,3}])\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);